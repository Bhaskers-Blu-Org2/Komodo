#verbatim
function method banked_regs_framesize(): int { 18*4 }

predicate {:opaque} wellformed_banked_regs_stackframe(m:memstate, a:addr)
    requires ValidMemState(m)
{
    ValidMemRange(a, a + banked_regs_framesize())
    && forall i:int | 12 <= i <= 17 ::
        ValidPsrWord(MemContents(m, a + i * 4))
}

lemma lemma_wellformed_banked_regs_stackframe_preserved(m1:memstate, m2:memstate, a:addr)
    requires ValidMemState(m1) && ValidMemState(m2)
    requires wellformed_banked_regs_stackframe(m1, a)
    requires forall p:addr :: ValidMem(p) && (a <= p < a + banked_regs_framesize())
        ==> MemContents(m1, p) == MemContents(m2, p)
    ensures wellformed_banked_regs_stackframe(m2, a)
{
    reveal_wellformed_banked_regs_stackframe();
    forall i:int | 12 <= i <= 17
        ensures ValidPsrWord(MemContents(m2, a + i * 4));
    {
        assert MemContents(m1, a + i * 4) == MemContents(m2, a + i * 4);
    }
}

predicate {:opaque} banked_regs_stackframe(s:state, m:memstate, a:addr)
    requires ValidState(s) && ValidMemState(m)
    ensures banked_regs_stackframe(s,m,a) ==> wellformed_banked_regs_stackframe(m, a)
{
    reveal_ValidRegState();
    reveal_ValidSRegState();
    reveal_wellformed_banked_regs_stackframe();

    wellformed_banked_regs_stackframe(m, a)
    && MemContents(m, a+(0*4))  == s.regs[SP(User)]
    && MemContents(m, a+(1*4))  == s.regs[SP(FIQ)]
    && MemContents(m, a+(2*4))  == s.regs[SP(IRQ)]
    && MemContents(m, a+(3*4))  == s.regs[SP(Supervisor)]
    && MemContents(m, a+(4*4))  == s.regs[SP(Abort)]
    && MemContents(m, a+(5*4))  == s.regs[SP(Undefined)]

    && MemContents(m, a+(6*4))  == s.regs[LR(User)]
    && MemContents(m, a+(7*4))  == s.regs[LR(FIQ)]
    && MemContents(m, a+(8*4))  == s.regs[LR(IRQ)]
    && MemContents(m, a+(9*4))  == s.regs[LR(Supervisor)]
    && MemContents(m, a+(10*4)) == s.regs[LR(Abort)]
    && MemContents(m, a+(11*4)) == s.regs[LR(Undefined)]

    && MemContents(m, a+(12*4)) == s.sregs[spsr(FIQ)]
    && MemContents(m, a+(13*4)) == s.sregs[spsr(IRQ)]
    && MemContents(m, a+(14*4)) == s.sregs[spsr(Supervisor)]
    && MemContents(m, a+(15*4)) == s.sregs[spsr(Abort)]
    && MemContents(m, a+(16*4)) == s.sregs[spsr(Undefined)]
    && MemContents(m, a+(17*4)) == s.sregs[spsr(Monitor)]
}

lemma lemma_stackunstack_banked_regs(s1:state, m1:memstate, s2:state, m2:memstate, a:addr)
    requires SaneState(s1) && ValidMemState(m1) && SaneState(s2) && ValidMemState(m2)
    requires banked_regs_stackframe(s1, m1, a) && banked_regs_stackframe(s2, m2, a)
    requires forall p:addr :: ValidMem(p) && (a <= p < a + banked_regs_framesize())
        ==> MemContents(m1, p) == MemContents(m2, p)
    ensures BankedRegsInvariant(s1, s2) && SpsrsInvariant(s1, s2)
{
    reveal_wellformed_banked_regs_stackframe();
    reveal_ValidRegState();
    reveal_ValidSRegState();

    // sigh. help Dafny see that we're enumerating all constructors of a datatype
    assert forall m:mode {:trigger SP(m)} :: m.User? || m.FIQ? || m.IRQ? || m.Supervisor?
        || m.Abort? || m.Undefined? || m.Monitor?;

    forall m | m != Monitor
        ensures s1.regs[SP(m)] == s2.regs[SP(m)] && s1.regs[LR(m)] == s2.regs[LR(m)]
    {
        reveal_banked_regs_stackframe();
    }

    // double sigh. something's odd with triggering here, and we need a separate assert
    assert forall m:mode {:trigger spsr(m)} ::
        m.User? || m.FIQ? || m.IRQ? || m.Supervisor?
        || m.Abort? || m.Undefined? || m.Monitor?;

    forall m | m != User
        ensures s1.sregs[spsr(m)] == s2.sregs[spsr(m)]
    {
        reveal_banked_regs_stackframe();
    }
}
#endverbatim

procedure MRS_STR(
    {:operand} reg:int,
    {:operand} base:int,
    {:operand} ofs:int,
    {:operand} tmp:int)
    requires/ensures
        SaneState(this);
    requires
        ValidMrsMsrOperand(this, @reg);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidMem(base + ofs);
        ValidRegOperand(@tmp);
        @tmp != @sp && @tmp != @base && @tmp != @ofs;
    ensures
        RegPreservingExcept(old(this),this,set(@tmp));
        sp == old(sp);
        GlobalsInvariant(old(this),this);
        MemPreservingExcept(old(this), this, old(base+ofs), old(base+ofs+4));
        MemContents(this.m, old(base+ofs)) == old(reg);
{
    MRS(tmp, reg);
    STR(tmp, base, ofs);
}

procedure stack_banked_regs({:operand} tmp:int, ghost stack_bytes_in:int)
          returns (ghost stack_bytes:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@tmp);
        @tmp != @sp;
        stack_bytes_in >= banked_regs_framesize();
        StackBytesRemaining(this, stack_bytes_in);
    ensures
        sp == old(sp)-banked_regs_framesize();
        stack_bytes == stack_bytes_in-banked_regs_framesize();
        StackBytesRemaining(this,stack_bytes);
        banked_regs_stackframe(old(this), this.m, sp);
        RegPreservingExcept(old(this),this,set(@tmp,@sp));
        GlobalsInvariant(old(this),this);
        NonStackMemPreserving(old(this),this);
        ParentStackPreserving(old(this),this);
{
    SUB(sp, sp, sp_op_const(banked_regs_framesize()));
    stack_bytes := stack_bytes_in - banked_regs_framesize();

    ghost var start := this;

    MRS_STR(spsr_fiq, sp, sp_op_const(12*4), tmp);
    MRS_STR(spsr_irq, sp, sp_op_const(13*4), tmp);
    MRS_STR(spsr_svc, sp, sp_op_const(14*4), tmp);
    MRS_STR(spsr_abt, sp, sp_op_const(15*4), tmp);
    MRS_STR(spsr_und, sp, sp_op_const(16*4), tmp);
    MRS_STR(spsr_mon, sp, sp_op_const(17*4), tmp);

    ghost var midway := this;

    assert wellformed_banked_regs_stackframe(this.m, sp) by {
        reveal_wellformed_banked_regs_stackframe();
        forall i:int :| 12 <= i <= 17 :: ValidPsrWord(MemContents(this.m, sp + i * 4))
            { reveal_ValidSRegState(); }
    }
    assert RegPreservingExcept(start,this,set(@tmp));
    assert MemPreservingExcept(old(this), this, sp + 12*4, sp + 18*4);

    MRS_STR(sp_usr, sp, sp_op_const(0*4), tmp);
    MRS_STR(sp_fiq, sp, sp_op_const(1*4), tmp);
    MRS_STR(sp_irq, sp, sp_op_const(2*4), tmp);
    MRS_STR(sp_svc, sp, sp_op_const(3*4), tmp);
    MRS_STR(sp_abt, sp, sp_op_const(4*4), tmp);
    MRS_STR(sp_und, sp, sp_op_const(5*4), tmp);

    MRS_STR(lr_usr, sp, sp_op_const(6*4), tmp);
    MRS_STR(lr_fiq, sp, sp_op_const(7*4), tmp);
    MRS_STR(lr_irq, sp, sp_op_const(8*4), tmp);
    MRS_STR(lr_svc, sp, sp_op_const(9*4), tmp);
    MRS_STR(lr_abt, sp, sp_op_const(10*4), tmp);
    MRS_STR(lr_und, sp, sp_op_const(11*4), tmp);

    assert RegPreservingExcept(midway, this, set(@tmp));
    assert MemPreservingExcept(midway, this, sp, sp + 12*4);
    assert wellformed_banked_regs_stackframe(this.m, sp)
        by { reveal_wellformed_banked_regs_stackframe(); }
    assert banked_regs_stackframe(old(this), this.m, sp)
        by { reveal_banked_regs_stackframe(); }
}

procedure unstack_banked_regs({:operand} tmp:int, ghost stack_bytes_in:int)
          returns (ghost stack_bytes:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@tmp);
        @tmp != @sp;
        isUInt32(sp + banked_regs_framesize());
        sp + banked_regs_framesize() <= StackBase();
        StackBytesRemaining(this, stack_bytes_in);
        wellformed_banked_regs_stackframe(this.m, sp);
    ensures
        sp == old(sp)+banked_regs_framesize();
        stack_bytes == stack_bytes_in + banked_regs_framesize();
        StackBytesRemaining(this, stack_bytes);
        banked_regs_stackframe(this, old(this.m), old(sp));
        CoreRegPreservingExcept(old(this), this, set(@tmp,@sp));
        AllMemInvariant(old(this),this);

{
    reveal_banked_regs_stackframe();
    reveal_wellformed_banked_regs_stackframe();

    LDR(tmp, sp, sp_op_const(0*4));
    MSR(sp_usr, tmp);
    LDR(tmp, sp, sp_op_const(1*4));
    MSR(sp_fiq, tmp);
    LDR(tmp, sp, sp_op_const(2*4));
    MSR(sp_irq, tmp);
    LDR(tmp, sp, sp_op_const(3*4));
    MSR(sp_svc, tmp);
    LDR(tmp, sp, sp_op_const(4*4));
    MSR(sp_abt, tmp);
    LDR(tmp, sp, sp_op_const(5*4));
    MSR(sp_und, tmp);

    LDR(tmp, sp, sp_op_const(6*4));
    MSR(lr_usr, tmp);
    LDR(tmp, sp, sp_op_const(7*4));
    MSR(lr_fiq, tmp);
    LDR(tmp, sp, sp_op_const(8*4));
    MSR(lr_irq, tmp);
    LDR(tmp, sp, sp_op_const(9*4));
    MSR(lr_svc, tmp);
    LDR(tmp, sp, sp_op_const(10*4));
    MSR(lr_abt, tmp);
    LDR(tmp, sp, sp_op_const(11*4));
    MSR(lr_und, tmp);

    LDR(tmp, sp, sp_op_const(12*4));
    MSR(spsr_fiq, tmp);
    LDR(tmp, sp, sp_op_const(13*4));
    MSR(spsr_irq, tmp);
    LDR(tmp, sp, sp_op_const(14*4));
    MSR(spsr_svc, tmp);
    LDR(tmp, sp, sp_op_const(15*4));
    MSR(spsr_abt, tmp);
    LDR(tmp, sp, sp_op_const(16*4));
    MSR(spsr_und, tmp);
    LDR(tmp, sp, sp_op_const(17*4));
    MSR(spsr_mon, tmp);

    ADD(sp, sp, sp_op_const(banked_regs_framesize()));
    stack_bytes := stack_bytes_in + banked_regs_framesize();
}

procedure smc_enter_err(
    {:register OReg(R0)} callno:int,
    {:register OReg(R1)} pagenr:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        callno == KOM_SMC_ENTER() || callno == KOM_SMC_RESUME();
    ensures
        AllMemInvariant(old(this),this);
        RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
        SmcProcedureInvariant(old(this), this);
        err == smc_enter_err(pagedb, old(pagenr), old(callno) == KOM_SMC_RESUME());
{
    if (pagenr >= sp_op_const(KOM_SECURE_NPAGES())) {
        assert !validPageNr(pagenr);
        err := sp_op_const(KOM_ERR_INVALID_PAGENO());
    } else {
        assert validPageNr(pagenr);
        LDRglobaladdr(r12, PageDb());
        lemma_LeftShift3(pagenr);
        LSL(r10, pagenr, sp_op_const(PAGEDB_ENTRY_SHIFT()));
        assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
        WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_TYPE(), r10);
        LDRglobal(r9, PageDb(), r12, r10);
        assert r9 == GlobalWord(this.m, PageDb(), r10);
        assert pageDbEntryCorresponds(pagedb[pagenr], extractPageDbEntry(this.m, pagenr))
            by { reveal_validPageDb(); }
        assert r9 == pageDbEntryTypeVal(pagedb[pagenr]) by {
            reveal_pageDbEntryCorresponds();
            extractPageDbToAbstractOne(this.m, pagenr, PAGEDB_ENTRY_TYPE());
            assert GlobalWord(this.m, PageDb(), r10) == 
                pageDbEntryTypeVal(pagedb[pagenr]);
        }
        assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
        if( r9 != sp_op_const(KOM_PAGE_DISPATCHER()) ) {
            assert !(pagedb[pagenr] is PageDbEntryTyped && pagedb[pagenr].entry is Dispatcher);
            err := sp_op_const(KOM_ERR_INVALID_PAGENO());
        } else {
            assert pagedb[pagenr] is PageDbEntryTyped && pagedb[pagenr].entry is Dispatcher;

            ADD(r10, r10, sp_op_const(PAGEDB_ENTRY_ADDRSPACE()));
            assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
            WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE(), r10);
           
            LDRglobal(r8, PageDb(), r12, r10);
            ghost var addrspace := pagedb[pagenr].addrspace;
            assert validPageNr(addrspace) by { reveal_validPageDb(); }
            assert r8 == page_monvaddr(addrspace) && WordAligned(r8) by {
                reveal_pageDbEntryCorresponds();
                reveal_validPageDb();
                assert pageDbCorrespondsOnly(this.m, pagedb, pagenr);
                ghost var entryWords := extractPageDbEntry(this.m, pagenr);
                assert entryWords[BytesToWords(PAGEDB_ENTRY_ADDRSPACE())] == 
                    page_monvaddr(pagedb[pagenr].addrspace);
                               
                extractPageDbToAbstractOne(this.m, pagenr, PAGEDB_ENTRY_ADDRSPACE());

                assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
                assert entryWords[BytesToWords(PAGEDB_ENTRY_ADDRSPACE())] ==
                    GlobalWord(this.m, PageDb(), r10);
                assert GlobalWord(this.m, PageDb(), r10) == 
                    page_monvaddr(pagedb[pagenr].addrspace);
            }
            WordAlignedAdd_(r8,ADDRSPACE_STATE(),r8+ADDRSPACE_STATE());
           
            assert ValidMem(r8 + ADDRSPACE_STATE()) by { reveal_validPageDb(); }
            LDR(r8, r8, sp_op_const(ADDRSPACE_STATE()));
            assert r8 == KOM_ADDRSPACE_FINAL()
                <==> pagedb[addrspace].entry.state == FinalState
            by {
                reveal_validPageDb();
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            // this particular RegPreserving assert saved 30s.
            assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
            if( r8 != sp_op_const(KOM_ADDRSPACE_FINAL()) ) {
                err := sp_op_const(KOM_ERR_NOT_FINAL());
            } else {
                assert this.m == old(this.m);
                assert SaneState(this);
                page_monvaddr_impl(r9,pagenr,r10);
                assert r9 == page_monvaddr(pagenr);
                assert MemContents(this.m, page_monvaddr(pagenr) + 
                    DISPATCHER_ENTERED()) == to_i(pagedb[pagenr].entry.entered)
                by {
                    reveal_pageContentsCorresponds();
                    reveal_pageDbDispatcherCorresponds();
                }
                LDR(r9,r9,sp_op_const(DISPATCHER_ENTERED()));
                
                assert r9 == 1 <==> pagedb[pagenr].entry.entered;
                assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));

                assert callno == old(callno);
                if (callno == sp_op_const(KOM_SMC_RESUME())) {
                    // smc_resume
                    if( r9 != 1 ) {
                        err := sp_op_const(KOM_ERR_NOT_ENTERED());
                    } else {
                        err := sp_op_const(KOM_ERR_SUCCESS());
                    }
                } else {
                    // smc_enter
                    if( r9 == 1 ) {
                        err := sp_op_const(KOM_ERR_ALREADY_ENTERED());
                    } else {
                        err := sp_op_const(KOM_ERR_SUCCESS());
                    }
                }
            }
        }
    }
}

#verbatim
lemma lemma_scr_entry(pre: word, post: word)
    requires post == BitwiseOr(BitwiseAnd(pre, 0xfffffffe), 6)
    ensures decode_scr(post) == SCR(Secure, true, true)
{
    assert WordAsBits(1) == 1 && WordAsBits(2) == 2 && WordAsBits(4) == 4
           && WordAsBits(6) == 6 && WordAsBits(0xfffffffe) == 0xfffffffe
        by { reveal_WordAsBits(); }
    lemma_WordBitEquiv(1,1);

    calc {
        post;
        BitwiseOr(BitwiseAnd(pre, 0xfffffffe), 6);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitOr(BitAnd(WordAsBits(pre), 0xfffffffe), 6));
    }

    calc {
        BitwiseAnd(post, 1);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitAnd(BitOr(BitAnd(WordAsBits(pre), 0xfffffffe), 6), 1));
        { reveal_BitAnd(); reveal_BitOr(); }
        BitsAsWord(0);
    }

    var x := BitAnd(WordAsBits(pre), 0xfffffffe);

    calc {
        BitwiseAnd(post, 2);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitAnd(BitOr(BitAnd(WordAsBits(pre), 0xfffffffe), 6), 2));
        BitsAsWord(BitAnd(BitOr(x, 6), 2));
        { lemma_BitOrAndRelation(x, 6, 2); }
        BitsAsWord(BitOr(BitAnd(x, 2), BitAnd(6, 2)));
        { reveal_BitAnd(); }
        BitsAsWord(BitOr(BitAnd(x, 2), 2));
        != { reveal_BitOr(); }
        BitsAsWord(0);
    }

    calc {
        BitwiseAnd(post, 4);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitAnd(BitOr(BitAnd(WordAsBits(pre), 0xfffffffe), 6), 4));
        BitsAsWord(BitAnd(BitOr(x, 6), 4));
        { lemma_BitOrAndRelation(x, 6, 4); }
        BitsAsWord(BitOr(BitAnd(x, 4), BitAnd(6, 4)));
        { reveal_BitAnd(); }
        BitsAsWord(BitOr(BitAnd(x, 4), 4));
        != { reveal_BitOr(); }
        BitsAsWord(0);
    }
}

lemma lemma_scr_exit(pre: word, post: word)
    requires post == BitwiseOr(BitwiseAnd(pre, 0xfffffff9), 1)
    ensures decode_scr(post) == SCR(NotSecure, false, false)
{
    assert WordAsBits(1) == 1 && WordAsBits(2) == 2 && WordAsBits(4) == 4
           && WordAsBits(0xfffffff9) == 0xfffffff9
        by { reveal_WordAsBits(); }
    lemma_WordBitEquiv(1,1);

    calc {
        post;
        BitwiseOr(BitwiseAnd(pre, 0xfffffff9), 1);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitOr(BitAnd(WordAsBits(pre), 0xfffffff9), 1));
    }

    calc {
        BitwiseAnd(post, 1);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitAnd(BitOr(BitAnd(WordAsBits(pre), 0xfffffff9), 1), 1));
        { reveal_BitAnd(); reveal_BitOr(); }
        BitsAsWord(1);
    }

    calc {
        BitwiseAnd(post, 2);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitAnd(BitOr(BitAnd(WordAsBits(pre), 0xfffffff9), 1), 2));
        { reveal_BitAnd(); reveal_BitOr(); }
        BitsAsWord(0);
    }

    calc {
        BitwiseAnd(post, 4);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitAnd(BitOr(BitAnd(WordAsBits(pre), 0xfffffff9), 1), 4));
        { reveal_BitAnd(); reveal_BitOr(); }
        BitsAsWord(0);
    }
}
#endverbatim

procedure switch_addrspace(
    {:register OReg(R1)} pagenr:int,
    ghost isresume:bool,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validPageNr(pagenr);
        validDispatcherPage(pagedb, pagenr);
        !hasStoppedAddrspace(pagedb, pagenr);
    ensures
        AllMemInvariant(old(this),this);
        CoreRegPreservingExcept(old(this), this, set(@r10,@r11,@r12));
        BankedRegsInvariant(old(this),this);
        this.conf.ttbr0.ptbase == page_paddr(l1pOfDispatcher(pagedb, pagenr));
        this.conf.scr.ns == Secure && this.conf.scr.irq && this.conf.scr.fiq;
{
    //-------------------------------------------------------------------------
    // update SCR
    //-------------------------------------------------------------------------

    // read SCR
    MRC(r10, OSReg(scr));
    ghost var old_scr := r10;

    // clear NS bit
    AND(r10, r10, 0xfffffffe);

    // set IRQ and FIQ bits
    ORR(r10, r10, 6);

    // write SCR
    lemma_scr_entry(old_scr, r10);
    MCR(OSReg(scr), r10);
    assert this.conf.scr.ns == Secure;

    //-------------------------------------------------------------------------
    // load l1p into ttbr0
    //-------------------------------------------------------------------------
    ghost var addrspace := pagedb[pagenr].addrspace;
    assert validAddrspacePage(pagedb, addrspace) by { reveal_validPageDb(); }
    ghost var l1p := l1pOfDispatcher(pagedb, pagenr);

    r11 := sp_op_const(PAGEDB_ENTRY_SIZE());
    MUL(r10,pagenr,r11);
    assert r10 == G_PAGEDB_ENTRY(pagenr);
    ADD(r10, r10, sp_op_const(PAGEDB_ENTRY_ADDRSPACE())); 
    assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
    WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE(), r10);

    LDRglobaladdr(r12, PageDb());
    LDRglobal(r11, PageDb(), r12, r10);
    assert r11 == page_monvaddr(addrspace) by {
        reveal_pageDbEntryCorresponds();
        assert validAddrspacePage(pagedb, addrspace);
    }

    LDR(r10,r11,sp_op_const(ADDRSPACE_L1PT_PHYS()));

    assert r10 == page_paddr(pagedb[addrspace].entry.l1ptnr) by {
        assert pageDbAddrspaceCorresponds(addrspace, pagedb[addrspace].entry,
            extractPage(this.m, addrspace))
        by {
            assert validAddrspacePage(pagedb, addrspace);
            assert pageDbCorrespondsOnly(this.m, pagedb, addrspace);
            reveal_pageContentsCorresponds();
        }
        reveal_pageDbAddrspaceCorresponds();
    }

    assert r10 == page_paddr(l1p);
    assert PageAligned(r10);
    MCR(OSReg(ttbr0), r10);
    assert this.conf.ttbr0.ptbase == page_paddr(l1p);
}

procedure leave_secure_world({:operand} tmp:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@tmp) && @tmp != @sp;
    ensures
        AllMemInvariant(old(this),this);
        CoreRegPreservingExcept(old(this), this, set(@tmp));
        BankedRegsInvariant(old(this),this);
        SpsrsInvariant(old(this), this);
        this.conf.scr.ns == NotSecure && !this.conf.scr.irq && !this.conf.scr.fiq;
{
    // read SCR
    MRC(tmp, OSReg(scr));
    ghost var old_scr := tmp;

    // clear IRQ and FIQ bits
    AND(tmp, tmp, 0xfffffff9);

    // set NS bit
    ORR(tmp, tmp, 1);

    // write SCR
    lemma_scr_exit(old_scr, tmp);
    MCR(OSReg(scr), tmp);
}

#verbatim
predicate SpsrsInvariant(s:state, r:state)
    requires ValidState(s) && ValidState(r)
{
    reveal_ValidSRegState();
    forall m | m != User :: s.sregs[spsr(m)] == r.sregs[spsr(m)]
}

predicate EnterResumeSmcProcedureInvariant(s:state, r:state)
    requires SaneState(s) && SaneState(r)
{
    mode_of_state(r) == mode_of_state(s) // implied by SaneState
        && StackPreserving(s,r)
        && BankedRegsInvariant(s, r)
        && SpsrsInvariant(s, r)
        && r.conf.scr.ns == NotSecure
}
#endverbatim

procedure pre_entry_enter(
    {:register OReg(R1)} pagenr:int,
    {:register OReg(R2)} arg1:int,
    {:register OReg(R3)} arg2:int,
    {:register OReg(R4)} arg3:int,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        smc_enter_err(pagedb, pagenr, false) == KOM_ERR_SUCCESS();
    ensures
        AddrMemInvariant(old(this),this);
        GlobalsPreservingExcept(old(this),this, set(CurDispatcherOp()));
        pageDbCorresponds(this.m, pagedb);
        StackPreserving(old(this),this);
        BankedRegsInvariant(old(this),this);
        preEntryEnter(old(this), this, pagedb, pagenr, arg1, arg2, arg3);
        spsr_of_state(this).m == User;
        sp == old(sp);
{
    assert validPageNr(pagenr);
    assert validDispatcherPage(pagedb, pagenr);
    assert !hasStoppedAddrspace(pagedb, pagenr);
    ghost var l1p := l1pOfDispatcher(pagedb, pagenr);

    //-------------------------------------------------------------------------
    //  Switch addrspace
    //-------------------------------------------------------------------------
    switch_addrspace(pagenr, false, pagedb);
    assert pagenr == old(pagenr);

    //-------------------------------------------------------------------------
    // Set SPSR to Usermode
    //-------------------------------------------------------------------------
    r10 := 0x10;
    assert psr_mask_mode(0x10) == 0x10 by {
        assert WordAsBits(0x10) == 0x10 && WordAsBits(0x1f) == 0x1f
            by { reveal WordAsBits; }
        assert BitAnd(0x10, 0x1f) == 0x10 by { reveal BitAnd; }
        lemma_WordBitEquiv(0x10, 0x10);
    }
    assert decode_mode(psr_mask_mode(r10)) == User;
    assert ValidModeChange'(this, User);
    assert ValidModeChange(this, r10);
    MSR(spsr_mon, r10);
    assert spsr_of_state(this).m == User;
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Load entrypoint into LR
    //-------------------------------------------------------------------------
    page_monvaddr_impl(r10,pagenr,r11);
    LDR(lr,r10,sp_op_const(DISPATCHER_ENTRYPOINT()));
    assert lr == pagedb[pagenr].entry.entrypoint
    by {
        assert pageDbCorrespondsOnly(this.m,pagedb,pagenr);
        assert validDispatcherPage(pagedb,pagenr);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(pagenr,pagedb[pagenr],
            extractPage(this.m,pagenr));
        reveal_pageDbDispatcherCorresponds();
    }

    //-------------------------------------------------------------------------
    // Update current dispatcher
    //-------------------------------------------------------------------------
    LDRglobaladdr(r12, CurDispatcherOp());
    STRglobal(r10, CurDispatcherOp(), r12, 0);

    //-------------------------------------------------------------------------
    //  Move arguments to regs
    //-------------------------------------------------------------------------
    r0 := arg1;
    r1 := arg2;
    r2 := arg3;
    // XXX: TODO (also in spec): zero other regs!
    //-------------------------------------------------------------------------
    lemma_SameMemAndGlobalsPreservesPageDb'(old(this), this, pagedb);
}

procedure pre_entry_resume(
    {:register OReg(R1)} pagenr:int,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        smc_enter_err(pagedb, pagenr, true) == KOM_ERR_SUCCESS();
    ensures
        AddrMemInvariant(old(this),this);
        GlobalsPreservingExcept(old(this),this, set(CurDispatcherOp()));
        pageDbCorresponds(this.m, pagedb);
        StackPreserving(old(this),this);
        preEntryResume(old(this), this, pagedb, pagenr);
        spsr_of_state(this).m == User;
        sp == old(sp);
{
    ghost var dispPg := pagenr;
    assert validPageNr(dispPg);
    assert validDispatcherPage(pagedb, dispPg);
    assert !hasStoppedAddrspace(pagedb, dispPg);

    //-------------------------------------------------------------------------
    //  Switch addrspace
    //-------------------------------------------------------------------------
    switch_addrspace(pagenr, true, pagedb);
    assert pagenr == old(pagenr);

    //-------------------------------------------------------------------------
    // Update current dispatcher
    //-------------------------------------------------------------------------
    page_monvaddr_impl(lr,pagenr,r0);
    LDRglobaladdr(r2, CurDispatcherOp());
    STRglobal(lr, CurDispatcherOp(), r2, 0);
    // help dafny see pagedb invariant
    globalUnmodifiedImpliesCorrespondingPreserved(pagedb,old(this).m,this.m);

    //-------------------------------------------------------------------------
    // Restore SPSR
    //-------------------------------------------------------------------------
    assert validDispatcherContext(pagedb[dispPg].entry.ctxt) by { reveal_validPageDb(); }

    LDR(r0,lr,sp_op_const(DISP_CTXT_PSR()));
    assert r0 == pagedb[dispPg].entry.ctxt.cpsr by
    {
        assert pageDbCorrespondsOnly(this.m,pagedb,dispPg);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(dispPg,pagedb[dispPg],
            extractPage(this.m,dispPg));
        reveal_pageDbDispatcherCorresponds();
    }

    assert decode_mode'(psr_mask_mode(pagedb[dispPg].entry.ctxt.cpsr)) == Just(User);
    MSR(OSReg(spsr(Monitor)),r0);
    assert this.sregs[spsr(Monitor)] == pagedb[dispPg].entry.ctxt.cpsr;
    assert spsr_of_state(this).m == User;

    //-------------------------------------------------------------------------
    // Restore integer context
    //-------------------------------------------------------------------------
    ghost var disp := pagedb[dispPg].entry;

    LDR(r0,lr,sp_op_const(DISP_CTXT_LR()));
    MSR(lr_usr,r0);

    LDR(r0,lr,sp_op_const(DISP_CTXT_SP()));
    MSR(sp_usr,r0);

    LDR(r0,lr,sp_op_const(DISP_CTXT_R0()));
    LDR(r1,lr,sp_op_const(DISP_CTXT_R1()));
    LDR(r2,lr,sp_op_const(DISP_CTXT_R2()));
    LDR(r3,lr,sp_op_const(DISP_CTXT_R3()));
    LDR(r4,lr,sp_op_const(DISP_CTXT_R4()));
    LDR(r5,lr,sp_op_const(DISP_CTXT_R5()));
    LDR(r6,lr,sp_op_const(DISP_CTXT_R6()));
    LDR(r7,lr,sp_op_const(DISP_CTXT_R7()));
    LDR(r8,lr,sp_op_const(DISP_CTXT_R8()));
    LDR(r9,lr,sp_op_const(DISP_CTXT_R9()));
    LDR(r10,lr,sp_op_const(DISP_CTXT_R10()));
    LDR(r11,lr,sp_op_const(DISP_CTXT_R11()));
    LDR(r12,lr,sp_op_const(DISP_CTXT_R12()));
    LDR(lr,lr,sp_op_const(DISP_CTXT_PC()));

    reveal_ValidRegState(); 
    assert r0 == disp.ctxt.regs[R0] && r1 == disp.ctxt.regs[R1] &&
           r2 == disp.ctxt.regs[R2] && r3 == disp.ctxt.regs[R3] &&
           r4 == disp.ctxt.regs[R4] && r5 == disp.ctxt.regs[R5] &&
           r6 == disp.ctxt.regs[R6] && r7 == disp.ctxt.regs[R7] &&
           r8 == disp.ctxt.regs[R8] && r9 == disp.ctxt.regs[R9] &&
           r10 == disp.ctxt.regs[R10] && r11 == disp.ctxt.regs[R11] &&
           r12 == disp.ctxt.regs[R12]
           && this.regs[LR(User)] == disp.ctxt.regs[LR(User)]
           && this.regs[SP(User)] == disp.ctxt.regs[SP(User)]
           && lr == pagedb[dispPg].entry.ctxt.pc
    by {
        assert pageDbCorrespondsOnly(this.m,pagedb,dispPg);
        assert validDispatcherPage(pagedb,dispPg);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(dispPg,pagedb[dispPg],
            extractPage(this.m,dispPg));
        reveal_pageDbDispatcherCorresponds();
    }
}

#verbatim
lemma lemma_ValidEntryPost(s:state, sd:PageDb, r1:state, rd:PageDb, r2:state, dp:word,
                           a1:word, a2:word, a3:word)
    requires ValidState(s) && ValidState(r1) && ValidState(r2) && validPageDb(sd)
    requires validExceptionTransition(SysState(r1, rd), SysState(r2, rd), dp)
    requires OperandContents(r1, OReg(R0)) == OperandContents(r2, OReg(R0))
    requires OperandContents(r1, OReg(R1)) == OperandContents(r2, OReg(R1))
    ensures smc_enter(s, sd, r1, rd, dp, a1, a2, a3)
        ==> smc_enter(s, sd, r2, rd, dp, a1, a2, a3)
    ensures smc_resume(s, sd, r1, rd, dp) ==> smc_resume(s, sd, r2, rd, dp)
{
    reveal_ValidRegState();

    if smc_enter(s, sd, r1, rd, dp, a1, a2, a3) {
        if smc_enter_err(sd, dp, false) == KOM_ERR_SUCCESS() {
            lemma_validEnterPost(s, sd, r1, rd, r2, dp, a1, a2, a3);
        }
    }

    if smc_resume(s, sd, r1, rd, dp) {
        if smc_enter_err(sd, dp, true) == KOM_ERR_SUCCESS() {
            lemma_validResumePost(s, sd, r1, rd, r2, dp);
        }
    }
}
#endverbatim

procedure smc_enterresume_success(
    {:register OReg(R1)} pagenr:int,
    {:register OReg(R2)} arg1:int,
    {:register OReg(R3)} arg2:int,
    {:register OReg(R4)} arg3:int,
    {:register OReg(R5)} callno:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost pagedb_in: PageDb,
    ghost stack_bytes: int)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        stack_bytes >= banked_regs_framesize();
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        AUCIdef();
        callno == KOM_SMC_ENTER() || callno == KOM_SMC_RESUME();
        smc_enter_err(pagedb_in, pagenr, callno == KOM_SMC_RESUME()) == KOM_ERR_SUCCESS();
    ensures
        EnterResumeSmcProcedureInvariant(old(this), this);
        if old(callno) == KOM_SMC_ENTER() then
            validEnter(SysState(old(this), pagedb_in), SysState(this, pagedb),
                       old(pagenr),old(arg1),old(arg2),old(arg3))
        else
            validResume(SysState(old(this), pagedb_in), SysState(this, pagedb),
                        old(pagenr));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    ghost var dispPg := old(pagenr);
    ghost var isEnter := old(callno) == KOM_SMC_ENTER();
    ghost var exs;
    assert nonStoppedDispatcher(pagedb, dispPg);

    ghost var stack_bytes_local;
    stack_bytes_local := stack_banked_regs(r0, stack_bytes);
    lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb);

    ghost var s0 := this;

    if (callno == sp_op_const(KOM_SMC_ENTER())) {
        pre_entry_enter(pagenr,arg1,arg2,arg3,pagedb);
        assert preEntryEnter(old(this),this,pagedb,dispPg,old(arg1),old(arg2),old(arg3));
    } else {
        pre_entry_resume(pagenr,pagedb);
        assert preEntryResume(old(this),this,pagedb,dispPg);
    }

    ghost var s1 := this;

    MOVS_PCLR_TO_USERMODE_AND_CONTINUE();
    lemma_evalMOVSPCLRUC(s1, this, pagedb_in, dispPg);

    if ghost (isEnter) {
        exs, pagedb := lemma_validEnter(s0, s1, this, pagedb_in, dispPg,
                                        old(arg1), old(arg2), old(arg3));
    } else {
        exs, pagedb := lemma_validResume(s0, s1, this, pagedb_in, dispPg);
    }

    ghost var s6 := this;
    ghost var s6_sp := sp;

    lemma_wellformed_banked_regs_stackframe_preserved(s0.m, this.m, sp);
    stack_bytes_local := unstack_banked_regs(r2, stack_bytes_local);
    assert stack_bytes_local == stack_bytes;
    lemma_SameMemAndGlobalsPreservesPageDb(s6, this, pagedb);

    assert StackPreserving(old(this), this);
    lemma_stackunstack_banked_regs(old(this), s0.m, this, s6.m, s6_sp);

    leave_secure_world(r2);

    lemma_ValidEntryPre(old(this), s0, pagedb_in, s6, pagedb, dispPg,
                            old(arg1), old(arg2), old(arg3));

    assert validExceptionTransition(SysState(s6, pagedb), SysState(this, pagedb), dispPg)
        by { reveal_validExceptionTransition(); }
    lemma_ValidEntryPost(old(this), pagedb_in, s6, pagedb, this,
                         dispPg, old(arg1), old(arg2), old(arg3));
}

procedure kom_smc_enterresume(
    {:register OReg(R0)} callno:int,
    {:register OReg(R1)} disppg:int,
    {:register OReg(R2)} arg1:int,
    {:register OReg(R3)} arg2:int,
    {:register OReg(R4)} arg3:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost pagedb_in:PageDb,
    ghost stack_bytes: int)
    returns (ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        stack_bytes >= banked_regs_framesize();
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        AUCIdef();
        this.conf.scr.ns == NotSecure; // FIXME: cleanup
        callno == KOM_SMC_ENTER() || callno == KOM_SMC_RESUME();
    ensures
        EnterResumeSmcProcedureInvariant(old(this), this);
        if old(callno) == KOM_SMC_ENTER() then
            smc_enter(old(this), pagedb_in, this, pagedb, old(disppg),
                      old(arg1), old(arg2), old(arg3))
        else
            smc_resume(old(this), pagedb_in, this, pagedb, old(disppg));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    r5 := callno;
    smc_enter_err(callno,disppg,err,pagedb_in);
    if(err != sp_op_const(KOM_ERR_SUCCESS()) ) {
        pagedb := pagedb_in;
        val := 0;
    } else {
        ghost var s0 := this;
        pagedb := smc_enterresume_success(disppg, arg1, arg2, arg3, r5, err, val,
                                          pagedb_in, stack_bytes);
        lemma_ValidEntryPre(old(this), s0, pagedb_in, this, pagedb, old(disppg),
                            old(arg1), old(arg2), old(arg3));
    }
}
