procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV

procedure reg_preservation_inner(ghost stack_bytes:int)
    requires
        stack_bytes >= 40;
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
        can_fcall_n(this,stack_bytes);
    ensures
        MemValidityPreserving(old(this),this);
        StackValuePreserving(old(this),this,stack_bytes);
        RegPreserving(old(this),this);
        NonStackValuePreserving(old(this),this);
{
    fcall_prologue(stack_bytes);
    r10 := 99;
    fcall_epilogue(stack_bytes-40);
}

procedure reg_preservation_test(ghost stack_bytes:int)
    requires
        stack_bytes >= 80;
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
        can_fcall_n(this,stack_bytes);
    ensures
        MemValidityPreserving(old(this),this);
        StackValuePreserving(old(this),this,stack_bytes);
        RegPreserving(old(this),this);
        NonStackValuePreserving(old(this),this);
{
    fcall_prologue(stack_bytes);
    r10 := 3000;
    r4  := 98;
    reg_preservation_inner(stack_bytes-40);
    fcall_epilogue(stack_bytes-40);
}

procedure main()
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
        can_fcall_n(this,80);
        ValidMem(this,Address(4));
    ensures
        r4 == 10;
        addrval(this,4) == 5;
{
    r4 := 10;
    STR(5,4,0);
    reg_preservation_test(80);
    
    // r4 wasn't clobbered!
    assert r4 == 10;
    // Address(4) wasn't clobbered!
    assert addrval(this,4) == 5;
}

#verbatim

method Main()
{
  printHeader("fcall_example");
  var n := printCode(sp_code_main(), 0);
  printFooter();
}
#endverbatim
