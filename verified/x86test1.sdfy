procedure wrapIncr(ghost g1:int, inout{:operand} o:int, ghost g2:int, {:register var_ecx()} c:int, ghost g3:int, {:inline} k:int) returns (ghost b:bool)
  requires
    Valid32BitDestinationOperand(this, @o);
    0 <= o <= 1000;
    0 <= k <= 10;
  ensures
    ValidOperand(this, @o);
    o == old(o) + 1 + 2 * k;
{
  incr(o);

  // these two are equivalent:
  Add32(o, k);
  Add32(o, fromOperand(OConst(k)));
}

procedure foo(ghost x:int, inout{:register var_eax()} a:int) returns(ghost y:int)
  requires
    ValidOperand(this, var_eax());
    x < 100;
    a == eax;
    1 <= eax;
    eax < 10;
  ensures
    ValidOperand(this, var_eax());
    1 <= eax;
    eax == old(eax);
    y == x;
{
  y := x;
  ghost var z1 := x;
  ghost var z2:int := x;
  assert y == z1;
  ghost var a1 := eax;

  var{:register var_eax()} i:int;

  if (i <= i)
  {
    incr(i);
    assert i == a1 + 1;
    assert i == old(a) + 1;
    ghost var s1 := this;
    assert i == old[s1](i);
    decr(a);
    assert i == old[s1](i) - 1;
  }
  else if (i >= i)
  {
    assert true;
  }
  else
  {
    ghost var b;
    b := wrapIncr(3, eax, 4, ecx, 5, 6);
    incr(i);
  }
}

procedure p()
  requires/ensures
    ValidOperand(this, var_eax());
  requires
    eax < 100;
  modifies
    eax;
  requires
    eax >= 0;
  ensures
    eax >= 2;
{
  incr(eax);
  incr(eax);
}

#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := Mov32
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := Add32

procedure main()
  requires/ensures
    ValidOperand(this, var_eax());
    ValidOperand(this, var_ecx());
  requires
    2 <= eax;
    eax < 10;
  ensures
       eax == old(eax) + 2
    || eax == old(eax) - 2;
{
  for (ecx := 0; ecx < 10; ecx++)
    invariant
      ValidOperand(this, var_eax());
      ValidOperand(this, var_ecx());
      ecx <= 10;
      eax == old(eax);
    decreases 10 - ecx;
  {
  }
  assert ecx == 10;

  if (eax <= eax)
  {
    //eax += ebx;
    //add(eax, ebx);
    assert eax <= eax;
    incr(eax);
    incr(eax);
  }
  else if (eax >= eax)
  {
    //Add32(eax, 2);
    eax += 2;
  }
  else
  {
    decr(eax);
    decr(eax);
  }
}

#verbatim
method Main()
{
  printHeader();
  var n := printCode(sp_code_main(), 0);
  printFooter();
}
#endverbatim

