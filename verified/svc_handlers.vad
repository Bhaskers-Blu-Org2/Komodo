include {:verbatim} "kom_common.i.dfy"
include "valedecls.vad"
include "attest.vad"
include "verify.vad"
include "map_common.vad"
include "init_l2ptable.vad"

procedure svc_return_epilog()
    requires/ensures
        !interrupts_enabled(this);
        mode_of_state(this) == Monitor;
    modifies
         r1; r2; r3; r4; r5; r6; r7; r8; spsr_mon;
    ensures
        r1 == r2 == r3 == r4 == r5 == r6 == r7 == r8 == 0;
        spsr_mon == encode_mode(User);
{
    MOV(r1, const(encode_mode(User)));
    lemma_user_psr();
    MSR(spsr_mon, r1);

    MOV(r1, 0);
    MOV(r2, 0);
    MOV(r3, 0);
    MOV(r4, 0);
    MOV(r5, 0);
    MOV(r6, 0);
    MOV(r7, 0);
    MOV(r8, 0);
}

procedure svc_returning_default(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; spsr_mon;
    requires/ensures
        SaneState(this);
    requires
        ValidState(exstate) && mode_of_state(exstate) != User;
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        finalDispatcher(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        !(set(KOM_SVC_ATTEST, KOM_SVC_VERIFY_STEP0, KOM_SVC_VERIFY_STEP1,
              KOM_SVC_VERIFY_STEP2, KOM_SVC_MAP_DATA, KOM_SVC_UNMAP_DATA,
              KOM_SVC_INIT_L2PTABLE) ?[r0]);
    ensures
        let tuple := svcHandled(exstate, pagedb, dispPg) in
        let retRegs := firstOf2(tuple) in
        preEntryReturnRegsMatch(this, retRegs);
        spsr_mon == encode_mode(User);
{
    // Fall back position
    assert firstOf2(svcHandled(exstate, pagedb, dispPg))
            == tuple(KOM_ERR_INVALID,0,0,0,0,0,0,0,0);

    svc_return_epilog();
    MOV(r0, const(KOM_ERR_INVALID));
}

#verbatim
lemma lemma_svc_returning_verify_step0_helper(s:state, pagedb:PageDb, dispPg:PageNr, m1:memstate,
    m2:memstate, user_words:seq<word>, pagedb':PageDb, disp:PageDbEntryTyped, pg:memmap)
    requires SaneState(s);
    requires m1 == s.m;
    requires validPageDb(pagedb)
    requires pageDbCorresponds(m1, pagedb)
    requires finalDispatcher(pagedb, dispPg)
    requires |user_words| == 8
    requires pagedb' == pagedb[dispPg := pagedb[dispPg].(entry := pagedb[dispPg].entry.(verify_words := user_words))]
    requires disp == pagedb'[dispPg].entry
    requires ValidMemState(m1) && ValidMemState(m2)
    requires pg == extractPage(m2, dispPg)
    requires
        forall i :: ValidMem(i) && !(0 <= i - WordAlignedAdd(page_monvaddr(dispPg), DISP_CTXT_USER_WORDS) <= WordsToBytes(7)) ==> MemContents(m1, i) == MemContents(m2, i)
    requires
        forall i :: 0 <= i < 8 ==>
            var a := WordOffset(WordAlignedAdd(page_monvaddr(dispPg), DISP_CTXT_USER_WORDS), i);
            MemContents(m2, a) == user_words[i]
    ensures pageDbDispatcherCorresponds(dispPg, disp, pg)
    ensures finalDispatcher(pagedb', dispPg)
{
    assert pageDbDispatcherCorresponds(dispPg, disp, pg) by
    {
        reveal pageContentsCorresponds();
        reveal pageDbDispatcherCorresponds();
        reveal pageDbDispatcherContextCorresponds();
        reveal pageDbDispatcherVerifyStateCorresponds();

    }

    reveal validPageDb();

    forall n:PageNr | n != dispPg && pagedb'[n].PageDbEntryTyped?
        ensures validPageDbEntry(pagedb', n)
    {
        assert pagedb[n] == pagedb'[n];
        assert addrspaceRefs(pagedb, n) == addrspaceRefs(pagedb', n); // set equality
        if pagedb[n].entry.DataPage? && !hasStoppedAddrspace(pagedb, n) {
            assert forall i:PageNr | pagedb[i].PageDbEntryTyped?
                && !pagedb[i].entry.Dispatcher? :: pagedb'[i] == pagedb[i];
            assert dataPageRefs(pagedb, pagedb[n].addrspace, n)
                == dataPageRefs(pagedb', pagedb'[n].addrspace, n);
        }
    }
}
#endverbatim

procedure svc_returning_verify_step0(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    returns (
    ghost pagedb': PageDb
    )
    reads
        globals; lr;
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; 
         spsr_mon; mem;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        ValidState(exstate) && mode_of_state(exstate) != User;
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        finalDispatcher(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        r0 == KOM_SVC_VERIFY_STEP0;
    ensures
        StackPreserving(old(this), this);
        MemPreservingExcept(old(this), this, page_monvaddr(dispPg), page_monvaddr(dispPg) + DISP_CTXT_USER_WORDS + 8 * WORDSIZE);
        let tuple := svcHandled(exstate, pagedb, dispPg) in
        let retRegs := firstOf2(tuple) in
        let handled_pagedb := secondOf2(tuple) in
        pagedb' == handled_pagedb && preEntryReturnRegsMatch(this, retRegs);
        spsr_mon == encode_mode(User);
        pageDbCorresponds(this.m, pagedb');
        validDispatcherPage(pagedb', dispPg);
{
    ghost var user_words := seq(r1, r2, r3, r4, r5, r6, r7, r8);
    pagedb' := pagedb[dispPg := pagedb[dispPg].(entry := pagedb[dispPg].entry.(verify_words := user_words))];

    LDRglobaladdr(r0, CurDispatcherOp());
    LDRglobal(r0, CurDispatcherOp(), r0, 0);
    assert r0 == page_monvaddr(dispPg);
    // Use r0 to grab DISP_CTXT_USER_WORDS

    STR(r1, r0, const(DISP_CTXT_USER_WORDS + 0 * WORDSIZE));
    STR(r2, r0, const(DISP_CTXT_USER_WORDS + 1 * WORDSIZE));
    STR(r3, r0, const(DISP_CTXT_USER_WORDS + 2 * WORDSIZE));
    STR(r4, r0, const(DISP_CTXT_USER_WORDS + 3 * WORDSIZE));
    STR(r5, r0, const(DISP_CTXT_USER_WORDS + 4 * WORDSIZE));
    STR(r6, r0, const(DISP_CTXT_USER_WORDS + 5 * WORDSIZE));
    STR(r7, r0, const(DISP_CTXT_USER_WORDS + 6 * WORDSIZE));
    STR(r8, r0, const(DISP_CTXT_USER_WORDS + 7 * WORDSIZE));

    assert firstOf2(svcHandled(exstate, pagedb, dispPg)) == tuple(KOM_ERR_SUCCESS,0,0,0,0,0,0,0,0);
    svc_return_epilog();
    MOV(r0, const(KOM_ERR_SUCCESS));

    ghost var disp := pagedb'[dispPg].entry;
    ghost var pg := extractPage(this.m, dispPg);
    lemma_svc_returning_verify_step0_helper(old(this), pagedb, dispPg, old(this.m), this.m,
        user_words, pagedb', disp, pg);

    assert pageDbCorresponds(this.m, pagedb') by {
        assert pageDbCorrespondsOnly(this.m, pagedb', dispPg) by {
            assert pageDbEntryCorresponds(pagedb'[dispPg],
                                          extractPageDbEntry(this.m, dispPg))
                by { assert GlobalsInvariant(old(this), this);
                     reveal pageDbEntryCorresponds; }
            assert pageContentsCorresponds(dispPg, pagedb'[dispPg], pg)
                by { reveal pageContentsCorresponds; }
        }
        AllButOnePagePreserving(dispPg, old(this), this);
    }
}

#verbatim
lemma lemma_svc_returning_verify_step1_helper(s:state, pagedb:PageDb, dispPg:PageNr, m1:memstate,
    m2:memstate, user_words:seq<word>, pagedb':PageDb, disp:PageDbEntryTyped, pg:memmap)
    requires SaneState(s);
    requires m1 == s.m;
    requires validPageDb(pagedb)
    requires pageDbCorresponds(m1, pagedb)
    requires finalDispatcher(pagedb, dispPg)
    requires |user_words| == 8
    requires pagedb' == pagedb[dispPg := pagedb[dispPg].(entry := pagedb[dispPg].entry.(verify_measurement := user_words))]
    requires disp == pagedb'[dispPg].entry
    requires ValidMemState(m2)
    requires pg == extractPage(m2, dispPg)
    requires
        forall i :: i in m1.addresses <==> i in m2.addresses
    requires
        forall i :: !(0 <= i - WordAlignedAdd(page_monvaddr(dispPg), DISP_CTXT_VERIFY_MEASUREMENT) <= WordsToBytes(7)) ==>
            i in m1.addresses ==> m1.addresses[i] == m2.addresses[i]
    requires
        forall i :: 0 <= i < 8 ==>
            var a := WordOffset(WordAlignedAdd(page_monvaddr(dispPg), DISP_CTXT_VERIFY_MEASUREMENT), i);
            a in m2.addresses && m2.addresses[a] == user_words[i]
    ensures pageDbDispatcherCorresponds(dispPg, disp, pg)
    ensures validDispatcherPage(pagedb', dispPg)
{
    assert pageDbDispatcherCorresponds(dispPg, disp, pg) by
    {
        reveal pageContentsCorresponds();
        reveal pageDbDispatcherCorresponds();
        reveal pageDbDispatcherContextCorresponds();
        reveal pageDbDispatcherVerifyStateCorresponds();
    }

    reveal validPageDb();

    forall n:PageNr | n != dispPg && pagedb'[n].PageDbEntryTyped?
        ensures validPageDbEntry(pagedb', n)
    {
        assert pagedb'[n] == pagedb[n];
        assert addrspaceRefs(pagedb, n) == addrspaceRefs(pagedb', n); // set equality
        if pagedb[n].entry.DataPage? && !hasStoppedAddrspace(pagedb, n) {
            assert forall i:PageNr | pagedb[i].PageDbEntryTyped?
                && !pagedb[i].entry.Dispatcher? :: pagedb'[i] == pagedb[i];
            assert dataPageRefs(pagedb, pagedb[n].addrspace, n)
                == dataPageRefs(pagedb', pagedb'[n].addrspace, n);
        }
    }
}
#endverbatim

procedure svc_returning_verify_step1(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    returns (
    ghost pagedb': PageDb
    )
    reads
        globals; lr; 
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; mem; spsr_mon;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        ValidState(exstate) && mode_of_state(exstate) != User;
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR, OReg(R10)));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        finalDispatcher(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        r0 == KOM_SVC_VERIFY_STEP1;
    ensures
        StackPreserving(old(this), this);
        MemPreservingExcept(old(this), this, page_monvaddr(dispPg), page_monvaddr(dispPg) + DISP_CTXT_VERIFY_MEASUREMENT + 8 * WORDSIZE);
        let tuple := svcHandled(exstate, pagedb, dispPg) in
        let retRegs := firstOf2(tuple) in
        let handled_pagedb := secondOf2(tuple) in
        pagedb' == handled_pagedb && preEntryReturnRegsMatch(this, retRegs);
        pageDbCorresponds(this.m, pagedb');
        validDispatcherPage(pagedb', dispPg);
        spsr_mon == encode_mode(User);
{
    ghost var user_words := seq(r1, r2, r3, r4, r5, r6, r7, r8);
    pagedb' := pagedb[dispPg := pagedb[dispPg].(entry := pagedb[dispPg].entry.(verify_measurement := user_words))];

    LDRglobaladdr(r0, CurDispatcherOp());
    LDRglobal(r0, CurDispatcherOp(), r0, 0);
    assert r0 == page_monvaddr(dispPg);
    // Use r10 to grab DISP_CTXT_USER_WORDS

    STR(r1, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 0 * WORDSIZE));
    STR(r2, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 1 * WORDSIZE));
    STR(r3, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 2 * WORDSIZE));
    STR(r4, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 3 * WORDSIZE));
    STR(r5, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 4 * WORDSIZE));
    STR(r6, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 5 * WORDSIZE));
    STR(r7, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 6 * WORDSIZE));
    STR(r8, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 7 * WORDSIZE));

    assert firstOf2(svcHandled(exstate, pagedb, dispPg))
            == tuple(KOM_ERR_SUCCESS,0,0,0,0,0,0,0,0);
    MOV(r0, const(KOM_ERR_SUCCESS));
    svc_return_epilog();

    ghost var disp := pagedb'[dispPg].entry;
    ghost var pg := extractPage(this.m, dispPg);
    lemma_svc_returning_verify_step1_helper(old(this), pagedb, dispPg, old(this.m), this.m,
        user_words, pagedb', disp, pg);

    assert pageDbCorresponds(this.m, pagedb') by {
        assert pageDbCorrespondsOnly(this.m, pagedb', dispPg) by {
            assert pageDbEntryCorresponds(pagedb'[dispPg],
                                          extractPageDbEntry(this.m, dispPg))
                by { assert GlobalsInvariant(old(this), this);
                     reveal pageDbEntryCorresponds; }
            assert pageContentsCorresponds(dispPg, pagedb'[dispPg], pg)
                by { reveal pageContentsCorresponds; }
        }
        AllButOnePagePreserving(dispPg, old(this), this);
    }
}

procedure monvaddr_page_impl(out operand pagenr:reg, operand mva:reg, out operand tmp:reg)
    reads
        globals;
    requires/ensures
        SaneState(this);
    requires
        // NB: @mva == @pagenr is supported
        @mva != @tmp;
        @pagenr != @tmp;
        @tmp != OSP;
        @pagenr != OSP;
        PageAligned(mva);
        address_is_secure(mva);
    ensures
        //SmcProcedureInvariant(old(this), this);
        pagenr == monvaddr_page(old(mva));
        validPageNr(pagenr);
{
    SUB(pagenr,mva,const(KOM_DIRECTMAP_VBASE));
    LDRglobaladdr(tmp, SecurePhysBaseOp());
    LDRglobal(tmp, SecurePhysBaseOp(), tmp, 0);
    assert WordAligned(tmp);
    SUB(pagenr,pagenr,tmp);

    ghost var oldpagenr := pagenr;
    LSR(pagenr, pagenr, 12);
    lemma_RightShift12(oldpagenr);
    assert pagenr == oldpagenr / PAGESIZE;
}

procedure get_cur_addrspace(out operand asva:reg,
    out operand pagedb_base:reg, ghost pagedb:PageDb, ghost dispPg:PageNr)
    reads globals;
    requires/ensures
        SaneState(this);
    requires
        @asva != @pagedb_base && @asva != OSP && @pagedb_base != OSP;
        validPageDb(pagedb) && pageDbCorresponds(this.m, pagedb);
        pagedb[dispPg] is PageDbEntryTyped;
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        SmcProcedureInvariant(old(this), this);
        asva == page_monvaddr(pagedb[dispPg].addrspace);
        pagedb_base == AddressOfGlobal(PageDb());
{
    LDRglobaladdr(asva, CurDispatcherOp());
    LDRglobal(asva, CurDispatcherOp(), asva, 0);
    assert asva == page_monvaddr(dispPg);
    monvaddr_page_impl(asva, asva, pagedb_base);
    assert asva == dispPg;

    lemma_LeftShift3(asva);
    LSL(asva, asva, const(PAGEDB_ENTRY_SHIFT));
    ADD(asva, asva, const(PAGEDB_ENTRY_ADDRSPACE));
    assert asva == G_PAGEDB_ENTRY(dispPg) + PAGEDB_ENTRY_ADDRSPACE;
    LDRglobaladdr(pagedb_base, PageDb());
    LDRglobal(asva, PageDb(), pagedb_base, asva);
    reveal pageDbEntryCorresponds;
}

procedure svc_map_data_zeropage(
    ghost pagedb: PageDb,
    operand page:reg, // r1
    inout operand entryptr:reg) // r2
    returns (ghost pagedb': PageDb)
    modifies
         r0; r2; r5; mem; globals;
    requires/ensures
        SaneState(this);
    requires
        @page == OReg(R1) && @entryptr == OReg(R2);
        validPageDb(pagedb) && pageDbCorresponds(this.m, pagedb);
        validPageNr(page);
        pagedb[page] is PageDbEntryTyped && pagedb[page].entry is SparePage;
        !hasStoppedAddrspace(pagedb, page);
        entryptr == AddressOfGlobal(PageDb()) + G_PAGEDB_ENTRY(page);
    ensures
        SmcProcedureInvariant(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PageDb()));
        MemPreservingExcept(old(this), this, old(page_monvaddr(page)),
                            old(page_monvaddr(page)) + PAGESIZE);
        pagedb' == updatePageEntry(pagedb, old(page),
                                   DataPage(SeqRepeat(PAGESIZE/WORDSIZE, 0)));
        validPageDb(pagedb') && pageDbCorresponds(this.m, pagedb');
{
    ghost var zeroEntry := DataPage(SeqRepeat(PAGESIZE/WORDSIZE, 0));
    pagedb' := updatePageEntry(pagedb, old(page), zeroEntry);
    lemma_allocateSpareDataPage(pagedb, old(page), zeroEntry);

    // update pagedb entry type
    MOV(r0, const(KOM_PAGE_DATA));
    STRglobal(r0, PageDb(), entryptr, 0);

    ghost var entry := pagedb[page].(entry := zeroEntry);
    assert pageDbEntryCorresponds(entry, extractPageDbEntry(this.m, old(page)))
        by { reveal pageDbEntryCorresponds; }

    // zero-fill page
    page_monvaddr_impl(r2, page, r0);
    MOV(r0, 0);
    MOV(r5, const(PAGESIZE));
    memset(r2, r0, r5);

    ghost var pg := extractPage(this.m, old(page));
    assert pageContentsCorresponds(old(page), entry, pg)
    by {
        assert pageDbDataCorresponds(old(page), zeroEntry, pg)
            by { reveal pageDbDataCorresponds; }
        reveal pageContentsCorresponds;
    }

    assert pageDbCorresponds(this.m, pagedb')
    by {
        AllButOnePagePreserving(old(page), old(this), this);
    }
}

procedure svc_map_data_success(
    ghost pagedb: PageDb,
    inout operand page:reg, // r1
    operand entryptr:reg, // r2
    operand mapping:reg, // r3
    operand l1pte:reg, // r4
    ghost asPg: PageNr)
    returns (ghost pagedb': PageDb)
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; mem; globals;
    requires/ensures
        SaneState(this);
    requires
        @page == OReg(R1) && @entryptr == OReg(R2) && @mapping == OReg(R3)
            && @l1pte == OReg(R4);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        isAddrspace(pagedb, asPg);
        validSparePageForAS(pagedb, asPg, page);
        isValidMappingTarget'(pagedb, asPg, mapping) == KOM_ERR_SUCCESS;
        entryptr == AddressOfGlobal(PageDb()) + G_PAGEDB_ENTRY(page);
        l1pte == page_monvaddr(pagedb[pagedb[asPg].entry.l1ptnr].entry.l1pt[
                    wordToMapping(mapping).l1index].v);
    ensures
        SmcProcedureInvariant(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PageDb()));
        tuple(pagedb', KOM_ERR_SUCCESS)
            == svcMapData(pagedb, asPg, old(page), old(mapping));
        validPageDb(pagedb') && pageDbCorresponds(this.m, pagedb');
{
    pagedb' := svc_map_data_zeropage(pagedb, page, r2);

    ghost var abs_mapping := wordToMapping(mapping);
    ghost var l2pte := SecureMapping(old(page), abs_mapping.perm.w, abs_mapping.perm.x);
    lemma_sparePageRefs(pagedb, old(page));
    lemma_isValidMappingTarget_validAndEmptyMapping(pagedb, asPg, mapping);

    reveal wordToMapping;
    mkL2Pte_secure(mapping, page, r0, abs_mapping, l2pte); // page := l2pte

    ghost var l1 := old(pagedb[pagedb[asPg].entry.l1ptnr].entry);
    ghost var l1pte_abs := fromJust(l1.l1pt[abs_mapping.l1index]);
    ghost var tmpst := this;
    assert l1pte_abs != old(page);
    pagedb' := update_l2pte(asPg, mapping, page, l1pte, r7,
                            pagedb', abs_mapping, l2pte);
    AllButOnePagePreserving(l1pte_abs, tmpst, this);
    assert pageDbCorresponds(this.m, pagedb');
}

procedure svc_map_data(
    ghost pagedb: PageDb,
    out operand err:reg, // r0
    inout operand page:reg, // r1
    inout operand mapping:reg, // r2
    ghost dispPg: PageNr)
    returns (ghost pagedb': PageDb)
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; mem; globals;
    requires/ensures
        SaneState(this);
    requires
        @err == OReg(R0) && @page == OReg(R1) && @mapping == OReg(R2);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        finalDispatcher(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        SmcProcedureInvariant(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PageDb()));
        tuple(pagedb', err)
            == svcMapData(pagedb, pagedb[dispPg].addrspace, old(page), old(mapping));
        validPageDb(pagedb') && pageDbCorresponds(this.m, pagedb');
{
    ghost var asPg := pagedb[dispPg].addrspace;
    ghost var specDb := firstOf2(svcMapData(pagedb, asPg, page, mapping));
    ghost var specErr := secondOf2(svcMapData(pagedb, asPg, page, mapping));
    pagedb' := pagedb;

    get_cur_addrspace(r5, r8, pagedb, dispPg);
    // r8 = pagedb base, r5 = asva

    if (page >= const(KOM_SECURE_NPAGES)) {
        MOV(err, const(KOM_ERR_INVALID_PAGENO));
        assert err == specErr && pagedb' == specDb;
    } else {
        assert validPageNr(page);
        load_page_type(page, r8, r4, r0, pagedb);
        assert r4 == G_PAGEDB_ENTRY(old(page));
        assert r0 == pageDbEntryTypeVal(pagedb[page]);
        if (r0 != const(KOM_PAGE_SPARE)) {
            assert set(KOM_PAGE_FREE, KOM_PAGE_ADDRSPACE, KOM_PAGE_DISPATCHER,
                       KOM_PAGE_L1PTABLE, KOM_PAGE_L2PTABLE, KOM_PAGE_DATA) ?[r0];
            assert !(pagedb[page] is PageDbEntryTyped
                    && pagedb[page].entry is SparePage);
            MOV(err, const(KOM_ERR_INVALID_PAGENO));
            assert err == specErr && pagedb' == specDb;
        } else {
            ADD(r6, r4, const(PAGEDB_ENTRY_ADDRSPACE));
            LDRglobal(r0, PageDb(), r8, r6);
            assert r0 == page_monvaddr(pagedb[page].addrspace)
                by { reveal pageDbEntryCorresponds; }
            if (r0 != r5) { // spare page in wrong addrspace
                MOV(err, const(KOM_ERR_INVALID_PAGENO));
                assert err == specErr && pagedb' == specDb;
            } else {
                assert old(page) == page && old(mapping) == mapping;
                assert validSparePageForAS(pagedb, asPg, page);

                // kludge register fiddling to meet conventions:
                // move mapping (r2) into r3 for is_valid_mapping_target'
                MOV(r3, mapping);

                // prep r2 with addr of page type so we can update it later
                ADD(r2, r8, r4);
                assert r2 == AddressOfGlobal(PageDb()) + G_PAGEDB_ENTRY(old(page));

                is_valid_mapping_target'(r5, r3, r4, err, asPg, pagedb);
                assert err == specErr;

                if (err == const(KOM_ERR_SUCCESS)) {
                    pagedb' := svc_map_data_success(pagedb, page, r2, r3, r4, asPg);
                    MOV(err, const(KOM_ERR_SUCCESS)); // TODO: remove me if possible
                    assert err == specErr && pagedb' == specDb;
                }
            }
        }
    }
}

#verbatim
lemma lemma_PageBase_Shift(x:word, y:word)
    ensures RightShift(x, PAGEBITS) == RightShift(y, PAGEBITS)
        <==> PageBase(x) == PageBase(y)
{
    calc {
        PageBase(x);
        { reveal PageBase(); }
        BitwiseMaskHigh(x, PAGEBITS);
        x / PAGESIZE * PAGESIZE;
        { lemma_RightShift12(x); }
        RightShift(x, PAGEBITS) * PAGESIZE;
    }

    calc {
        PageBase(y);
        { reveal PageBase(); }
        BitwiseMaskHigh(y, PAGEBITS);
        y / PAGESIZE * PAGESIZE;
        { lemma_RightShift12(y); }
        RightShift(y, PAGEBITS) * PAGESIZE;
    }
}

lemma lemma_PageAligned_PageBase(x:word)
    requires PageAligned(x)
    ensures PageBase(x) == x
{
    calc {
        PageBase(x);
        { reveal PageBase(); }
        BitwiseMaskHigh(x, PAGEBITS);
        x / PAGESIZE * PAGESIZE;
        { reveal PageAligned(); }
        x;
    }
}

lemma lemma_read_l2pte_secure(d: PageDb, asPg: PageNr, pte:L2PTE, ptew:word,
                              page:PageNr)
    requires PhysBase() == KOM_DIRECTMAP_VBASE
    requires !mkAbsPTE(pte).Nothing?
    requires ptew == mkL2Pte(pte)
    requires wellFormedPageDb(d) && validL2PTE(d, asPg, pte)
    ensures (RightShift(ptew, PAGEBITS) == RightShift(page_paddr(page), PAGEBITS))
        <==> (pte.SecureMapping? && pte.page == page)
{
    assert WordAsBits(PAGEBITS) == 12 by { reveal WordAsBits(); }
    lemma_l2ptesmatch(pte);
    assert ExtractAbsL2PTE(ptew) == mkAbsPTE(pte);
    assert mkAbsPTE(pte).v.phys == PageBase(ptew);
    lemma_PageBase_Shift(ptew, page_paddr(page));
    lemma_PageAligned_PageBase(page_paddr(page));
    if RightShift(ptew, PAGEBITS) == RightShift(page_paddr(page), PAGEBITS) {
        if pte.InsecureMapping? {
            assert PageBase(ptew) == pte.insecurePage * PAGESIZE;
            assert PageBase(ptew) == page_paddr(page);
            assert physPageIsInsecureRam(pte.insecurePage);
            assert validPageNr(page);
            assert false;
        } else {
            assert pte.SecureMapping? && pte.page == page;
        }
    }
}
#endverbatim

procedure existing_va_ok(
    ghost asPg: PageNr,
    ghost pagedb: PageDb,
    out operand err:reg, // r0
    inout operand page:reg, // r1, trashed
    operand mapva:reg, // r2
    operand asva:reg, // r5
    out operand l1:reg, // r6
    out operand l2:reg // r7
    )
    reads
        mem; globals;
    modifies
        r4; r8;
    requires/ensures
        SaneState(this);
    requires
        @err == OReg(R0) && @page == OReg(R1) && @mapva == OReg(R2);
        @asva == OReg(R5) && @l1 == OReg(R6) && @l2 == OReg(R7);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        isAddrspace(pagedb, asPg) && pagedb[asPg].entry.state is FinalState;
        asva == page_monvaddr(asPg);
        validPageNr(page);
    ensures
        SmcProcedureInvariant(old(this), this);
        if isExistingVAForDataPage(pagedb, asPg, old(mapva), old(page))
        then
            let l1pt := pagedb[pagedb[asPg].entry.l1ptnr].entry.l1pt in
            err == KOM_ERR_SUCCESS
            && l1 == page_monvaddr(l1pt[l1indexFromMapping(old(mapva))].v)
            && l2 == l2indexFromMapping(old(mapva))
        else err == KOM_ERR_INVALID_MAPPING;
{
    ghost var abs_mapping := wordToMapping(mapva);
    ghost var l1index := abs_mapping.l1index;
    ghost var l2index := abs_mapping.l2index;
    ghost var l1p := pagedb[asPg].entry.l1ptnr;
    assert validL1PTPage(pagedb, l1p) by { reveal validPageDb; }
    ghost var l1pt := pagedb[l1p].entry.l1pt;

    MOV(err, const(KOM_ERR_INVALID_MAPPING));

    LSR(l1, mapva, 20); 
    assert l1 == l1index by { reveal wordToMapping; }

    if (l1 < const(NR_L1PTES)) {
        LSR(l2, mapva, 12);
        AND(l2, l2, 0xff);
        assert l2 == l2index
            by { reveal wordToMapping; assert l2 == l2indexFromMapping(mapva); }
        if (l2 < const(NR_L2PTES)) {
            LDR(r8, asva, const(ADDRSPACE_L1PT));

            assert r8 == page_monvaddr(l1p)
            by {
                assert validAddrspacePage(pagedb, asPg);
                reveal pageContentsCorresponds;
                reveal pageDbAddrspaceCorresponds;
            }

            fetch_l1pte(r8, l1, r4, l1, pagedb, l1p);
            assert l1 == 0 <==> l1pt[l1index] == Nothing;
            if (l1 != 0) {
                ghost var l1pte_abs := fromJust(l1pt[l1index]);
                fetch_l2pte(asPg, mapva, l1, r4, pagedb); // r4 := l2pte
                ghost var ptew := r4;
                ghost var l2pt := pagedb[l1pte_abs].entry.l2pt;
                assert validL2PTable(pagedb, asPg, l2pt)
                    by { reveal validPageDb; }
                ghost var l2pte_abs := l2pt[l2index];
                AND(r8, r4, 3);
                lemma_read_l2pte_zero(l2pte_abs);
                if (r8 != 0) {
                    assert !(mkAbsPTE(l2pte_abs) is Nothing);
                    assert l2pte_abs is SecureMapping || l2pte_abs is InsecureMapping;
                    page_paddr_impl(page, page, r8);
                    LSR(r4, r4, const(PAGEBITS));
                    LSR(page, page, const(PAGEBITS));
                    lemma_read_l2pte_secure(pagedb, asPg, l2pte_abs, ptew, old(page));
                    if (r4 == page) {
                        assert isExistingVAForDataPage(pagedb, asPg, old(mapva),
                                                       old(page));
                        MOV(err, const(KOM_ERR_SUCCESS));
                    }
                }
            }
        }
    }
}

procedure svc_unmap_data_success(
    ghost pagedb: PageDb,
    ghost asPg: PageNr,
    ghost page: PageNr,
    operand mapva:reg,
    operand l1pte:reg,
    operand entryptr:reg)
    returns (ghost pagedb': PageDb)
    modifies
         r4; r7; mem; globals;
    requires/ensures
        SaneState(this);
    requires
        @mapva == OReg(R2) && @l1pte == OReg(R6) && @entryptr == OReg(R3);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        isAddrspace(pagedb, asPg) && pagedb[asPg].entry.state is FinalState;
        pagedb[page] is PageDbEntryTyped && pagedb[page].addrspace == asPg;
        pagedb[page].entry is DataPage;
        isExistingVAForDataPage(pagedb, asPg, mapva, page);
        let l1pt := pagedb[pagedb[asPg].entry.l1ptnr].entry.l1pt;
        l1pte == page_monvaddr(l1pt[l1indexFromMapping(mapva)].v);
        entryptr == AddressOfGlobal(PageDb()) + G_PAGEDB_ENTRY(page);
    ensures
        SmcProcedureInvariant(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PageDb()));
        pagedb' == firstOf2(svcUnmapData(pagedb, asPg, page, old(mapva)));
        wellFormedPageDb(pagedb') && pageDbCorresponds(this.m, pagedb');
{
    ghost var abs_mapping := wordToMapping(mapva);
    assert abs_mapping.l1index == l1indexFromMapping(mapva)
        && abs_mapping.l2index == l2indexFromMapping(mapva)
        by { reveal wordToMapping; }

    // update page table
    MOV(r7, 0);
    ghost var pagedb1;
    pagedb1 := update_l2pte(asPg, mapva, r7, l1pte, r4, pagedb, abs_mapping, NoMapping);
    assert validPageDb(pagedb1) && pageDbCorresponds(this.m, pagedb1);

    ghost var tmp := this;

    // update pagedb type
    MOV(r4, const(KOM_PAGE_SPARE));
    STRglobal(r4, PageDb(), entryptr, 0);
    pagedb' := updatePageEntry(pagedb1, page, SparePage);

    assert pageDbCorresponds(this.m, pagedb')
    by {
        assert pageDbEntryCorresponds(pagedb'[page], extractPageDbEntry(this.m, page))
        by {
            reveal pageDbEntryCorresponds;
            extractPageDbToAbstract(this.m, page);
        }
        assert pageContentsCorresponds(page, pagedb'[page], extractPage(this.m, page))
        by {
            reveal pageContentsCorresponds;
            assert pagedb'[page] is PageDbEntryTyped
                && pagedb'[page].entry is SparePage;
        }
        forall p :| validPageNr(p) && p != page :: pageDbCorrespondsOnly(this.m, pagedb', p)
        {
            assert pagedb'[p] == pagedb1[p];
            assert tmp.m.addresses == this.m.addresses;
            assert extractPage(tmp.m, p) == extractPage(this.m, p);
            assert extractPageDbEntry(tmp.m, p) == extractPageDbEntry(this.m, p);
        }
    }
}

procedure svc_unmap_data(
    ghost pagedb: PageDb,
    out operand err:reg, // r0
    inout operand page:reg, // r1
    inout operand mapva:reg, // r2
    ghost dispPg: PageNr)
    returns (ghost pagedb': PageDb)
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; mem; globals;
    requires/ensures
        SaneState(this);
    requires
        @err == OReg(R0) && @page == OReg(R1) && @mapva == OReg(R2);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        finalDispatcher(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        SmcProcedureInvariant(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PageDb()));
        tuple(pagedb', err)
            == svcUnmapData(pagedb, pagedb[dispPg].addrspace, old(page), old(mapva));
        validPageDb(pagedb') && pageDbCorresponds(this.m, pagedb');
{
    ghost var asPg := pagedb[dispPg].addrspace;
    ghost var specDb := firstOf2(svcUnmapData(pagedb, asPg, page, mapva));
    ghost var specErr := secondOf2(svcUnmapData(pagedb, asPg, page, mapva));
    lemma_svcUnmapData_validPageDb(pagedb, asPg, page, mapva);
    pagedb' := pagedb;

    get_cur_addrspace(r5, r8, pagedb, dispPg);
    // r8 := pagedb base, r5 := asva

    if (page >= const(KOM_SECURE_NPAGES)) {
        MOV(err, const(KOM_ERR_INVALID_PAGENO));
        assert err == specErr && pagedb' == specDb;
    } else {
        assert validPageNr(page);
        load_page_type(page, r8, r4, r0, pagedb);
        assert r4 == G_PAGEDB_ENTRY(old(page));
        assert r0 == pageDbEntryTypeVal(pagedb[page]);
        if (r0 != const(KOM_PAGE_DATA)) {
            assert set(KOM_PAGE_FREE, KOM_PAGE_ADDRSPACE, KOM_PAGE_DISPATCHER,
                       KOM_PAGE_L1PTABLE, KOM_PAGE_L2PTABLE, KOM_PAGE_SPARE) ?[r0];
            assert !(pagedb[page] is PageDbEntryTyped
                    && pagedb[page].entry is DataPage);
            MOV(err, const(KOM_ERR_INVALID_PAGENO));
            assert err == specErr && pagedb' == specDb;
        } else {
            ADD(r6, r4, const(PAGEDB_ENTRY_ADDRSPACE));
            LDRglobal(r0, PageDb(), r8, r6);
            assert r0 == page_monvaddr(pagedb[page].addrspace)
                by { reveal pageDbEntryCorresponds; }
            if (r0 != r5) { // page in wrong addrspace
                MOV(err, const(KOM_ERR_INVALID_PAGENO));
                assert err == specErr && pagedb' == specDb;
            } else {
                assert old(page) == page && old(mapva) == mapva;
                assert pagedb[page]is PageDbEntryTyped
                    && pagedb[page].addrspace == asPg && pagedb[page].entry is DataPage;

                // prep r3 with addr of page type so we can update it later
                ADD(r3, r8, r4);
                assert r3 == AddressOfGlobal(PageDb()) + G_PAGEDB_ENTRY(old(page));
                // r4, r6, r7, r8 are free for use

                existing_va_ok(asPg, pagedb, err, page, mapva, r5, r6, r7);
                // r6 := page_monvaddr(l1pt[l1indexFromMapping(old(mapva))].v)

                if (err == const(KOM_ERR_SUCCESS)) {
                    ghost var p := old(page);
                    assert mapva == old(mapva);

                    pagedb' := svc_unmap_data_success(pagedb, asPg, old(page),
                                                     mapva, r6, r3);
                    assert err == specErr && pagedb' == specDb;

                    // TODO: flush TLB
                } else {
                    assert !isExistingVAForDataPage(pagedb, asPg, old(mapva), old(page));
                    assert err == KOM_ERR_INVALID_MAPPING;
                }
            }
        }
    }
}

procedure svc_init_l2ptable(
    ghost pagedb: PageDb,
    out operand err:reg, // r0
    inout operand page:reg, // r1
    inout operand l1index:reg, // r2
    ghost dispPg: PageNr)
    returns (ghost pagedb': PageDb)
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; mem; globals;
    requires/ensures
        SaneState(this);
    requires
        @err == OReg(R0) && @page == OReg(R1) && @l1index == OReg(R2);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        finalDispatcher(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        SmcProcedureInvariant(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PageDb()));
        tuple(pagedb', err)
            == svcInitL2PTable(pagedb, pagedb[dispPg].addrspace, old(page), old(l1index));
        validPageDb(pagedb') && pageDbCorresponds(this.m, pagedb');
{
    ghost var asPg := pagedb[dispPg].addrspace;
    ghost var specDb := firstOf2(svcInitL2PTable(pagedb, asPg, page, l1index));
    ghost var specErr := secondOf2(svcInitL2PTable(pagedb, asPg, page, l1index));
    lemma_svcInitL2PTable_validPageDb(pagedb, asPg, page, l1index);
    pagedb' := pagedb;

    get_cur_addrspace(r5, r8, pagedb, dispPg);
    // r8 := pagedb base, r5 := asva

    if (l1index >= const(NR_L1PTES)) {
        MOV(err, const(KOM_ERR_INVALID_MAPPING));
        assert err == specErr && pagedb' == specDb;
    } else if (page >= const(KOM_SECURE_NPAGES)) {
        MOV(err, const(KOM_ERR_INVALID_PAGENO));
        assert err == specErr && pagedb' == specDb;
    } else {
        assert validPageNr(page);
        load_page_type(page, r8, r4, r0, pagedb);
        assert r4 == G_PAGEDB_ENTRY(old(page));
        assert r0 == pageDbEntryTypeVal(pagedb[page]);
        if (r0 != const(KOM_PAGE_SPARE)) {
            assert set(KOM_PAGE_FREE, KOM_PAGE_ADDRSPACE, KOM_PAGE_DISPATCHER,
                       KOM_PAGE_L1PTABLE, KOM_PAGE_L2PTABLE, KOM_PAGE_DATA) ?[r0];
            assert !(pagedb[page] is PageDbEntryTyped
                    && pagedb[page].entry is SparePage);
            MOV(err, const(KOM_ERR_INVALID_PAGENO));
            assert err == specErr && pagedb' == specDb;
        } else {
            ADD(r6, r4, const(PAGEDB_ENTRY_ADDRSPACE));
            LDRglobal(r0, PageDb(), r8, r6);
            assert r0 == page_monvaddr(pagedb[page].addrspace)
                by { reveal pageDbEntryCorresponds; }
            if (r0 != r5) { // page in wrong addrspace
                MOV(err, const(KOM_ERR_INVALID_PAGENO));
                assert err == specErr && pagedb' == specDb;
            } else {
                assert old(page) == page && old(l1index) == l1index;
                assert validSparePageForAS(pagedb, asPg, page);

                // prep r3 with addr of page type so we can update it later
                ADD(r3, r8, r4);
                assert r3 == AddressOfGlobal(PageDb()) + G_PAGEDB_ENTRY(old(page));
                // r4, r6, r7, r8 are free for use

                // check for L1 index in use
                ghost var l1pg := pagedb[asPg].entry.l1ptnr;
                LDR(r4, r5, const(ADDRSPACE_L1PT));

                assert r4 == page_monvaddr(l1pg)
                by {
                    assert validAddrspacePage(pagedb, asPg);
                    reveal pageContentsCorresponds;
                    reveal pageDbAddrspaceCorresponds;
                    assert pageDbCorrespondsOnly(this.m, pagedb, asPg);
                }

                assert pagedb[l1pg] is PageDbEntryTyped
                    && pagedb[l1pg].entry is L1PTable
                    && wellFormedPageDbEntryTyped(pagedb[l1pg].entry)
                by {
                    assert isAddrspace(pagedb, asPg);
                    assert !stoppedAddrspace(pagedb[asPg]);
                    reveal validPageDb;
                }

                fetch_l1pte(r4, l1index, r6, r7, pagedb, l1pg);
                if (r7 != 0) {
                    assert l1indexInUse(pagedb, asPg, old(l1index));
                    MOV(err, const(KOM_ERR_ADDRINUSE));
                    assert err == specErr;
                } else {
                    assert !l1indexInUse(pagedb, asPg, old(l1index));

                    // update pagedb entry type
                    ghost var l2pt := L2PTable(SeqRepeat(NR_L2PTES, NoMapping));
                    ghost var pagedb1 := updatePageEntry(pagedb, page, l2pt);
                    MOV(r6, const(KOM_PAGE_L2PTABLE));
                    STRglobal(r6, PageDb(), r3, 0);
                    assert pageDbEntryCorresponds(pagedb1[page],
                                                  extractPageDbEntry(this.m, page))
                    by {
                        reveal pageDbEntryCorresponds;
                        extractPageDbToAbstract(this.m, page);
                    }
                    forall p :| validPageNr(p) && p != page
                        :: pageDbCorrespondsOnly(this.m, pagedb1, p)
                    {
                        assert pagedb[p] == pagedb1[p];
                        assert old(this).m.addresses == this.m.addresses;
                        assert extractPage(old(this).m, p) == extractPage(this.m, p);
                        assert extractPageDbEntry(old(this).m, p)
                            == extractPageDbEntry(this.m, p);
                    }

                    // zero page and install l1 pte
                    pagedb' := init_l2ptable_success(page, r4, l1index, r6,
                                                     pagedb1, asPg, l1pg);
                    MOV(err, const(KOM_ERR_SUCCESS));
                    assert pagedb' == specDb && err == specErr;
                }
            }
        }
    }
}

#verbatim
lemma lemma_svc_returning_WordAlignedStack(s:state, stack_bytes:int)
    requires SaneState(s)
    requires StackBytesRemaining(s, stack_bytes)
    requires stack_bytes >= WordsToBytes(STACKSIZE_ATTEST + 14)
    ensures ValidMemRange(va_get_osp(s) - WordsToBytes(STACKSIZE_ATTEST + 14), va_get_osp(s))
    ensures ValidMemRange(va_get_osp(s) - WordsToBytes(STACKSIZE_ATTEST + 10), va_get_osp(s))
{
}
#endverbatim

procedure {:frame false}{:timeLimitMultiplier 2} svc_returning(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    returns (
    ghost pagedb': PageDb
    )
    reads
        globals;
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
         spsr_mon; mem;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        stack_bytes >= WordsToBytes(STACKSIZE_ATTEST + 14);
        ValidState(exstate) && mode_of_state(exstate) != User;
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR));
        OperandContents(this, OLR) == OperandContents(exstate, OLR);
        preEntryCommon(this, pagedb, dispPg);
        this.conf.nondet == nondet_int(exstate.conf.nondet, NONDET_GENERATOR());
        this.conf.scr == exstate.conf.scr && this.conf.ttbr0 == exstate.conf.ttbr0;
        pageDbCorresponds(this.m, pagedb);
        preEntryReturnPreserved(exstate, this);
        OperandContents(this, OLR) == OperandContents(exstate, OLR);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        lr == old(lr);
        StackPreserving(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PageDb()));
        BankedRegsInvariant(old(this), this);
        //SRegsInvariant(old(this), this);
        ttbr0 == old(ttbr0) && scr == old(scr);
        InsecureMemInvariant(old(this), this);
        let tuple := svcHandled(exstate, pagedb, dispPg);
        let retRegs := firstOf2(tuple);
        let handled_pagedb := secondOf2(tuple);
        pagedb' == handled_pagedb;
        validPageDb(pagedb') && pageDbCorresponds(this.m, pagedb');
        preEntryReturn(exstate, this, retRegs, pagedb, dispPg);
{
    ghost var retRegs := firstOf2(svcHandled(exstate, pagedb, dispPg));

    lemma_svc_returning_WordAlignedStack(this, stack_bytes);

    if (r0 == const(KOM_SVC_ATTEST)) {
        // Create an attestation
        svc_returning_attest(exstate, stack_bytes, pagedb, dispPg);
        pagedb' := pagedb;
        assert pageDbCorresponds(this.m, pagedb');
        assert preEntryReturn(exstate, this, retRegs, pagedb', dispPg);
        assert BankedRegsInvariant(old(this), this);
    } else if (r0 == const(KOM_SVC_VERIFY_STEP0)) {
        // Store the user provided words to verify
        pagedb' := svc_returning_verify_step0(exstate, stack_bytes, pagedb, dispPg);
        assert pageDbCorresponds(this.m, pagedb');
        assert preEntryReturn(exstate, this, retRegs, pagedb', dispPg);
        assert BankedRegsInvariant(old(this), this);
    } else if (r0 == const(KOM_SVC_VERIFY_STEP1)) {
        // Store the user provided measurement to verify
        pagedb' := svc_returning_verify_step1(exstate, stack_bytes, pagedb, dispPg);
        assert pageDbCorresponds(this.m, pagedb');
        assert preEntryReturn(exstate, this, retRegs, pagedb', dispPg);
        assert BankedRegsInvariant(old(this), this);
    } else if (r0 == const(KOM_SVC_VERIFY_STEP2)) {
        // Do some verification
        svc_returning_verify(exstate, stack_bytes, pagedb, dispPg);
        pagedb' := pagedb;
        assert pageDbCorresponds(this.m, pagedb');
        calc {
            OperandContents(this, OLR);
            lr;
            old(lr);
            OperandContents(old(this), OLR);
            OperandContents(exstate, OLR);
        }
        assert preEntryReturn(exstate, this, retRegs, pagedb', dispPg);
        assert BankedRegsInvariant(old(this), this);
    } else if (r0 == const(KOM_SVC_MAP_DATA)) {
        pagedb' := svc_map_data(pagedb, r0, r1, r2, dispPg);
        svc_return_epilog();
        assert preEntryReturn(exstate, this, retRegs, pagedb', dispPg);
        assert BankedRegsInvariant(old(this), this);
    } else if (r0 == const(KOM_SVC_UNMAP_DATA)) {
        pagedb' := svc_unmap_data(pagedb, r0, r1, r2, dispPg);
        svc_return_epilog();
        assert preEntryReturn(exstate, this, retRegs, pagedb', dispPg);
        assert BankedRegsInvariant(old(this), this);
    } else if (r0 == const(KOM_SVC_INIT_L2PTABLE)) {
        pagedb' := svc_init_l2ptable(pagedb, r0, r1, r2, dispPg);
        svc_return_epilog();
        assert preEntryReturn(exstate, this, retRegs, pagedb', dispPg);
        assert BankedRegsInvariant(old(this), this);
    } else {
        // Fall back position
        svc_returning_default(exstate, stack_bytes, pagedb, dispPg);
        pagedb' := pagedb;
        assert preEntryReturn(exstate, this, retRegs, pagedb', dispPg);
        assert BankedRegsInvariant(old(this), this);
    }
}
