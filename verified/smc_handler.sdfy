#verbatim // workarounds for Spartan's lack of Dafny language features
function specPageDb(t: (PageDb, int)): PageDb { t.0 }
function specErr(t: (PageDb, int)): int { t.1 }
#endverbatim

//=============================================================================
// Allocate page
//=============================================================================

#verbatim
lemma ValidPageDbImpliesValidAddrspace(d:PageDb, n:PageNr)
    requires validPageDb(d)
    requires isAddrspace(d, n)
    ensures closedRefsPageDbEntry(d[n]) && validAddrspace(d, n)
{
    reveal_validPageDb();
    assert validPageDbEntryTyped(d, n);
}

lemma PageDbCorrespondsImpliesEntryCorresponds(s:memstate, d:PageDb, n:PageNr)
    requires SaneMem(s)
    requires pageDbClosedRefs(d)
    requires pageDbCorresponds(s, d)
    requires validPageNr(n)
    ensures closedRefsPageDbEntry(d[n])
    ensures pageDbEntryCorresponds(d[n], extractPageDbEntry(s, n))
{
    reveal_pageDbClosedRefs();
}

// XXX: lifted from ironfleet/src/Dafny/Distributed/Common/Collections/Sets.i.dfy
lemma ThingsIKnowAboutSubset<T>(x:set<T>, y:set<T>)
    requires x<y;
    ensures |x|<|y|;
{
    if (x!={}) {
        var e :| e in x;
        ThingsIKnowAboutSubset(x-{e}, y-{e});
    }
}

// XXX: lifted from ironfleet/src/Dafny/Distributed/Common/Collections/Sets.i.dfy
lemma SubsetCardinality<T>(x:set<T>, y:set<T>)
    ensures x<y ==> |x|<|y|;
    ensures x<=y ==> |x|<=|y|;
{
    if (x<y) {
        ThingsIKnowAboutSubset(x, y);
    }
    if (x==y) { // OBSERVE the other case
    }
}

lemma BoundedAddrspaceRefs(d:PageDb, n:PageNr)
    requires validPageDb(d)
    requires isAddrspace(d, n)
    ensures d[n].entry.refcount <= KEVLAR_SECURE_NPAGES()
{
    reveal_validPageNrs();
    reveal_validPageDb();
    assert addrspaceRefs(d,n) <= validPageNrs();
    assert d[n].entry.refcount == |addrspaceRefs(d,n)|;
    SubsetCardinality(addrspaceRefs(d,n), validPageNrs());
}

lemma OnePagePreserving(n:PageNr,s:state,r:state)
    requires validPageNr(n)
    requires SaneState(s) && SaneState(r) && AlwaysInvariant(s,r)
    requires forall m :: ValidMem(s.m,m) && addrInPage(m,n) ==> addrval(s,m) == addrval(r,m)
    ensures extractPage(s.m, n) == extractPage(r.m, n)
{
}

lemma AllButOnePagePreserving(n:PageNr,s:state,r:state)
    requires validPageNr(n)
    requires SaneState(s) && SaneState(r) && AlwaysInvariant(s,r)
    requires MemPreservingExcept(s, r, page_monvaddr(n), page_monvaddr(n) + KEVLAR_PAGE_SIZE())
    ensures forall p :: validPageNr(p) && p != n ==> extractPage(s.m, p) == extractPage(r.m, p)
{
}

function increfAddrspaceEntry(entry:PageDbEntry): PageDbEntry
    requires entry.PageDbEntryTyped? && entry.entry.Addrspace?
{
    entry.(entry := entry.entry.(refcount := entry.entry.refcount + 1))
}

function increfAddrspacePageDb(d:PageDb, n:PageNr): PageDb
    requires validAddrspacePage(d, n)
    requires pageDbClosedRefs(d)
    ensures pageDbClosedRefs(d)
{
    reveal_pageDbClosedRefs();
    d[n := increfAddrspaceEntry(d[n])]
}

lemma AllocatePageImpliesIncrefAddrspace(dbin: PageDb, pg: PageNr,
                                         aspg: PageNr, entry: PageDbEntryTyped)
    requires validPageDb(dbin)
    requires validAddrspacePage(dbin, aspg)
    requires allocatePageEntryValid(entry)
    requires allocatePage(dbin, pg, aspg, entry).1 == KEV_ERR_SUCCESS()
    ensures (allocatePage(dbin, pg, aspg, entry).0)[aspg]
        == increfAddrspaceEntry(dbin[aspg]);
{
}

#endverbatim

procedure addrspace_incref(
    {:operand} as_va:mem,
    out {:operand} tmp:int,
    ghost pagedb_in:PageDb,
    ghost pagenr:int)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@as_va, @tmp), 2);
        validPageDb(pagedb_in);
        validAddrspacePage(pagedb_in, pagenr);
        as_va == page_monvaddr(pagenr);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        AlwaysInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
        StackPreserving(old(this),this);
        MemPreservingExcept(old(this),this, as_va, as_va + KEVLAR_PAGE_SIZE());
        RegPreservingExcept(old(this),this, set(@tmp));
        pagedb == increfAddrspacePageDb(pagedb_in, pagenr);
        pageDbClosedRefs(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, pagenr);
    pagedb := increfAddrspacePageDb(pagedb_in, pagenr);
    reveal_pageDbClosedRefs();

    LDR(tmp, as_va, sp_op_const(ADDRSPACE_REF()));

    // help dafny see that refcount++ won't overflow
    forall :: tmp == pagedb_in[pagenr].entry.refcount
        && tmp <= KEVLAR_SECURE_NPAGES()
    {
        reveal_pageContentsCorresponds();
        reveal_pageDbAddrspaceCorresponds();
        assert pageDbAddrspaceCorresponds(pagenr,
                pagedb_in[pagenr].entry, this.m.addresses);
        assert tmp == pagedb_in[pagenr].entry.refcount;
        BoundedAddrspaceRefs(pagedb_in, pagenr);
    }

    ADD(tmp, tmp, 1);
    assert tmp == pagedb[pagenr].entry.refcount;
    STR(tmp, as_va, sp_op_const(ADDRSPACE_REF()));

    forall p :| validPageNr(p) ::
        pageDbEntryCorresponds(pagedb[p], extractPageDbEntry(this.m, p))
    {
        reveal_pageDbEntryCorresponds();
        assert pageDbEntryCorresponds(pagedb_in[p],
                                      extractPageDbEntry(old(this).m, p));
        assert extractPageDbEntry(this.m, p) == extractPageDbEntry(old(this).m, p);
    }

    AllButOnePagePreserving(pagenr, old(this), this);
    assert pageDbCorrespondsExcluding(this.m, pagedb, pagenr);

    forall :: pageContentsCorresponds(pagenr, pagedb[pagenr],
                                extractPage(this.m, pagenr))
    {
        reveal_pageContentsCorresponds();
        reveal_pageDbAddrspaceCorresponds();
    }
}

procedure allocate_page_success(
    {:operand} pagenr:PageNr,
    {:operand} as_va:mem,
    {:operand} typeval:int,
    {:operand} pagedb_base:mem,
    out {:operand} tmp:int,
    out {:operand} tmp2:int,
    out {:operand} page_va:int,
    ghost pagedb_in:PageDb,
    ghost entry:PageDbEntry)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@pagenr, @as_va, @pagedb_base, @tmp, @tmp2, @page_va), 6);
        ValidOperand(@typeval) && @typeval is OConst;
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        closedRefsPageDbEntry(entry);
        entry is PageDbEntryTyped && validAddrspacePage(pagedb_in, entry.addrspace);
        entry.entry is Dispatcher; // FIXME: temp shortcut!
        allocatePageEntryValid(entry.entry);
        typeval == pageDbEntryTypeVal(entry);
        as_va == page_monvaddr(entry.addrspace);
        pageDbCorresponds(this.m, pagedb_in);
        validPageNr(pagenr) && pageIsFree(pagedb_in, pagenr);
        pagedb_in[entry.addrspace].entry.state == InitState;
    ensures
        AlwaysInvariant(old(this),this);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this),this, set(@tmp, @tmp2, @page_va));
        pagedb == specPageDb(allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry));
        //page_va == page_monvaddr(old(pagenr));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, entry.addrspace);
    assert specErr(allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry))
        == KEV_ERR_SUCCESS();
    pagedb := specPageDb(allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry));
    //assert forall i :: validPageNr(i) && i != entry.addrspace && i != pagenr
    //    ==> pagedb[i] == pagedb_in[i];

    // increment AS refcount
    ghost var pagedb_incref;
    pagedb_incref := addrspace_incref(as_va, tmp, pagedb_in, entry.addrspace);
    AllocatePageImpliesIncrefAddrspace(pagedb_in, pagenr, entry.addrspace, entry.entry);
    assert pagedb_incref[entry.addrspace] == pagedb[entry.addrspace];
    assert pageDbCorrespondsOnly(this.m, pagedb, entry.addrspace);
    assert pageDbCorrespondsExcluding(this.m, pagedb_in, entry.addrspace);
    ghost var midway := this;
    AllButOnePagePreserving(entry.addrspace, old(this), this);

    // update pagedb
    tmp := typeval;
    tmp2 := sp_op_const(PAGEDB_ENTRY_SIZE());
    MUL(tmp2,pagenr,tmp2);
    assert tmp2 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
    STRglobal(tmp, PageDb(), pagedb_base, tmp2);
    ADD(tmp2, tmp2, sp_op_const(PAGEDB_ENTRY_ADDRSPACE()));
    assert tmp2 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
    STRglobal(as_va, PageDb(), pagedb_base, tmp2);

    forall :: pageDbEntryCorresponds(pagedb[pagenr],
                               extractPageDbEntry(this.m, pagenr))
    {
        assert extractPageDbEntry(this.m, pagenr)
            == seq(pageDbEntryTypeVal(entry), as_va);
        reveal_pageDbEntryCorresponds();
    }

    // memset
    page_monvaddr_impl(page_va, pagenr, tmp);
    tmp2 := sp_op_const(KEVLAR_PAGE_SIZE());
    tmp := 0;
    memset(page_va,tmp,tmp2);

    // memset didn't touch any other pages
    AllButOnePagePreserving(pagenr, midway, this);

    // pagedb now corresponds for this new entry
    forall :: pageDbCorrespondsOnly(this.m, pagedb, pagenr)
    {
        assert pageDbEntryCorresponds(pagedb[pagenr],
                                      extractPageDbEntry(this.m, pagenr));
        reveal_pageContentsCorresponds();
        reveal_pageDbDispatcherCorresponds();
        //ghost var pg := extractPage(this.m, pagenr);
        //assert forall m :: addrInPage(m, pagenr) ==> pg[m] == 0;

       // TODO: FIXME: we haven't set the dispatcher entrypoint!
       // this will be fixed up shortly...
        assume false;
    }

    // the rest of the pagedb wasn't messed with
    forall :: pageDbCorresponds(this.m, pagedb)
    {
        assert forall i :: validPageNr(i) && i != entry.addrspace && i != pagenr
        ==> extractPage(this.m, i) == extractPage(old(this.m), i);
        assert pageDbCorrespondsOnly(this.m, pagedb, entry.addrspace);
    }
}

procedure allocate_page(
    {:operand} pagenr:PageNr,
    {:operand} as_va:mem,
    {:operand} typeval:int,
    {:operand} pagedb_base:mem,
    out {:operand} tmp:int,
    out {:operand} page_va:int,
    out {:operand} err:int,
    ghost pagedb_in:PageDb,
    ghost entry:PageDbEntry)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@pagenr, @as_va, @pagedb_base, @tmp, @page_va, @err), 6);
        ValidOperand(@typeval) && @typeval is OConst;
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        closedRefsPageDbEntry(entry);
        entry is PageDbEntryTyped && validAddrspacePage(pagedb_in, entry.addrspace);
        allocatePageEntryValid(entry.entry);
        typeval == pageDbEntryTypeVal(entry);
        entry.entry is Dispatcher; // FIXME: temp shortcut!
        as_va == page_monvaddr(entry.addrspace);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        AlwaysInvariant(old(this),this);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this),this, set(@tmp, @page_va, @err));
        tuple(pagedb, err)
            == allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry);
        //err == KEV_ERR_SUCCESS() ==> page_va == page_monvaddr(old(pagenr));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, entry.addrspace);
    pagedb := pagedb_in;

    if (pagenr >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else {
        assert validPageNr(pagenr);
        // NB: using err as a second tmp reg here
        err := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(err,pagenr,err);
        assert err == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
        LDRglobal(tmp, PageDb(), pagedb_base, err);

        forall :: tmp == pageDbEntryTypeVal(pagedb_in[pagenr])
        {
            reveal_pageDbEntryCorresponds();
            PageDbCorrespondsImpliesEntryCorresponds(this.m, pagedb_in, pagenr);
        }

        if (tmp != sp_op_const(KEV_PAGE_FREE())) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else {
            LDR(tmp, as_va, sp_op_const(ADDRSPACE_STATE()));
            forall :: tmp == pageDbAddrspaceStateVal(pagedb[entry.addrspace].entry.state)
            {
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            if (tmp != sp_op_const(KEV_ADDRSPACE_INIT())) {
                err := sp_op_const(KEV_ERR_ALREADY_FINAL());
            } else {
                pagedb := allocate_page_success(pagenr, as_va, typeval,
                                pagedb_base, tmp, err, page_va, pagedb_in, entry);
                err := sp_op_const(KEV_ERR_SUCCESS());
            }
        }
    }
}

//=============================================================================
// Init addrspace
//=============================================================================

/* Register allocation for init_addrspace paths:
 * r0 temp / err out
 * r1 addrspace_pagenr in
 * r2 l1pt_pagenr in
 * r3 temp
 * r4 addrspace_page pagedb entry offset
 * r5 l1pt_page pagedb entry offset
 * r6 addrspace monvaddr
 * r7 l1pt paddr & monvaddr
 * r12 pagedb global base
 */

#verbatim
function initAddrspaceEntry(addrspace_page:int, l1pt_page:int): PageDbEntry
{
    PageDbEntryTyped(addrspace_page, Addrspace(l1pt_page, 1, InitState))
}

function initL1PTEntry(addrspace_page:int): PageDbEntry
{
    PageDbEntryTyped(addrspace_page, L1PTable(SeqRepeat(NR_L1PTES(), Nothing)))
}
#endverbatim

procedure init_addrspace_mem(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R6)} addrspace_va:int)
    requires/ensures
        SaneState(this);
    requires
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        addrspace_page != l1pt_page;
        addrspace_va == page_monvaddr(addrspace_page);
    ensures
        AlwaysInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
        StackPreserving(old(this),this);
        forall i :: ValidMem(this.m, i)
            && !(page_monvaddr(addrspace_page) <= i < page_monvaddr(addrspace_page) + KEVLAR_PAGE_SIZE())
            && !(page_monvaddr(l1pt_page) <= i < page_monvaddr(l1pt_page) + KEVLAR_PAGE_SIZE())
            ==> addrval(this,i) == addrval(old(this),i);
        RegPreservingExcept(old(this),this, set(@r0, @r3, @r7));
        pageContentsCorresponds(old(addrspace_page), initAddrspaceEntry(addrspace_page, l1pt_page), extractPage(this.m, old(addrspace_page)));
        pageContentsCorresponds(old(l1pt_page), initL1PTEntry(addrspace_page), extractPage(this.m, old(l1pt_page)));
{
    reveal_pageContentsCorresponds();
    reveal_pageDbAddrspaceCorresponds();

    page_paddr_impl(r7,l1pt_page,r0);

    STR(r7,r6,sp_op_const(ADDRSPACE_L1PT_PHYS()));
    assert addrval(this,addrspace_va + ADDRSPACE_L1PT_PHYS()) == page_paddr(l1pt_page);

    r7 += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
    assert r7 == page_monvaddr(l1pt_page);
    STR(r7,r6,sp_op_const(ADDRSPACE_L1PT()));
    assert addrval(this,addrspace_va + ADDRSPACE_L1PT()) == page_monvaddr(l1pt_page);

    r0 := 1;
    STR(r0,r6,sp_op_const(ADDRSPACE_REF()));
    assert addrval(this,addrspace_va + ADDRSPACE_REF()) == 1;

    r0 := sp_op_const(KEV_ADDRSPACE_INIT());
    STR(r0,r6,sp_op_const(ADDRSPACE_STATE()));
    assert addrval(this,addrspace_va + ADDRSPACE_STATE()) == KEV_ADDRSPACE_INIT();

    r3 := sp_op_const(KEVLAR_PAGE_SIZE());
    r0 := 0;
    memset(r7,r0,r3);

    ghost var l1pg := extractPage(this.m, old(l1pt_page));
    ghost var emptyptes := SeqRepeat(NR_L1PTES(), Nothing);
    forall :: pageDbL1PTableCorresponds(l1pt_page, L1PTable(emptyptes), l1pg)
    {
        reveal_pageDbL1PTableCorresponds();
        assert forall m :: addrInPage(m, l1pt_page) ==> l1pg[m] == 0;
    }
}

procedure init_addrspace_pagedb(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R4)} addrspace_entry:int,
    {:register OReg(R5)} l1pt_entry:int,
    out {:register OReg(R6)} addrspace_va:int,
    {:register OReg(R12)} pagedb_base:int)
    requires/ensures
        SaneState(this);
    requires
        addrspace_page != l1pt_page;
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        addrspace_entry == G_PAGEDB_ENTRY(addrspace_page);
        l1pt_entry == G_PAGEDB_ENTRY(l1pt_page);
        pagedb_base == AddressOfGlobal(PageDb());
    ensures
        AlwaysInvariant(old(this),this);
        AddrMemInvariant(old(this),this);
        RegPreservingExcept(old(this),this, set(@r0, @r4, @r5, @r6));
        addrspace_va == page_monvaddr(old(addrspace_page));
        forall p :: validPageNr(p) && p != addrspace_page && p != l1pt_page
            ==> extractPageDbEntry(old(this).m, p) == extractPageDbEntry(this.m, p);
        pageDbEntryCorresponds(initAddrspaceEntry(addrspace_page, l1pt_page),
                               extractPageDbEntry(this.m, addrspace_page));
        pageDbEntryCorresponds(initL1PTEntry(addrspace_page),
                               extractPageDbEntry(this.m, l1pt_page));
{
    reveal_pageDbEntryCorresponds();

    /* update addrspace entry in pagedb */
    r0 := sp_op_const(KEV_PAGE_ADDRSPACE());
    STRglobal(r0, PageDb(), r12, r4);
    assert GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE())
        == KEV_PAGE_ADDRSPACE();

    page_monvaddr_impl(r6,addrspace_page,r0);
    r4 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    assert r4 == G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_ADDRSPACE();
    STRglobal(r6, PageDb(), r12, r4);
    assert extractPageDbEntry(this.m, addrspace_page)[BytesToWords(PAGEDB_ENTRY_ADDRSPACE())]
           == page_monvaddr(addrspace_page);

    assert extractPageDbEntry(this.m, addrspace_page)
        == seq(KEV_PAGE_ADDRSPACE(), old(page_monvaddr(addrspace_page)));

    /* Update l1pt entry in pagedb */
    r0 := sp_op_const(KEV_PAGE_L1PTABLE());
    STRglobal(r0, PageDb(), r12, r5);
    assert GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_L1PTABLE();
    r5 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    assert r5 == G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_ADDRSPACE();
    STRglobal(r6, PageDb(), r12, r5);
    assert GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(addrspace_page);

    assert extractPageDbEntry(this.m, l1pt_page)
        == seq(KEV_PAGE_L1PTABLE(), old(page_monvaddr(addrspace_page)));
}

procedure init_addrspace(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R4)} addrspace_entry:int,
    {:register OReg(R5)} l1pt_entry:int,
    {:register OReg(R12)} pagedb_base:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        addrspace_page != l1pt_page;
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        l1pt_page % 4 == 0;
        addrspace_entry == G_PAGEDB_ENTRY(addrspace_page);
        l1pt_entry == G_PAGEDB_ENTRY(l1pt_page);
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        pageDbClosedRefs(pagedb_in);
        wellFormedPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        pageIsFree(pagedb_in, addrspace_page);
        pageIsFree(pagedb_in, l1pt_page);
    ensures
        AlwaysInvariant(old(this),this);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this),this, set(@r0, @r3, @r4, @r5, @r6, @r7));
        old(specPageDb(smc_initAddrspace_premium(pagedb_in, addrspace_page, l1pt_page))) == pagedb;
        pageDbClosedRefs(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ghost var gaddrspace_entry := initAddrspaceEntry(addrspace_page, l1pt_page);
    ghost var gl1pt_entry := initL1PTEntry(addrspace_page);
    pagedb := pagedb_in[addrspace_page := gaddrspace_entry][l1pt_page := gl1pt_entry];

    /* Update entries in PageDb */
    init_addrspace_pagedb(addrspace_page, l1pt_page, addrspace_entry, l1pt_entry, r6, pagedb_base);
    assert pageDbEntryCorresponds(gaddrspace_entry,
                                  extractPageDbEntry(this.m, addrspace_page));
    assert pageDbEntryCorresponds(gl1pt_entry,
                                  extractPageDbEntry(this.m, l1pt_page));

    /* Update pages in memory */
    init_addrspace_mem(addrspace_page, l1pt_page, r6);

    // It should be okay that this isn't wrapped in a forall ::.
    // The rest of this code is about pagedb anyway.
    reveal_validPageDb();
    reveal_pageDbClosedRefs();

    assert pageDbCorrespondsOnly(this.m, pagedb, addrspace_page);
    assert pageDbCorrespondsOnly(this.m, pagedb, l1pt_page);

    // other pages haven't changed
    assert forall p :: validPageNr(p) && p != addrspace_page && p != l1pt_page
        ==> extractPageDbEntry(old(this).m, p) == extractPageDbEntry(this.m, p)
            && extractPage(old(this).m, p) == extractPage(this.m, p);
    assert forall p :: validPageNr(p) && p != addrspace_page && p != l1pt_page
        ==> pageDbCorrespondsOnly(old(this).m, pagedb, p);

    forall ::
        old(specPageDb(smc_initAddrspace_premium(pagedb_in, addrspace_page, l1pt_page))) == pagedb &&
        pageDbCorresponds(this.m, pagedb)
    {
        reveal_smc_initAddrspace_premium();
    }
}

procedure kev_smc_init_addrspace(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbClosedRefs(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        StackPreserving(old(this),this);
        tuple(pagedb, err)
            == old(smc_initAddrspace_premium(pagedb_in, addrspace_page, l1pt_page));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    reveal_pageDbEntryCorresponds();
    pagedb := pagedb_in;
    reveal_pageDbClosedRefs();

    // check alignment of l1pt page
    AND(r0,l1pt_page,3);
    assert r0 == l1pt_page % 4;

    if (addrspace_page == l1pt_page) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (addrspace_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (l1pt_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (r0 != 0) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else {
        LDRglobaladdr(r12, PageDb());
        assert validPageNr(addrspace_page) && validPageNr(l1pt_page);
        r0 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r4,addrspace_page,r0);
        assert r4 == G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r3, PageDb(), r12, r4);
        assert pageDbEntryCorresponds(pagedb[addrspace_page], extractPageDbEntry(this.m, addrspace_page));
        assert r3 == GlobalWord(this.m, PageDb(), r4) == pageDbEntryTypeVal(pagedb[addrspace_page]);
        if (r3 == sp_op_const(KEV_PAGE_FREE())) {
            assert pageIsFree(pagedb, addrspace_page);
            assert r0 == PAGEDB_ENTRY_SIZE();
            MUL(r5,l1pt_page,r0);
            assert r5 == G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_TYPE();
            LDRglobal(r0, PageDb(), r12, r5);
            assert pageDbEntryCorresponds(pagedb[l1pt_page], extractPageDbEntry(this.m, l1pt_page));
            assert r0 == GlobalWord(this.m, PageDb(), r5) == pageDbEntryTypeVal(pagedb[l1pt_page]);
            if (r0 == sp_op_const(KEV_PAGE_FREE())) {
                assert pageIsFree(pagedb, l1pt_page);
                pagedb := init_addrspace(addrspace_page, l1pt_page, r4, r5, r12, pagedb);
                err := OConst(KEV_ERR_SUCCESS());
            } else {
                err := sp_op_const(KEV_ERR_PAGEINUSE());
            }
        } else {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        }
    }
    forall :: 
        tuple(pagedb, err) == old(smc_initAddrspace_premium(pagedb_in, addrspace_page, l1pt_page))
        && pageDbClosedRefs(pagedb) && pageDbCorresponds(this.m, pagedb)
    {
        reveal_smc_initAddrspace_premium();
        reveal_validPageDb();
    }
}


//=============================================================================
// Init dispatcher
//=============================================================================

procedure kev_smc_init_dispatcher(
    {:register OReg(R1)} disp_page:int,
    {:register OReg(R2)} as_page:int,
    {:register OReg(R3)} entrypoint:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbClosedRefs(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        StackPreserving(old(this),this);
        tuple(pagedb, err)
            == old(smc_initDispatcher_premium(pagedb_in, disp_page, as_page, entrypoint));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    reveal_pageDbEntryCorresponds();
    reveal_pageDbClosedRefs();
    reveal_smc_initDispatcher_premium();

    if (as_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_ADDRSPACE());
    } else {
        LDRglobaladdr(r12, PageDb());
        assert validPageNr(as_page);
        r0 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r4,as_page,r0);
        assert r4 == G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r0, PageDb(), r12, r4);
        assert r0 == pageDbEntryTypeVal(pagedb[as_page]);
        if (r0 != sp_op_const(KEV_PAGE_ADDRSPACE())) {
            err := sp_op_const(KEV_ERR_INVALID_ADDRSPACE());
        } else {
            assert isAddrspace(pagedb, as_page);

            page_monvaddr_impl(r4, as_page, r6);

            ghost var entry := PageDbEntryTyped(as_page, Dispatcher(entrypoint, false, dispctxt(entrypoint)));
            pagedb := allocate_page(disp_page, r4,
                                    sp_op_const(KEV_PAGE_DISPATCHER()),
                                    r12, r5, r6 /* tmps */, err, pagedb, entry);
        }
    }
}

#verbatim
function dispctxt(entrypoint:int) : DispatcherContext
{
    DispatcherContext(map[], entrypoint, encode_mode(User))
}
#endverbatim

//=============================================================================
// Enter / Return
//=============================================================================
procedure smc_enter_err(
    {:register OReg(R0)} pagenr:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    out {:register OReg(R0)} err:int,
    ghost s:SysState)
    returns (ghost s':SysState)
    requires 
        this == s.hw;
        SaneState(this);
        validSysState(s);
    ensures
        this == s'.hw; 
        validSysState(s');
        RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
    ensures
        tuple(s'.d, err) == smc_enter_premium(s.d, pagenr, arg1, arg2, arg3);
{
    reveal_smc_enter_premium();
    if (pagenr >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        assert !validPageNr(pagenr);
        
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
        s' := s.(hw := this);
    } else {
        assert validPageNr(pagenr);

        LDRglobaladdr(r12, PageDb());
        r11 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r10,pagenr,r11);
        assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r9, PageDb(), r12, r10);
        forall :: pageDbEntryCorresponds(s.d[pagenr], extractPageDbEntry(this.m, pagenr))
        {
            reveal_validPageDb();
        }
        forall :: r9 == GlobalWord(s.hw.m, PageDb(), r10) &&
            r9 == pageDbEntryTypeVal(s.d[pagenr])
        {
            reveal_pageDbEntryCorresponds(); reveal_pageContentsCorresponds();
        }
        assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
        if( r9 != sp_op_const(KEV_PAGE_DISPATCHER()) ) {
            assert !(s.d[pagenr] is PageDbEntryTyped && s.d[pagenr].entry is Dispatcher);

            err := sp_op_const(KEV_ERR_INVALID_PAGENO());
            s' := s.(hw := this);
        } else {
            assert s.d[pagenr] is PageDbEntryTyped && s.d[pagenr].entry is Dispatcher;

            r10 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
            assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
            WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE(), r10);
           
            LDRglobal(r8, PageDb(), r12, r10);
            ghost var addrspace := s.d[pagenr].addrspace;
            forall :: r8 == page_monvaddr(addrspace) && WordAligned(r8)
            {
                reveal_pageDbEntryCorresponds(); reveal_pageContentsCorresponds();
                reveal_validPageDb();
            }
            WordAlignedAdd_(r8,ADDRSPACE_STATE(),r8+ADDRSPACE_STATE());
           
            forall :: ValidMem(this.m, addr_mem(this, @r8, sp_op_const(ADDRSPACE_STATE())))
                { reveal_validPageDb(); } 
            LDR(r8, r8, sp_op_const(ADDRSPACE_STATE()));
            forall :: 
            (r8 == KEV_ADDRSPACE_FINAL() ==>
                s.d[addrspace].entry.state == FinalState) &&
            (r8 != KEV_ADDRSPACE_FINAL() ==>
                s.d[addrspace].entry.state != FinalState)
            {
                reveal_validPageDb();
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            // this particular RegPreserving assert saved 30s.
            assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
            if( r8 != sp_op_const(KEV_ADDRSPACE_FINAL()) ) {
                forall :: s.d[addrspace].entry.state != FinalState { reveal_validPageDb(); }
                err := sp_op_const(KEV_ERR_NOT_FINAL());
                s' := s.(hw := this);
            } else {
                forall :: s.d[addrspace].entry.state == FinalState { reveal_validPageDb(); }
                
                assert this.m == old(this.m);
                assert SaneState(this);
                page_monvaddr_impl(r9,pagenr,r10);
                assert r9 == page_monvaddr(pagenr);
                forall :: addrval(this, page_monvaddr(pagenr) + 
                    DISPATCHER_ENTERED()) == to_i(s.d[pagenr].entry.entered)
                {
                    reveal_pageContentsCorresponds();
                    reveal_pageDbDispatcherCorresponds();
                }
                LDR(r9,r9,sp_op_const(DISPATCHER_ENTERED()));
                
                assert r9 == 1 ==> s.d[pagenr].entry.entered;
                assert r9 != 1 ==> !(s.d[pagenr].entry.entered);
                assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
                if( r9 == 1 ) {
                    err := sp_op_const(KEV_ERR_ALREADY_ENTERED());
                    s' := s.(hw := this);
                } else {
                    err := sp_op_const(KEV_ERR_SUCCESS());
                    s' := s.(hw := this);
                }
            }
        }
    }
}

procedure exceptionProc(ghost s:SysState)
    returns (ghost s':SysState)
    requires
        this == s.hw;
        validSysState(s);
        userEnteredState(s);
    ensures 
        this == s'.hw;
        validSysState(s');
        exception(s, s');
{
    assume false;
}

procedure kev_smc_enter(
    {:register OReg(R0)} pagenr:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost s:SysState)
    returns (ghost s':SysState)
    requires 
        this == s.hw; 
        validSysState(s);
        SaneState(s.hw);
        isUInt32(arg1) && isUInt32(arg2) && isUInt32(arg3);
    ensures
        this == s'.hw;
        //TODO SaneState(s'.hw);
        validSysState(s');
        tuple(s'.d, err) == smc_enter_premium(s.d, pagenr, arg1, arg2, arg3);
        validEnter(s,s',pagenr,arg1,arg2,arg3);
{
    reveal_validEnter();
    reveal_smc_enter_premium();
    r5 := pagenr;
    ghost var s_err;
    s_err := smc_enter_err(@r0,@r1,@r2,@r3,@r0,s.(hw := this));
    if(err != sp_op_const(KEV_ERR_SUCCESS()) ) {
        val := sp_op_const(0);
        s' := s_err.(hw := this);
        assert validSysState(s');
        assert tuple(s'.d, err) == smc_enter(s.d, pagenr, arg1, arg2, arg3);
    } else {
        assume false; // TODO
        ///  // ghost var s_test:SysState;
        ///  // ghost var err_test :int;
        ///  ghost var r:SysState; 
        ///  // assume validPageDb(s_test.d);
        ///  // assume validSysState(s_test);
        ///  assert specErr(smc_enter(s.d, pagenr, arg1, arg2, arg3)) == KEV_ERR_SUCCESS();
        ///  assume r.hw == this;
        ///  assume validEntryTransitionEnter(s,r,pagenr,arg1,arg2,arg3);

        ///  // ghost var r := userspaceExecutionF(q); 
        ///  
        ///  s' := exceptionProc(r);
        ///  // assume this == s';
        ///  assert validEntryTransitionEnter(s,r,pagenr,arg1,arg2,arg3) && exception(r, s');

        ///  // assert (validEntryTransitionEnter(s_test,q,pagenr,arg1,arg2,arg3)
        ///  //     && userspaceExecution(q, r) && exception(r, s'));

        ///  assert SaneMem(s'.hw.m);

        ///  //assert SaneState(s'.hw); 

        ///  // assert false;

        ///  // val := sp_op_const(0);
        ///  // s' := s'.(hw := this);
    }
    
}


//=============================================================================
// Top-level SMC handler
//=============================================================================

#verbatim
lemma SameMemAndGlobalsImpliesSamePageDb(s:state, s':state, pagedb:PageDb)
    requires SaneState(s) && SaneState(s')
    requires AlwaysInvariant(s,s')
    requires pageDbClosedRefs(pagedb)
    requires pageDbCorresponds(s.m, pagedb)
    requires NonStackMemPreserving(s,s')
    requires GlobalsInvariant(s,s')
    ensures pageDbCorresponds(s'.m, pagedb)
{
    assert GlobalFullContents(s.m, PageDb()) == GlobalFullContents(s'.m, PageDb());
    assert forall p :: validPageNr(p) ==> extractPage(s.m, p) == extractPage(s'.m, p);
}
#endverbatim

procedure smc_handler(
    {:register OReg(R0)} callno:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    {:register OReg(R4)} arg4:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} retval:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this,120);
    requires
        validPageDb(pagedb_in);
        pageDbClosedRefs(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        NonvolatileRegPreserving(old(this),this);
        //tuple(pagedb, err, retval) == old(smchandler_premium(pagedb_in, callno, arg1, arg2, arg3, arg4));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ghost var stack_bytes := 120;
    pagedb := pagedb_in;
    retval := 0;

    fcall_prologue(stack_bytes);
    SameMemAndGlobalsImpliesSamePageDb(old(this), this, pagedb);

    if(callno == sp_op_const(KEV_SMC_QUERY())) {
        err := sp_op_const(KEV_MAGIC());
    } else if(callno == sp_op_const(KEV_SMC_GETPHYSPAGES())) {
        retval := sp_op_const(KEVLAR_SECURE_NPAGES());
        err := sp_op_const(KEV_ERR_SUCCESS());
    } else if(callno == sp_op_const(KEV_SMC_INIT_ADDRSPACE())) {
        pagedb := kev_smc_init_addrspace(arg1, arg2, err, pagedb);
    } else if(callno == sp_op_const(KEV_SMC_INIT_DISPATCHER())) {
        pagedb := kev_smc_init_dispatcher(arg1, arg2, arg3, err, pagedb);
    }

    ghost var prePopThis := this;
    fcall_epilogue(stack_bytes-40);
    SameMemAndGlobalsImpliesSamePageDb(prePopThis, this, pagedb);

    // zero other volatiles to prevent information leakage
    r2 := 0;
    r3 := 0;

    // TODO: return path (movs pc, lr etc.)
}

#verbatim
method Main()
{
    printHeader();
    var n := printFunction("smc_handler", sp_code_smc_handler(), 0);
    printBss(KevGlobalDecls());
    printFooter();
}
#endverbatim
