#verbatim // workarounds for Spartan's lack of Dafny language features
function specPageDb(t: (PageDb, int)): PageDb { t.0 }
function specErr(t: (PageDb, int)): int { t.1 }
#endverbatim

//=============================================================================
// Allocate page
//=============================================================================

#verbatim
lemma ValidPageDbImpliesValidAddrspace(d:PageDb, n:PageNr)
    requires validPageDb(d)
    requires isAddrspace(d, n)
    ensures closedRefsPageDbEntry(d[n]) && validAddrspace(d, n)
{
    reveal_validPageDb();
    assert validPageDbEntryTyped(d, n);
}

lemma PageDbCorrespondsImpliesEntryCorresponds(s:memstate, d:PageDb, n:PageNr)
    requires SaneMem(s)
    requires pageDbClosedRefs(d)
    requires pageDbCorresponds(s, d)
    requires validPageNr(n)
    ensures closedRefsPageDbEntry(d[n])
    ensures pageDbEntryCorresponds(d[n], extractPageDbEntry(s, n))
{
    reveal_pageDbClosedRefs();
}

lemma BoundedAddrspaceRefs(d:PageDb, n:PageNr)
    requires validPageDb(d)
    requires isAddrspace(d, n)
    ensures d[n].entry.refcount <= KEVLAR_SECURE_NPAGES()
{
    reveal_validPageNrs();
    reveal_validPageDb();
    assert addrspaceRefs(d,n) <= validPageNrs();
    assert d[n].entry.refcount == |addrspaceRefs(d,n)|;
    SubsetCardinality(addrspaceRefs(d,n), validPageNrs());
}

lemma OnePagePreserving(n:PageNr,s:state,r:state)
    requires validPageNr(n)
    requires SaneState(s) && SaneState(r) && AlwaysInvariant(s,r)
    requires forall m :: ValidMem(s.m,m) && addrInPage(m,n) ==> addrval(s,m) == addrval(r,m)
    ensures extractPage(s.m, n) == extractPage(r.m, n)
{
}

lemma AllButOnePagePreserving(n:PageNr,s:state,r:state)
    requires validPageNr(n)
    requires SaneState(s) && SaneState(r) && AlwaysInvariant(s,r)
    requires MemPreservingExcept(s, r, page_monvaddr(n), page_monvaddr(n) + KEVLAR_PAGE_SIZE())
    ensures forall p :: validPageNr(p) && p != n ==> extractPage(s.m, p) == extractPage(r.m, p)
{
}

function increfAddrspaceEntry(entry:PageDbEntry): PageDbEntry
    requires entry.PageDbEntryTyped? && entry.entry.Addrspace?
{
    entry.(entry := entry.entry.(refcount := entry.entry.refcount + 1))
}

function increfAddrspacePageDb(d:PageDb, n:PageNr): PageDb
    requires validAddrspacePage(d, n)
    requires pageDbClosedRefs(d)
    ensures pageDbClosedRefs(d)
{
    reveal_pageDbClosedRefs();
    d[n := increfAddrspaceEntry(d[n])]
}

lemma AllocatePageImpliesIncrefAddrspace(dbin: PageDb, pg: PageNr,
                                         aspg: PageNr, entry: PageDbEntryTyped)
    requires validPageDb(dbin)
    requires validAddrspacePage(dbin, aspg)
    requires allocatePageEntryValid(entry)
    requires allocatePage(dbin, pg, aspg, entry).1 == KEV_ERR_SUCCESS()
    ensures (allocatePage(dbin, pg, aspg, entry).0)[aspg]
        == increfAddrspaceEntry(dbin[aspg]);
{
}

lemma SameEntriesImpliesPageDbCorresponds(s:memstate, p: PageNr,
                                          db1: PageDb, db2: PageDb)
    requires SaneMem(s)
    requires validPageNr(p)
    requires pageDbClosedRefs(db1) && pageDbClosedRefs(db2)
    requires pageDbCorresponds(s, db1) || pageDbCorrespondsOnly(s, db1, p)
    requires db1[p] == db2[p]
    ensures pageDbCorrespondsOnly(s, db2, p)
{
    reveal_pageDbClosedRefs();
}
#endverbatim

procedure addrspace_incref(
    {:operand} as_va:mem,
    out {:operand} tmp:int,
    ghost pagedb_in:PageDb,
    ghost pagenr:int)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@as_va, @tmp), 2);
        validPageDb(pagedb_in);
        validAddrspacePage(pagedb_in, pagenr);
        as_va == page_monvaddr(pagenr);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        AlwaysInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
        StackPreserving(old(this),this);
        MemPreservingExcept(old(this),this, as_va, as_va + KEVLAR_PAGE_SIZE());
        RegPreservingExcept(old(this),this, set(@tmp));
        pagedb == increfAddrspacePageDb(pagedb_in, pagenr);
        pageDbClosedRefs(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, pagenr);
    pagedb := increfAddrspacePageDb(pagedb_in, pagenr);
    reveal_pageDbClosedRefs();

    LDR(tmp, as_va, sp_op_const(ADDRSPACE_REF()));

    // help dafny see that refcount++ won't overflow
    forall :: tmp == pagedb_in[pagenr].entry.refcount
        && tmp <= KEVLAR_SECURE_NPAGES()
    {
        reveal_pageContentsCorresponds();
        reveal_pageDbAddrspaceCorresponds();
        assert pageDbAddrspaceCorresponds(pagenr,
                pagedb_in[pagenr].entry, this.m.addresses);
        assert tmp == pagedb_in[pagenr].entry.refcount;
        BoundedAddrspaceRefs(pagedb_in, pagenr);
    }

    ADD(tmp, tmp, 1);
    assert tmp == pagedb[pagenr].entry.refcount;
    STR(tmp, as_va, sp_op_const(ADDRSPACE_REF()));

    forall p :| validPageNr(p) ::
        pageDbEntryCorresponds(pagedb[p], extractPageDbEntry(this.m, p))
    {
        reveal_pageDbEntryCorresponds();
        assert pageDbEntryCorresponds(pagedb_in[p],
                                      extractPageDbEntry(old(this).m, p));
        assert extractPageDbEntry(this.m, p) == extractPageDbEntry(old(this).m, p);
    }

    AllButOnePagePreserving(pagenr, old(this), this);
    assert pageDbCorrespondsExcluding(this.m, pagedb, pagenr);

    forall :: pageContentsCorresponds(pagenr, pagedb[pagenr],
                                extractPage(this.m, pagenr))
    {
        reveal_pageContentsCorresponds();
        reveal_pageDbAddrspaceCorresponds();
    }
}

procedure allocate_page_success(
    {:operand} pagenr:PageNr,
    {:operand} as_va:mem,
    {:operand} typeval:int,
    {:operand} pagedb_base:mem,
    out {:operand} tmp:int,
    out {:operand} tmp2:int,
    ghost pagedb_in:PageDb,
    ghost entry:PageDbEntry)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@pagenr, @as_va, @pagedb_base, @tmp, @tmp2), 5);
        ValidOperand(@typeval) && @typeval is OConst;
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        closedRefsPageDbEntry(entry);
        entry is PageDbEntryTyped && validAddrspacePage(pagedb_in, entry.addrspace);
        allocatePageEntryValid(entry.entry);
        typeval == pageDbEntryTypeVal(entry);
        as_va == page_monvaddr(entry.addrspace);
        pageDbCorresponds(this.m, pagedb_in);
        validPageNr(pagenr) && pageIsFree(pagedb_in, pagenr);
        pagedb_in[entry.addrspace].entry.state == InitState;
    ensures
        AlwaysInvariant(old(this),this);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this),this, set(@tmp, @tmp2));
        pagedb == specPageDb(allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry));
        pageDbCorrespondsExcluding(this.m, pagedb, pagenr);
        pageDbEntryCorresponds(pagedb[pagenr], extractPageDbEntry(this.m, pagenr));
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, entry.addrspace);
    assert specErr(allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry))
        == KEV_ERR_SUCCESS();
    pagedb := specPageDb(allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry));

    // increment AS refcount
    ghost var pagedb_incref;
    pagedb_incref := addrspace_incref(as_va, tmp, pagedb_in, entry.addrspace);
    AllocatePageImpliesIncrefAddrspace(pagedb_in, pagenr, entry.addrspace, entry.entry);
    assert pagedb_incref[entry.addrspace] == pagedb[entry.addrspace];
    assert pageDbCorrespondsOnly(this.m, pagedb, entry.addrspace);
    assert pageDbCorrespondsExcluding(this.m, pagedb_in, entry.addrspace);

    // remember that no other pages changed
    ghost var midway := this;
    AllButOnePagePreserving(entry.addrspace, old(this), midway);

    // update pagedb
    tmp := typeval;
    tmp2 := sp_op_const(PAGEDB_ENTRY_SIZE());
    MUL(tmp2,pagenr,tmp2);
    assert tmp2 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
    STRglobal(tmp, PageDb(), pagedb_base, tmp2);
    ADD(tmp2, tmp2, sp_op_const(PAGEDB_ENTRY_ADDRSPACE()));
    assert tmp2 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
    STRglobal(as_va, PageDb(), pagedb_base, tmp2);

    // no pages changed across pagedb update
    assert this.m.addresses == midway.m.addresses;

    forall :: pageDbEntryCorresponds(pagedb[pagenr], extractPageDbEntry(this.m, pagenr))
    {
        assert extractPageDbEntry(this.m, pagenr)
            == seq(pageDbEntryTypeVal(entry), as_va);
        reveal_pageDbEntryCorresponds();
    }

    forall :: pageDbCorrespondsOnly(this.m, pagedb, entry.addrspace) {
        assert pageDbCorrespondsOnly(midway.m, pagedb, entry.addrspace);
        assert extractPageDbEntry(this.m, entry.addrspace)
            == extractPageDbEntry(midway.m, entry.addrspace);
        assert extractPage(this.m, entry.addrspace)
            == extractPage(midway.m, entry.addrspace);
    }

    forall :: pageDbCorrespondsExcluding(this.m, pagedb, pagenr)
    {
        assert forall i :: validPageNr(i) && i != entry.addrspace
        ==> extractPage(this.m, i) == extractPage(old(this.m), i);
    }
}

procedure allocate_page(
    {:operand} pagenr:PageNr,
    {:operand} as_pagenr:PageNr,
    {:operand} typeval:int,
    {:operand} pagedb_base:mem,
    out {:operand} tmp:int,
    out {:operand} tmp2:int,
    out {:operand} err:int,
    ghost pagedb_in:PageDb,
    ghost entry:PageDbEntry)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@pagenr, @as_pagenr, @pagedb_base, @tmp, @tmp2, @err), 6);
        ValidOperand(@typeval) && @typeval is OConst;
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        closedRefsPageDbEntry(entry);
        entry is PageDbEntryTyped && validAddrspacePage(pagedb_in, entry.addrspace);
        allocatePageEntryValid(entry.entry);
        typeval == pageDbEntryTypeVal(entry);
        as_pagenr == entry.addrspace;
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        AlwaysInvariant(old(this),this);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this),this, set(@tmp, @tmp2, @err));
        tuple(pagedb, err)
            == allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry);
        // we update all of the pagedb except the target page itself,
        // which is the responsibility of the caller
        if err == KEV_ERR_SUCCESS()
        then pageDbCorrespondsExcluding(this.m, pagedb, pagenr)
            && pageDbEntryCorresponds(pagedb[pagenr],
                                     extractPageDbEntry(this.m, pagenr))
        else pagedb == pagedb_in && pageDbCorresponds(this.m, pagedb);
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, entry.addrspace);
    pagedb := pagedb_in;

    if (pagenr >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else {
        assert validPageNr(pagenr);
        // NB: using err as a second tmp reg here
        err := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(err,pagenr,err);
        assert err == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
        LDRglobal(tmp, PageDb(), pagedb_base, err);

        forall :: tmp == pageDbEntryTypeVal(pagedb_in[pagenr])
        {
            reveal_pageDbEntryCorresponds();
            PageDbCorrespondsImpliesEntryCorresponds(this.m, pagedb_in, pagenr);
        }

        if (tmp != sp_op_const(KEV_PAGE_FREE())) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else {
            page_monvaddr_impl(tmp2, as_pagenr, err);

            LDR(tmp, tmp2, sp_op_const(ADDRSPACE_STATE()));
            forall :: tmp == pageDbAddrspaceStateVal(pagedb[entry.addrspace].entry.state)
            {
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            if (tmp != sp_op_const(KEV_ADDRSPACE_INIT())) {
                err := sp_op_const(KEV_ERR_ALREADY_FINAL());
            } else {
                pagedb := allocate_page_success(pagenr, tmp2, typeval,
                                pagedb_base, tmp, err, pagedb_in, entry);
                err := sp_op_const(KEV_ERR_SUCCESS());
            }
        }
    }
}

//=============================================================================
// Init addrspace
//=============================================================================

/* Register allocation for init_addrspace paths:
 * r0 temp / err out
 * r1 addrspace_pagenr in
 * r2 l1pt_pagenr in
 * r3 temp
 * r4 addrspace_page pagedb entry offset
 * r5 l1pt_page pagedb entry offset
 * r6 addrspace monvaddr
 * r7 l1pt paddr & monvaddr
 * r12 pagedb global base
 */

#verbatim
function initAddrspaceEntry(addrspace_page:int, l1pt_page:int): PageDbEntry
{
    PageDbEntryTyped(addrspace_page, Addrspace(l1pt_page, 1, InitState))
}

function initL1PTEntry(addrspace_page:int): PageDbEntry
{
    PageDbEntryTyped(addrspace_page, L1PTable(SeqRepeat(NR_L1PTES(), Nothing)))
}
#endverbatim

procedure init_addrspace_mem(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R6)} addrspace_va:int)
    requires/ensures
        SaneState(this);
    requires
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        addrspace_page != l1pt_page;
        addrspace_va == page_monvaddr(addrspace_page);
    ensures
        AlwaysInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
        StackPreserving(old(this),this);
        forall i :: ValidMem(this.m, i)
            && !(page_monvaddr(addrspace_page) <= i < page_monvaddr(addrspace_page) + KEVLAR_PAGE_SIZE())
            && !(page_monvaddr(l1pt_page) <= i < page_monvaddr(l1pt_page) + KEVLAR_PAGE_SIZE())
            ==> addrval(this,i) == addrval(old(this),i);
        RegPreservingExcept(old(this),this, set(@r0, @r3, @r7));
        pageContentsCorresponds(old(addrspace_page), initAddrspaceEntry(addrspace_page, l1pt_page), extractPage(this.m, old(addrspace_page)));
        pageContentsCorresponds(old(l1pt_page), initL1PTEntry(addrspace_page), extractPage(this.m, old(l1pt_page)));
{
    reveal_pageContentsCorresponds();
    reveal_pageDbAddrspaceCorresponds();

    page_paddr_impl(r7,l1pt_page,r0);

    STR(r7,r6,sp_op_const(ADDRSPACE_L1PT_PHYS()));
    assert addrval(this,addrspace_va + ADDRSPACE_L1PT_PHYS()) == page_paddr(l1pt_page);

    r7 += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
    assert r7 == page_monvaddr(l1pt_page);
    STR(r7,r6,sp_op_const(ADDRSPACE_L1PT()));
    assert addrval(this,addrspace_va + ADDRSPACE_L1PT()) == page_monvaddr(l1pt_page);

    r0 := 1;
    STR(r0,r6,sp_op_const(ADDRSPACE_REF()));
    assert addrval(this,addrspace_va + ADDRSPACE_REF()) == 1;

    r0 := sp_op_const(KEV_ADDRSPACE_INIT());
    STR(r0,r6,sp_op_const(ADDRSPACE_STATE()));
    assert addrval(this,addrspace_va + ADDRSPACE_STATE()) == KEV_ADDRSPACE_INIT();

    r3 := sp_op_const(KEVLAR_PAGE_SIZE());
    r0 := 0;
    memset(r7,r0,r3);

    ghost var l1pg := extractPage(this.m, old(l1pt_page));
    ghost var emptyptes := SeqRepeat(NR_L1PTES(), Nothing);
    forall :: pageDbL1PTableCorresponds(l1pt_page, L1PTable(emptyptes), l1pg)
    {
        reveal_pageDbL1PTableCorresponds();
        assert forall m :: addrInPage(m, l1pt_page) ==> l1pg[m] == 0;
    }
}

procedure init_addrspace_pagedb(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R4)} addrspace_entry:int,
    {:register OReg(R5)} l1pt_entry:int,
    out {:register OReg(R6)} addrspace_va:int,
    {:register OReg(R12)} pagedb_base:int)
    requires/ensures
        SaneState(this);
    requires
        addrspace_page != l1pt_page;
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        addrspace_entry == G_PAGEDB_ENTRY(addrspace_page);
        l1pt_entry == G_PAGEDB_ENTRY(l1pt_page);
        pagedb_base == AddressOfGlobal(PageDb());
    ensures
        AlwaysInvariant(old(this),this);
        AddrMemInvariant(old(this),this);
        RegPreservingExcept(old(this),this, set(@r0, @r4, @r5, @r6));
        addrspace_va == page_monvaddr(old(addrspace_page));
        forall p :: validPageNr(p) && p != addrspace_page && p != l1pt_page
            ==> extractPageDbEntry(old(this).m, p) == extractPageDbEntry(this.m, p);
        pageDbEntryCorresponds(initAddrspaceEntry(addrspace_page, l1pt_page),
                               extractPageDbEntry(this.m, addrspace_page));
        pageDbEntryCorresponds(initL1PTEntry(addrspace_page),
                               extractPageDbEntry(this.m, l1pt_page));
{
    reveal_pageDbEntryCorresponds();

    /* update addrspace entry in pagedb */
    r0 := sp_op_const(KEV_PAGE_ADDRSPACE());
    STRglobal(r0, PageDb(), r12, r4);
    assert GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE())
        == KEV_PAGE_ADDRSPACE();

    page_monvaddr_impl(r6,addrspace_page,r0);
    r4 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    assert r4 == G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_ADDRSPACE();
    STRglobal(r6, PageDb(), r12, r4);
    assert extractPageDbEntry(this.m, addrspace_page)[BytesToWords(PAGEDB_ENTRY_ADDRSPACE())]
           == page_monvaddr(addrspace_page);

    assert extractPageDbEntry(this.m, addrspace_page)
        == seq(KEV_PAGE_ADDRSPACE(), old(page_monvaddr(addrspace_page)));

    /* Update l1pt entry in pagedb */
    r0 := sp_op_const(KEV_PAGE_L1PTABLE());
    STRglobal(r0, PageDb(), r12, r5);
    assert GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_L1PTABLE();
    r5 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    assert r5 == G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_ADDRSPACE();
    STRglobal(r6, PageDb(), r12, r5);
    assert GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(addrspace_page);

    assert extractPageDbEntry(this.m, l1pt_page)
        == seq(KEV_PAGE_L1PTABLE(), old(page_monvaddr(addrspace_page)));
}

procedure init_addrspace(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R4)} addrspace_entry:int,
    {:register OReg(R5)} l1pt_entry:int,
    {:register OReg(R12)} pagedb_base:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        addrspace_page != l1pt_page;
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        l1pt_page % 4 == 0;
        addrspace_entry == G_PAGEDB_ENTRY(addrspace_page);
        l1pt_entry == G_PAGEDB_ENTRY(l1pt_page);
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        pageDbClosedRefs(pagedb_in);
        wellFormedPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        pageIsFree(pagedb_in, addrspace_page);
        pageIsFree(pagedb_in, l1pt_page);
    ensures
        AlwaysInvariant(old(this),this);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this),this, set(@r0, @r3, @r4, @r5, @r6, @r7));
        old(specPageDb(smc_initAddrspace_premium(pagedb_in, addrspace_page, l1pt_page))) == pagedb;
        pageDbClosedRefs(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ghost var gaddrspace_entry := initAddrspaceEntry(addrspace_page, l1pt_page);
    ghost var gl1pt_entry := initL1PTEntry(addrspace_page);
    pagedb := pagedb_in[addrspace_page := gaddrspace_entry][l1pt_page := gl1pt_entry];

    /* Update entries in PageDb */
    init_addrspace_pagedb(addrspace_page, l1pt_page, addrspace_entry, l1pt_entry, r6, pagedb_base);
    assert pageDbEntryCorresponds(gaddrspace_entry,
                                  extractPageDbEntry(this.m, addrspace_page));
    assert pageDbEntryCorresponds(gl1pt_entry,
                                  extractPageDbEntry(this.m, l1pt_page));

    /* Update pages in memory */
    init_addrspace_mem(addrspace_page, l1pt_page, r6);

    // It should be okay that this isn't wrapped in a forall ::.
    // The rest of this code is about pagedb anyway.
    reveal_validPageDb();
    reveal_pageDbClosedRefs();

    assert pageDbCorrespondsOnly(this.m, pagedb, addrspace_page);
    assert pageDbCorrespondsOnly(this.m, pagedb, l1pt_page);

    // other pages haven't changed
    assert forall p :: validPageNr(p) && p != addrspace_page && p != l1pt_page
        ==> extractPageDbEntry(old(this).m, p) == extractPageDbEntry(this.m, p)
            && extractPage(old(this).m, p) == extractPage(this.m, p);
    assert forall p :: validPageNr(p) && p != addrspace_page && p != l1pt_page
        ==> pageDbCorrespondsOnly(old(this).m, pagedb, p);

    forall ::
        old(specPageDb(smc_initAddrspace_premium(pagedb_in, addrspace_page, l1pt_page))) == pagedb &&
        pageDbCorresponds(this.m, pagedb)
    {
        reveal_smc_initAddrspace_premium();
    }
}

procedure kev_smc_init_addrspace(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbClosedRefs(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        StackPreserving(old(this),this);
        tuple(pagedb, err)
            == old(smc_initAddrspace_premium(pagedb_in, addrspace_page, l1pt_page));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    reveal_pageDbEntryCorresponds();
    pagedb := pagedb_in;
    reveal_pageDbClosedRefs();

    // check alignment of l1pt page
    AND(r0,l1pt_page,3);
    assert r0 == l1pt_page % 4;

    if (addrspace_page == l1pt_page) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (addrspace_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (l1pt_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (r0 != 0) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else {
        LDRglobaladdr(r12, PageDb());
        assert validPageNr(addrspace_page) && validPageNr(l1pt_page);
        r0 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r4,addrspace_page,r0);
        assert r4 == G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r3, PageDb(), r12, r4);
        assert pageDbEntryCorresponds(pagedb[addrspace_page], extractPageDbEntry(this.m, addrspace_page));
        assert r3 == GlobalWord(this.m, PageDb(), r4) == pageDbEntryTypeVal(pagedb[addrspace_page]);
        if (r3 == sp_op_const(KEV_PAGE_FREE())) {
            assert pageIsFree(pagedb, addrspace_page);
            assert r0 == PAGEDB_ENTRY_SIZE();
            MUL(r5,l1pt_page,r0);
            assert r5 == G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_TYPE();
            LDRglobal(r0, PageDb(), r12, r5);
            assert pageDbEntryCorresponds(pagedb[l1pt_page], extractPageDbEntry(this.m, l1pt_page));
            assert r0 == GlobalWord(this.m, PageDb(), r5) == pageDbEntryTypeVal(pagedb[l1pt_page]);
            if (r0 == sp_op_const(KEV_PAGE_FREE())) {
                assert pageIsFree(pagedb, l1pt_page);
                pagedb := init_addrspace(addrspace_page, l1pt_page, r4, r5, r12, pagedb);
                err := OConst(KEV_ERR_SUCCESS());
            } else {
                err := sp_op_const(KEV_ERR_PAGEINUSE());
            }
        } else {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        }
    }
    forall :: 
        tuple(pagedb, err) == old(smc_initAddrspace_premium(pagedb_in, addrspace_page, l1pt_page))
        && pageDbClosedRefs(pagedb) && pageDbCorresponds(this.m, pagedb)
    {
        reveal_smc_initAddrspace_premium();
        reveal_validPageDb();
    }
}


//=============================================================================
// Init dispatcher
//=============================================================================

procedure kev_smc_init_dispatcher(
    {:register OReg(R1)} disp_page:int,
    {:register OReg(R2)} as_page:int,
    {:register OReg(R3)} entrypoint:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbClosedRefs(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        StackPreserving(old(this),this);
        tuple(pagedb, err)
            == old(smc_initDispatcher_premium(pagedb_in, disp_page, as_page, entrypoint));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    reveal_pageDbClosedRefs();
    reveal_smc_initDispatcher_premium();

    if (as_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_ADDRSPACE());
    } else {
        LDRglobaladdr(r12, PageDb());
        assert validPageNr(as_page);
        r0 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r4,as_page,r0);
        assert r4 == G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r0, PageDb(), r12, r4);

        forall :: r0 == pageDbEntryTypeVal(pagedb[as_page]) {
            reveal_pageDbEntryCorresponds();
        }

        if (r0 != sp_op_const(KEV_PAGE_ADDRSPACE())) {
            err := sp_op_const(KEV_ERR_INVALID_ADDRSPACE());
        } else {
            assert isAddrspace(pagedb, as_page);
            ghost var entry := PageDbEntryTyped(as_page,
                            Dispatcher(entrypoint, false, dispctxt(entrypoint)));
            pagedb := allocate_page(disp_page, as_page,
                                    sp_op_const(KEV_PAGE_DISPATCHER()),
                                    r12, r4, r5, err, pagedb, entry);

            if (err == sp_op_const(KEV_ERR_SUCCESS())) {
                assert pageDbCorrespondsExcluding(this.m, pagedb, disp_page);
                assert pageDbEntryCorresponds(pagedb[disp_page],
                                         extractPageDbEntry(this.m, disp_page));
                ghost var tmpstate := this;

                // update dispatcher page
                page_monvaddr_impl(r4, disp_page, r5);
                r5 := 0;
                STR(r5, r4, sp_op_const(DISPATCHER_ENTERED())); // entered = 0
                STR(r3, r4, sp_op_const(DISPATCHER_ENTRYPOINT())); // entrypoint

                forall :: pageDbCorrespondsOnly(this.m, pagedb, disp_page) {
                    reveal_pageDbDispatcherCorresponds();
                    reveal_pageContentsCorresponds();
                }
                AllButOnePagePreserving(disp_page, tmpstate, this);
                assert pageDbCorresponds(this.m, pagedb);
            } else {
                assert pagedb == pagedb_in;
                assert pageDbCorresponds(this.m, pagedb);
            }
        }
    }
}

#verbatim
function dispctxt(entrypoint:int) : DispatcherContext
{
    DispatcherContext(map[], entrypoint, encode_mode(User))
}
#endverbatim

//=============================================================================
// Init L2 page table
//=============================================================================

procedure fetch_l1pte(
    {:operand} l1pt_va:mem,
    {:operand} l1index:int,
    out {:operand} tmp:int,
    out {:operand} res:int,
    ghost pagedb:PageDb,
    ghost l1pg:int)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@l1pt_va, @l1index, @tmp, @res), 4);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validPageNr(l1pg) && pagedb[l1pg] is PageDbEntryTyped
            && pagedb[l1pg].entry is L1PTable
            && closedRefsL1PTable(pagedb[l1pg].entry);
        l1pt_va == page_monvaddr(l1pg);
        0 <= l1index < NR_L1PTES();
    ensures
        AlwaysInvariant(old(this),this);
        AllMemInvariant(old(this),this);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this),this, set(@tmp, @res));
        res == 0 <==> pagedb[l1pg].entry.l1pt[l1index] == Nothing;
{
    reveal_pageDbL1PTableCorresponds();
    reveal_pageContentsCorresponds();
    tmp := 16;
    MUL(tmp, l1index, tmp);
    LDR(res, l1pt_va, tmp);
    assert res == addrval(this, l1pteoffset(l1pt_va, l1index, 0));
    assert res == mkL1Pte(pagedb[l1pg].entry.l1pt[l1index], 0);
}

procedure install_l1ptes(
    {:operand} l1pt_va:mem,
    inout {:operand} l2_pg:int,
    inout {:operand} l1index:int,
    out {:operand} tmp:int,
    ghost pagedb_in:PageDb,
    ghost as_pg:int,
    ghost l1pg:int) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@l1pt_va, @l2_pg, @l1index, @tmp), 4);
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        validAddrspacePage(pagedb_in, as_pg) && !stoppedAddrspace(pagedb_in[as_pg]);
        l1pg == pagedb_in[as_pg].entry.l1ptnr;
        pagedb_in[l1pg] is PageDbEntryTyped && pagedb_in[l1pg].entry is L1PTable
                && closedRefsL1PTable(pagedb_in[l1pg].entry);
        l1pt_va == page_monvaddr(l1pg);
        validPageNr(l2_pg);
        0 <= l1index < NR_L1PTES();
    ensures
        AlwaysInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
        StackPreserving(old(this),this);
        MemPreservingExcept(old(this),this, l1pt_va + old(l1index) * 16,
                            l1pt_va + (old(l1index) + 1) * 16);
        RegPreservingExcept(old(this),this, set(@l2_pg, @l1index, @tmp));
        pagedb == installL1PTEInPageDb(pagedb_in, l1pg, old(l2_pg), old(l1index));
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;

    ghost var oldpg := extractPage(old(this).m, l1pg);
    forall :: pageDbL1PTableCorresponds(l1pg, pagedb[l1pg].entry, oldpg)
    {
        reveal_pageContentsCorresponds();
    }

    ghost var oldl1pt := pagedb[l1pg].entry;
    ghost var newl1pt := installL1PTE(oldl1pt, l2_pg, l1index);
    assert forall i :: 0 <= i < NR_L1PTES() && i != l1index
        ==> newl1pt.l1pt[i] == oldl1pt.l1pt[i];

    page_paddr_impl(l2_pg,l2_pg,tmp);

    tmp := 16;
    MUL(l1index, l1index, tmp);

    ADD(l2_pg, l2_pg, 1);
    assert l2_pg == mkL1Pte(Just(old(l2_pg)), 0);
    STR(l2_pg, l1pt_va, l1index);

    ADD(l1index, l1index, 4);
    ADD(l2_pg, l2_pg, sp_op_const(ARM_L2PT_BYTES()));
    assert l2_pg == mkL1Pte(Just(old(l2_pg)), 1);
    STR(l2_pg, l1pt_va, l1index);

    ADD(l1index, l1index, 4);
    ADD(l2_pg, l2_pg, sp_op_const(ARM_L2PT_BYTES()));
    assert l2_pg == mkL1Pte(Just(old(l2_pg)), 2);
    STR(l2_pg, l1pt_va, l1index);

    ADD(l1index, l1index, 4);
    ADD(l2_pg, l2_pg, sp_op_const(ARM_L2PT_BYTES()));
    assert l2_pg == mkL1Pte(Just(old(l2_pg)), 3);
    STR(l2_pg, l1pt_va, l1index);

    ghost var pg := extractPage(this.m, l1pg);
    forall :: pageDbL1PTableCorresponds(l1pg, newl1pt, pg)
    {
        assert forall i :: 0 <= i < 4
            ==> pg[l1pteoffset(l1pt_va, old(l1index), i)]
                    == mkL1Pte(Just(old(l2_pg)), i);
        assert forall i, j :: 0 <= i < NR_L1PTES() && 0 <= j < 4 && i != old(l1index)
            ==> (let o := l1pteoffset(l1pt_va, i, j) in pg[o] == oldpg[o]);
        reveal_pageDbL1PTableCorresponds();
    }

    pagedb := installL1PTEInPageDb(pagedb, l1pg, old(l2_pg), old(l1index));

    forall :: pageDbCorrespondsOnly(this.m, pagedb, l1pg)
    {
        assert pageContentsCorresponds(l1pg, pagedb_in[l1pg], oldpg);
        assert pagedb[l1pg] == pagedb_in[l1pg].(entry := newl1pt);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(l1pg, pagedb[l1pg], pg);
        reveal_pageDbEntryCorresponds();
    }

    forall p :| validPageNr(p) && p != l1pg :: pageDbCorrespondsOnly(this.m, pagedb, p)
    {
        AllButOnePagePreserving(l1pg, old(this), this);
        assert pageDbCorrespondsOnly(this.m, pagedb_in, p);
        SameEntriesImpliesPageDbCorresponds(this.m, p, pagedb_in, pagedb);
    }
}

#verbatim

#endverbatim

procedure init_l2ptable_success(
    inout {:operand} l2_pg:int, // trashed
    {:operand} as_pg:int,
    inout {:operand} l1index:int, // trashed
    out {:operand} tmp1:int,
    out {:operand} tmp2:int,
    out {:operand} tmp3:int,
    ghost pagedb_in: PageDb,
    ghost l1pg: int) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@l2_pg, @as_pg, @l1index, @tmp1, @tmp2, @tmp3), 6);
        validPageNr(l2_pg);
        0 <= l1index < NR_L1PTES();
        validPageDb(pagedb_in);
        validAddrspacePage(pagedb_in, as_pg) && !stoppedAddrspace(pagedb_in[as_pg]);
        l1pg == pagedb_in[as_pg].entry.l1ptnr;
        pagedb_in[l1pg] is PageDbEntryTyped && pagedb_in[l1pg].entry is L1PTable
                && closedRefsL1PTable(pagedb_in[l1pg].entry);
        pagedb_in[l2_pg] == PageDbEntryTyped(as_pg, L2PTable(SeqRepeat(NR_L2PTES(), NoMapping)));
        pageDbCorrespondsExcluding(this.m, pagedb_in, l2_pg);
        pageDbEntryCorresponds(pagedb_in[l2_pg], extractPageDbEntry(this.m, l2_pg));
    ensures
        AlwaysInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
        StackPreserving(old(this),this);
        //PagePreservingExcept(old(this),this, set(l1pg, l2_pg));
        RegPreservingExcept(old(this),this, set(@l2_pg, @l1index, @tmp1, @tmp2, @tmp3));
        pagedb == installL1PTEInPageDb(pagedb_in, l1pg, old(l2_pg), old(l1index));
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;

    // update L2 page contents
    page_monvaddr_impl(tmp1, l2_pg, tmp2);
    tmp2 := 0;
    tmp3 := sp_op_const(KEVLAR_PAGE_SIZE());
    memset(tmp1, tmp2, tmp3);

    ghost var pg := extractPage(this.m, l2_pg);
    ghost var newl2pt := L2PTable(SeqRepeat(NR_L2PTES(), NoMapping));
    forall :: pageDbL2PTableCorresponds(l2_pg, newl2pt, pg)
    {
        assert forall m :: addrInPage(m, l2_pg) ==> pg[m] == 0;
        reveal_pageDbL2PTableCorresponds();
    }
    forall :: pageDbCorrespondsOnly(this.m, pagedb, l2_pg) {
        assert forall m :: addrInPage(m, l2_pg) ==> pg[m] == 0;
        reveal_pageContentsCorresponds();
    }
    AllButOnePagePreserving(l2_pg, old(this), this);
    assert pageDbCorresponds(this.m, pagedb);
    ghost var tmpstate := this;

    // update L1 PTE
    page_monvaddr_impl(tmp1, as_pg, tmp2);
    LDR(tmp2, tmp1, sp_op_const(ADDRSPACE_L1PT()));

    forall :: tmp2 == page_monvaddr(pagedb[as_pg].entry.l1ptnr)
    {
        assert AllMemInvariant(tmpstate, this);
        assert pageDbCorrespondsOnly(this.m, pagedb, as_pg);
        assert validAddrspacePage(pagedb, as_pg);
        reveal_pageDbClosedRefs();
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(as_pg, pagedb[as_pg],
                                       extractPage(this.m, as_pg));
        reveal_pageDbAddrspaceCorresponds();
    }

    pagedb := install_l1ptes(tmp2, l2_pg, l1index, tmp3, pagedb, old(as_pg), l1pg);

    AllButOnePagePreserving(l1pg, tmpstate, this);
}

procedure kev_smc_init_l2ptable(
    {:register OReg(R1)} pagenr:int,
    {:register OReg(R2)} as_page:int,
    {:register OReg(R3)} l1index:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbClosedRefs(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        StackPreserving(old(this),this);
        tuple(pagedb, err)
            == old(smc_initL2PTable_premium(pagedb_in, pagenr, as_page, l1index));
        pageDbCorresponds(this.m, pagedb);
{
    ghost var specResult := smc_initL2PTable(pagedb_in, pagenr, as_page, l1index);
    pagedb := pagedb_in;

    if (l1index >= sp_op_const(NR_L1PTES())) {
        err := sp_op_const(KEV_ERR_INVALID_MAPPING());
        assert err == specErr(specResult);
    } else if (as_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_ADDRSPACE());
        assert err == specErr(specResult);
    } else {
        assert validPageNr(as_page);
        LDRglobaladdr(r12, PageDb());
        r4 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r4,as_page,r4);
        assert r4 == G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r4, PageDb(), r12, r4);

        forall :: r4 == pageDbEntryTypeVal(pagedb[as_page]) {
            reveal_pageDbEntryCorresponds();
        }

        if (r4 != sp_op_const(KEV_PAGE_ADDRSPACE())) {
            err := sp_op_const(KEV_ERR_INVALID_ADDRSPACE());
            assert err == specErr(specResult);
        } else {
            forall :: validAddrspacePage(pagedb, as_page) {
                assert isAddrspace(pagedb, as_page);
                reveal_pageDbClosedRefs();
            }

            ghost var l1pg := pagedb[as_page].entry.l1ptnr;

            // check for stopped addrspace
            page_monvaddr_impl(r4, as_page, r5);
            LDR(r5, r4, sp_op_const(ADDRSPACE_STATE()));
            forall :: r5 == pageDbAddrspaceStateVal(pagedb[as_page].entry.state)
            {
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }
            if (r5 != sp_op_const(KEV_ADDRSPACE_INIT())) {
                err := sp_op_const(KEV_ERR_ALREADY_FINAL());
                assert err == specErr(specResult);
            } else {
                // check for L1 index in use
                LDR(r4, r4, sp_op_const(ADDRSPACE_L1PT()));

                forall :: r4 == page_monvaddr(l1pg) {
                    assert pageDbCorrespondsOnly(this.m, pagedb, as_page);
                    assert validAddrspacePage(pagedb, as_page);
                    reveal_pageDbClosedRefs();
                    reveal_pageContentsCorresponds();
                    assert pageContentsCorresponds(as_page, pagedb[as_page],
                                                   extractPage(this.m, as_page));
                    reveal_pageDbAddrspaceCorresponds();
                }

                forall :: pagedb[l1pg] is PageDbEntryTyped
                    && pagedb[l1pg].entry is L1PTable
                    && closedRefsL1PTable(pagedb[l1pg].entry)
                {
                    assert isAddrspace(pagedb, as_page);
                    assert !stoppedAddrspace(pagedb[as_page]);
                    reveal_validPageDb();
                }

                fetch_l1pte(r4, l1index, r5, r6, pagedb, l1pg);
                if (r6 != 0) {
                    assert l1indexInUse(pagedb, as_page, l1index);
                    err := sp_op_const(KEV_ERR_ADDRINUSE());
                    assert err == specErr(specResult);
                } else {
                    ghost var emptyptes := SeqRepeat(NR_L2PTES(), NoMapping);
                    ghost var entry := PageDbEntryTyped(as_page, L2PTable(emptyptes));

                    pagedb := allocate_page(pagenr, as_page,
                                        sp_op_const(KEV_PAGE_L2PTABLE()),
                                        r12, r4, r5, err, pagedb, entry);

                    assert err == specErr(specResult);
                    if (err == sp_op_const(KEV_ERR_SUCCESS())) {
                        r4 := pagenr;
                        r5 := l1index;
                        pagedb := init_l2ptable_success(r4, as_page, r5, r6, r7, r8,
                                                        pagedb, l1pg);
                        assert pagedb == specPageDb(specResult);
                    }
                }
            }
        }
    }

    assert err == specErr(specResult);
    assert err != KEV_ERR_SUCCESS() ==> pagedb == pagedb_in;
    reveal_smc_initL2PTable_premium();
}

//=============================================================================
// Enter / Return
//=============================================================================
procedure smc_enter_err(
    {:register OReg(R0)} pagenr:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    out {:register OReg(R0)} err:int,
    ghost s:SysState)
    returns (ghost s':SysState)
    requires 
        this == s.hw;
        SaneState(this);
        validSysState(s);
    ensures
        this == s'.hw; 
        validSysState(s');
        RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
    ensures
        tuple(s'.d, err) == smc_enter_premium(s.d, pagenr, arg1, arg2, arg3);
{
    reveal_smc_enter_premium();
    if (pagenr >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        assert !validPageNr(pagenr);
        
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
        s' := s.(hw := this);
    } else {
        assert validPageNr(pagenr);

        LDRglobaladdr(r12, PageDb());
        r11 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r10,pagenr,r11);
        assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r9, PageDb(), r12, r10);
        forall :: pageDbEntryCorresponds(s.d[pagenr], extractPageDbEntry(this.m, pagenr))
        {
            reveal_validPageDb();
        }
        forall :: r9 == GlobalWord(s.hw.m, PageDb(), r10) &&
            r9 == pageDbEntryTypeVal(s.d[pagenr])
        {
            reveal_pageDbEntryCorresponds(); reveal_pageContentsCorresponds();
        }
        assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
        if( r9 != sp_op_const(KEV_PAGE_DISPATCHER()) ) {
            assert !(s.d[pagenr] is PageDbEntryTyped && s.d[pagenr].entry is Dispatcher);

            err := sp_op_const(KEV_ERR_INVALID_PAGENO());
            s' := s.(hw := this);
        } else {
            assert s.d[pagenr] is PageDbEntryTyped && s.d[pagenr].entry is Dispatcher;

            r10 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
            assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
            WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE(), r10);
           
            LDRglobal(r8, PageDb(), r12, r10);
            ghost var addrspace := s.d[pagenr].addrspace;
            forall :: r8 == page_monvaddr(addrspace) && WordAligned(r8)
            {
                reveal_pageDbEntryCorresponds(); reveal_pageContentsCorresponds();
                reveal_validPageDb();
            }
            WordAlignedAdd_(r8,ADDRSPACE_STATE(),r8+ADDRSPACE_STATE());
           
            forall :: ValidMem(this.m, addr_mem(this, @r8, sp_op_const(ADDRSPACE_STATE())))
                { reveal_validPageDb(); } 
            LDR(r8, r8, sp_op_const(ADDRSPACE_STATE()));
            forall :: 
            (r8 == KEV_ADDRSPACE_FINAL() ==>
                s.d[addrspace].entry.state == FinalState) &&
            (r8 != KEV_ADDRSPACE_FINAL() ==>
                s.d[addrspace].entry.state != FinalState)
            {
                reveal_validPageDb();
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            // this particular RegPreserving assert saved 30s.
            assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
            if( r8 != sp_op_const(KEV_ADDRSPACE_FINAL()) ) {
                forall :: s.d[addrspace].entry.state != FinalState { reveal_validPageDb(); }
                err := sp_op_const(KEV_ERR_NOT_FINAL());
                s' := s.(hw := this);
            } else {
                forall :: s.d[addrspace].entry.state == FinalState { reveal_validPageDb(); }
                
                assert this.m == old(this.m);
                assert SaneState(this);
                page_monvaddr_impl(r9,pagenr,r10);
                assert r9 == page_monvaddr(pagenr);
                forall :: addrval(this, page_monvaddr(pagenr) + 
                    DISPATCHER_ENTERED()) == to_i(s.d[pagenr].entry.entered)
                {
                    reveal_pageContentsCorresponds();
                    reveal_pageDbDispatcherCorresponds();
                }
                LDR(r9,r9,sp_op_const(DISPATCHER_ENTERED()));
                
                assert r9 == 1 ==> s.d[pagenr].entry.entered;
                assert r9 != 1 ==> !(s.d[pagenr].entry.entered);
                assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
                if( r9 == 1 ) {
                    err := sp_op_const(KEV_ERR_ALREADY_ENTERED());
                    s' := s.(hw := this);
                } else {
                    err := sp_op_const(KEV_ERR_SUCCESS());
                    s' := s.(hw := this);
                }
            }
        }
    }
}

procedure exceptionProc(ghost s:SysState)
    returns (ghost s':SysState)
    requires
        this == s.hw;
        validSysState(s);
        //userEnteredState(s);
    ensures 
        this == s'.hw;
        validSysState(s');
        exception(s, s');
{
    assume false;
}

procedure kev_smc_enter(
    {:register OReg(R0)} pagenr:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost s:SysState)
    returns (ghost s':SysState)
    requires 
        this == s.hw; 
        validSysState(s);
        SaneState(s.hw);
        isUInt32(arg1) && isUInt32(arg2) && isUInt32(arg3);
    ensures
        this == s'.hw;
        //TODO SaneState(s'.hw);
        validSysState(s');
        tuple(s'.d, err) == smc_enter_premium(s.d, pagenr, arg1, arg2, arg3);
        validEnter(s,s',pagenr,arg1,arg2,arg3);
{
    //reveal_validEnter();
    reveal_smc_enter_premium();
    r5 := pagenr;
    ghost var s_err;
    s_err := smc_enter_err(@r0,@r1,@r2,@r3,@r0,s.(hw := this));
    if(err != sp_op_const(KEV_ERR_SUCCESS()) ) {
        val := sp_op_const(0);
        s' := s_err.(hw := this);
        assert validSysState(s');
        assert tuple(s'.d, err) == smc_enter(s.d, pagenr, arg1, arg2, arg3);
    } else {
        assume false; // TODO
        ///  // ghost var s_test:SysState;
        ///  // ghost var err_test :int;
        ///  ghost var r:SysState; 
        ///  // assume validPageDb(s_test.d);
        ///  // assume validSysState(s_test);
        ///  assert specErr(smc_enter(s.d, pagenr, arg1, arg2, arg3)) == KEV_ERR_SUCCESS();
        ///  assume r.hw == this;
        ///  assume validEntryTransitionEnter(s,r,pagenr,arg1,arg2,arg3);

        ///  // ghost var r := userspaceExecutionF(q); 
        ///  
        ///  s' := exceptionProc(r);
        ///  // assume this == s';
        ///  assert validEntryTransitionEnter(s,r,pagenr,arg1,arg2,arg3) && exception(r, s');

        ///  // assert (validEntryTransitionEnter(s_test,q,pagenr,arg1,arg2,arg3)
        ///  //     && userspaceExecution(q, r) && exception(r, s'));

        ///  assert SaneMem(s'.hw.m);

        ///  //assert SaneState(s'.hw); 

        ///  // assert false;

        ///  // val := sp_op_const(0);
        ///  // s' := s'.(hw := this);
    }
    
}


//=============================================================================
// Top-level SMC handler
//=============================================================================

#verbatim
lemma SameMemAndGlobalsImpliesSamePageDb(s:state, s':state, pagedb:PageDb)
    requires SaneState(s) && SaneState(s')
    requires AlwaysInvariant(s,s')
    requires pageDbClosedRefs(pagedb)
    requires pageDbCorresponds(s.m, pagedb)
    requires NonStackMemPreserving(s,s')
    requires GlobalsInvariant(s,s')
    ensures pageDbCorresponds(s'.m, pagedb)
{
    assert GlobalFullContents(s.m, PageDb()) == GlobalFullContents(s'.m, PageDb());
    assert forall p :: validPageNr(p) ==> extractPage(s.m, p) == extractPage(s'.m, p);
}
#endverbatim

procedure smc_handler(
    {:register OReg(R0)} callno:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    {:register OReg(R4)} arg4:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} retval:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this,120);
    requires
        validPageDb(pagedb_in);
        pageDbClosedRefs(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        NonvolatileRegPreserving(old(this),this);
        //tuple(pagedb, err, retval) == old(smchandler_premium(pagedb_in, callno, arg1, arg2, arg3, arg4));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ghost var stack_bytes := 120;
    pagedb := pagedb_in;
    retval := 0;

    fcall_prologue(stack_bytes);
    SameMemAndGlobalsImpliesSamePageDb(old(this), this, pagedb);

    if(callno == sp_op_const(KEV_SMC_QUERY())) {
        err := sp_op_const(KEV_MAGIC());
    } else if(callno == sp_op_const(KEV_SMC_GETPHYSPAGES())) {
        retval := sp_op_const(KEVLAR_SECURE_NPAGES());
        err := sp_op_const(KEV_ERR_SUCCESS());
    } else if(callno == sp_op_const(KEV_SMC_INIT_ADDRSPACE())) {
        pagedb := kev_smc_init_addrspace(arg1, arg2, err, pagedb);
    } else if(callno == sp_op_const(KEV_SMC_INIT_DISPATCHER())) {
        pagedb := kev_smc_init_dispatcher(arg1, arg2, arg3, err, pagedb);
    } else if(callno == sp_op_const(KEV_SMC_INIT_L2PTABLE())) {
        pagedb := kev_smc_init_l2ptable(arg1, arg2, arg3, err, pagedb);
    }

    ghost var prePopThis := this;
    fcall_epilogue(stack_bytes-40);
    SameMemAndGlobalsImpliesSamePageDb(prePopThis, this, pagedb);

    // zero other volatiles to prevent information leakage
    r2 := 0;
    r3 := 0;

    // TODO: return path (movs pc, lr etc.)
}

#verbatim
method Main()
{
    printHeader();
    var n := printFunction("smc_handler", sp_code_smc_handler(), 0);
    printBss(KevGlobalDecls());
    printFooter();
}
#endverbatim
