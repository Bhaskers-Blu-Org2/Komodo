#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

#verbatim
predicate page_is_valid(page:int)
{
    0 <= page < KEVLAR_SECURE_NPAGES()
}

// lemma vmap_lemma(phys:int)
//     requires isUInt32(phys)
//     ensures  (KEVLAR_DIRECTMAP_VBASE() + G_SECURE_PHYSBASE() +
//         KEVLAR_PAGE_SIZE() * phys) % 4 == 0;
// {
//    assert (KEVLAR_DIRECTMAP_VBASE() % 4) == 0;
//    assert (G_SECURE_PHYSBASE() % 4) == 0;
//    assert (KEVLAR_PAGE_SIZE() % 4) == 0;
//    assert ( (KEVLAR_PAGE_SIZE() * phys) % 4) == 0;
// }

predicate {:opaque} vmap_lemma(phys:int)
    requires isUInt32(phys)
    ensures vmap_lemma(phys) == true;
    ensures  (KEVLAR_DIRECTMAP_VBASE() + G_SECURE_PHYSBASE() +
        KEVLAR_PAGE_SIZE() * phys) % 4 == 0;
{
   assert (KEVLAR_DIRECTMAP_VBASE() % 4) == 0;
   assert (G_SECURE_PHYSBASE() % 4) == 0;
   assert (KEVLAR_PAGE_SIZE() % 4) == 0;
   assert ( (KEVLAR_PAGE_SIZE() * phys) % 4) == 0;
   true
}

function vmap(phys:int):int
    requires isUInt32(phys);
    requires page_is_valid(phys);
    ensures (vmap(phys) % 4) == 0
{
   // I want this to always be in scope
   assert vmap_lemma(phys);

   KEVLAR_DIRECTMAP_VBASE() + G_SECURE_PHYSBASE() +
        KEVLAR_PAGE_SIZE() * phys
}

predicate ValidAddrspace(s:state,base:int)
{
    ValidMem(s,Address(ADDRSPACE_L1PT(base))) &&
    ValidMem(s,Address(ADDRSPACE_L1PT_PHYS(base))) &&
    ValidMem(s,Address(ADDRSPACE_REF(base))) &&
    ValidMem(s,Address(ADDRSPACE_STATE(base)))
}

#endverbatim

procedure phys2monvaddr({:register op_r(1)} phys:int, out {:register op_r(0)} virt:int, ghost stack_bytes:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        stack_bytes >= 40;
        can_fcall_n(this,stack_bytes);
    requires
        page_is_valid(phys);
    ensures
        virt == KEVLAR_DIRECTMAP_VBASE() + G_SECURE_PHYSBASE() +
            KEVLAR_PAGE_SIZE() * phys;
        WordAligned(virt);
        MemValidityPreserving(old(this),this);
        RegPreserving(old(this),this);
        StackValuePreserving(old(this),this,stack_bytes);
        NonStackValuePreserving(old(this),this);
{
    fcall_prologue(stack_bytes);
    r4 := sp_op_const(KEVLAR_PAGE_SIZE());
    MUL(virt,phys,r4);
    virt += sp_op_const(G_SECURE_PHYSBASE());
    virt += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
    fcall_epilogue(stack_bytes-40);
}

//This is not quite the same as std::memset
procedure memset({:register op_r(0)} lower:int, {:register op_r(1)} upper:int,
    {:register op_r(2)} val:int, ghost stack_bytes:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemRange(this,lower,upper);
        WordAligned(lower);
        WordAligned(upper);
        stack_bytes >= 40;
        can_fcall_n(this,stack_bytes);
    requires
        lower < upper;
        lower >= STACK_UPPER() || upper < STACK_LOWER();
    ensures
        MemValidityPreserving(old(this),this);
        GlobalValuePreserving(old(this),this);
        forall i:int :: (lower <= i < upper) && WordAligned(i) ==>
            addrval(this,i) == val;
        forall i:int :: !(lower <= i < upper) && WordAligned(i) &&
            !(STACK_LOWER() <= i < STACK_UPPER()) &&
            ValidMem(old(this),Address(i)) ==>
                addrval(this,i) == addrval(old(this),i);
        RegPreserving(old(this),this);
        StackValuePreserving(old(this),this,stack_bytes);
        r0 == old(r0);
        r1 == old(r1);
        r2 == old(r2);

{
    fcall_prologue(stack_bytes);

    ghost var loop_old_sp := sp;
    ghost var pre_loop_s := this;

    assert upper == old(upper);
    assert upper == r1;

    for (r9 := lower; r9 < upper; r9+=4)
        invariant
            ValidState(this);
            ValidStack(this);
            sp == loop_old_sp;
            MemValidityPreserving(old(this),pre_loop_s);
            MemValidityPreserving(pre_loop_s,this);
            GlobalValuePreserving(old(this),pre_loop_s);
            GlobalValuePreserving(pre_loop_s,this);
            ValidMemRange(old(this),lower,upper);
            StackValuePreserving(pre_loop_s,this,stack_bytes-40);
            can_fcall_n(this,stack_bytes-40);
         
            WordAligned(r9);
               
            r0 == old(lower);
            r1 == old(upper);
            r2 == old(val);
            lower < upper;
            lower <= r9 <= upper;
            lower >= STACK_UPPER() || upper < STACK_LOWER();
            
            forall i:int :: (lower <= i < r9) && WordAligned(i) ==>
                addrval(this,i) == val;
            forall i:int :: !(lower <= i < r9 ) && WordAligned(i) &&
                !(STACK_LOWER() <= i < STACK_UPPER()) &&
                ValidMem(pre_loop_s,Address(i)) ==>
                    addrval(this,i) == addrval(pre_loop_s,i);

        decreases
            upper - r9;
    {
        STR(r2, r9, 0);
    }
            
    fcall_epilogue(stack_bytes-40);
}

procedure kev_smc_init_addrspace_success(
    {:register op_r(0)} addrspace_page:int,
    {:register op_r(1)} l1pt_page:int,
    out {:register op_r(0)} err:int,
    ghost stack_bytes:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        stack_bytes >= 80 ;
        can_fcall_n(this,stack_bytes);
    requires
        MyGlobalDecls() == TheGlobalDecls();
        addrspace_page != l1pt_page;
        page_is_valid(addrspace_page);
        page_is_valid(l1pt_page);
        WordAligned(l1pt_page);
        ValidAddrspace(this, vmap(addrspace_page));
        ValidMemRange(this, vmap(l1pt_page), vmap(l1pt_page) + KEVLAR_PAGE_SIZE());
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_FREE();
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_FREE();
    ensures
        MemValidityPreserving(old(this),this);
        sp == old(sp);
        StackValuePreserving(old(this),this,stack_bytes);

        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_ADDRSPACE();
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                             + PAGEDB_ENTRY_ADDRSPACE()) == vmap(addrspace_page);
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_L1PTABLE();
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                             + PAGEDB_ENTRY_ADDRSPACE()) == vmap(addrspace_page);
        addrval(this, ADDRSPACE_L1PT(vmap(addrspace_page))) == vmap(l1pt_page);
        addrval(this, ADDRSPACE_L1PT_PHYS(vmap(addrspace_page))) == l1pt_page; 
        addrval(this, ADDRSPACE_REF(vmap(addrspace_page))) == 1;
        addrval(this, ADDRSPACE_STATE(vmap(addrspace_page))) == KEV_ADDRSPACE_INIT();
        forall i:int :: (vmap(l1pt_page) <= i < vmap(l1pt_page) + KEVLAR_PAGE_SIZE()) &&
            WordAligned(i) ==> addrval(this, i) == 0;
{
    fcall_prologue(stack_bytes);
    assert StackValuePreserving(old(this), this, stack_bytes);

    LDRglobaladdr(r11, PageDb());

    r5 := addrspace_page;
    r6 := l1pt_page;

    phys2monvaddr(r1,r0,stack_bytes-40);
    r9 := r0;
    assert r9 == vmap(l1pt_page);

    r1 := r5;
    phys2monvaddr(r1,r0,stack_bytes-40);
    r10 := r0;
    assert r10 == vmap(addrspace_page);

    r0 := r5;
    r1 := r6;

    r4 := sp_op_const(PAGEDB_ENTRY_SIZE());
    MUL(r7,r0,r4);
    assert r7 == G_PAGEDB_ENTRY(addrspace_page);

    //r4 := sp_op_const(PAGEDB_ENTRY_SIZE());
    MUL(r8,r1,r4);
    assert r8 == G_PAGEDB_ENTRY(l1pt_page);

    r4 := sp_op_const(KEV_PAGE_ADDRSPACE());
    STRglobal(r4, PageDb(), r11, r7);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                          + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_ADDRSPACE();
    r7 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    STRglobal(r10, PageDb(), r11, r7);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                          + PAGEDB_ENTRY_ADDRSPACE()) == vmap(addrspace_page);

    r4 := sp_op_const(KEV_PAGE_L1PTABLE());
    STRglobal(r4, PageDb(), r11, r8);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_L1PTABLE();
    r8 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    STRglobal(r10, PageDb(), r11, r8);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_ADDRSPACE()) == vmap(addrspace_page);

    STR(r9,r10,0);
    assert addrval(this,ADDRSPACE_L1PT(vmap(addrspace_page))) == vmap(l1pt_page);

    STR(r1,r10,4);
    assert addrval(this,ADDRSPACE_L1PT_PHYS(vmap(addrspace_page))) == l1pt_page;

    r4 := 1;
    STR(r4,r10,8);
    assert addrval(this,ADDRSPACE_REF(vmap(addrspace_page))) == 1;
   
    r4 := sp_op_const(KEV_ADDRSPACE_INIT());
    STR(r4,r10,12);
    assert addrval(this,ADDRSPACE_STATE(vmap(addrspace_page))) == KEV_ADDRSPACE_INIT();
  
    r0 := r9; // vmap(l1pt_page)
    ADD(r1, r9, sp_op_const(KEVLAR_PAGE_SIZE()));
    r2 := 0;
    assert ValidState(this);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_ADDRSPACE()) == vmap(addrspace_page);
    memset(r0,r1,r2,stack_bytes-40);
   
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_ADDRSPACE()) == vmap(addrspace_page);
   
    fcall_epilogue(stack_bytes-40);
}

procedure kev_smc_init_addrspace(
    {:register op_r(0)} addrspace_page:int,
    {:register op_r(1)} l1pt_page:int,
    out {:register op_r(3)} err:int,
    ghost stack_bytes:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        stack_bytes >= 120;
        can_fcall_n(this,stack_bytes);
    requires
        MyGlobalDecls() == TheGlobalDecls();
        isUInt32(addrspace_page);
        isUInt32(l1pt_page);
        page_is_valid(addrspace_page) ==>
            ValidAddrspace(this,vmap(addrspace_page));
        page_is_valid(l1pt_page) ==>
            ValidMemRange(this,vmap(l1pt_page),vmap(l1pt_page)+KEVLAR_PAGE_SIZE());
    ensures
        //RegPreserving(old(this),this);
        MemValidityPreserving(old(this),this); 
        sp == old(sp);
        StackValuePreserving(old(this),this,stack_bytes);
        addrspace_page == l1pt_page ==>
            err == KEV_ERR_INVALID_PAGENO();
        !page_is_valid(addrspace_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
        !page_is_valid(l1pt_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
        !WordAligned(l1pt_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
            /* TODO:
        page_is_valid(addrspace_page) && page_is_valid(l1pt_page) && WordAligned(l1pt_page) &&
            (addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page))) !=
                KEV_PAGE_FREE()) ==> err == KEV_ERR_PAGEINUSE();
        page_is_valid(addrspace_page) && page_is_valid(l1pt_page) && WordAligned(l1pt_page) &&
            (addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page))) !=
                KEV_PAGE_FREE()) ==> err == KEV_ERR_PAGEINUSE();
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page))) ==
                KEV_PAGE_ADDRSPACE());
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(addrspace_page))) ==
                vmap(addrspace_page));
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page))) ==
                KEV_PAGE_L1PTABLE());
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(l1pt_page))) ==
                vmap(addrspace_page));
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_L1PT(vmap(addrspace_page))) ==
                vmap(l1pt_page)); 
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_L1PT_PHYS(vmap(addrspace_page))) ==
                l1pt_page); 
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_REF(vmap(addrspace_page))) == 1);
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_STATE(vmap(addrspace_page))) == KEV_ADDRSPACE_INIT()); */
{
    fcall_prologue(stack_bytes);

    // check alignment of l1pt page
    AND(r4,l1pt_page,3);
    assert r4 == l1pt_page % 4;

    if (addrspace_page == l1pt_page) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (addrspace_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (l1pt_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (r4 != 0) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else {
        r4 := sp_op_const(PAGEDB_ENTRY_SIZE());
        LDRglobaladdr(r6, PageDb());
        MUL(r5,r0,r4); // addrspace_page * pagedb_entry_size
        assert r5 == addrspace_page * PAGEDB_ENTRY_SIZE();
        assert r5 == G_PAGEDB_ENTRY(addrspace_page);
        assert r5 == G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r5, PageDb(), r6, r5);
        assert r5 == GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE());

        MUL(r7,r1,r4); // l1pt_page * pagedb_entry_size
        LDRglobal(r7, PageDb(), r6, r7);
        assert r7 == GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_TYPE());

        if( r5 != sp_op_const(KEV_PAGE_FREE()) ) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else if( r7 != sp_op_const(KEV_PAGE_FREE()) ) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else {
            kev_smc_init_addrspace_success(r0,r1,err,stack_bytes-40);
            
            err := OConst(KEV_ERR_SUCCESS());
        }
    }
    assert ValidState(this);
    fcall_epilogue(stack_bytes-40);
}

procedure smc_handler(
    {:register op_r(4)} callno:int,
    {:register op_r(0)} arg1:int,
    {:register op_r(1)} arg2:int,
    {:register op_r(2)} arg3:int,
    {:register op_r(3)} arg4:int,
    out {:register op_r(11)} err:int,
    out {:register op_r(12)} retval:int,
    ghost stack_bytes:int)
    requires/ensures
        MyGlobalDecls() == TheGlobalDecls();
        ValidState(this);
        ValidStack(this);
        stack_bytes >= 120;
        can_fcall_n(this,stack_bytes);
        // TODO: mode_of_state(this) == Monitor;
    requires
        callno == KEV_SMC_INIT_ADDRSPACE() ==> (
            ( page_is_valid(arg1) ==> ValidAddrspace(this,vmap(arg1)) ) && 
            ( page_is_valid(arg2) ==>
                ValidMemRange(this,vmap(arg2),vmap(arg2)+KEVLAR_PAGE_SIZE()) ));
{
    
    retval := 0;
    
    if(callno == sp_op_const(KEV_SMC_QUERY())) {
        err := sp_op_const(KEV_MAGIC());
    } else if(callno == sp_op_const(KEV_SMC_GETPHYSPAGES())) {
        retval := sp_op_const(KEVLAR_SECURE_NPAGES());
        err := sp_op_const(KEV_ERR_SUCCESS());
    } else if(callno == sp_op_const(KEV_SMC_INIT_ADDRSPACE())) {
        kev_smc_init_addrspace(arg1, arg2, r3, stack_bytes);
        err := r3;
    }

}

#verbatim
function method PageDb(): operand { op_sym("g_pagedb") }

function method MyGlobalDecls(): globaldecls
    ensures ValidGlobalDecls(MyGlobalDecls());
{
    GlobalDecls(map[PageDb() := G_PAGEDB_SIZE()])
}

method Main()
{
    printHeader();
    var n := printFunction("smc_handler", sp_code_smc_handler(), 0);
    printBss(MyGlobalDecls());
    printFooter();
}
#endverbatim
