#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

#verbatim
predicate page_is_valid(page:int)
{
    0 <= page < KEVLAR_SECURE_NPAGES()
}

lemma valid_pagenr_ensures_valid_mem(s:state, pagenr: int)
      requires SaneState(s)
      requires page_is_valid(pagenr)
      ensures ValidMemRange(s, page_monvaddr(s, pagenr), page_monvaddr(s, pagenr) + KEVLAR_PAGE_SIZE())
{}

function page_monvaddr(s:state,pagenr:int):int
    requires page_is_valid(pagenr)
    requires SaneGlobals(s)
    ensures WordAligned(page_monvaddr(s,pagenr))
{
    GlobalContents(s, SecurePhysBase(), 0)
        + KEVLAR_DIRECTMAP_VBASE() + KEVLAR_PAGE_SIZE() * pagenr
}

#endverbatim

procedure phys2monvaddr({:operand} phys:int, out {:operand} virt:int, out {:operand} tmp:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(this, @phys);
        ValidRegOperand(this, @virt);
        ValidRegOperand(this, @tmp);
        // NB: @phys == @virt is supported
        @phys != @tmp;
        @virt != @tmp;
        @virt != op_sp();
        @tmp != op_sp();
        page_is_valid(phys);
    ensures
        GlobalValuePreserving(old(this),this);
        RegPreservingExcept(old(this), this, [@virt, @tmp]);
        MemPreserving(old(this),this);
        WordAligned(virt);
        virt == page_monvaddr(old(this), old(phys));
{
    tmp := sp_op_const(KEVLAR_PAGE_SIZE());
    MUL(virt,phys,tmp);
    // LSL(virt, phys, sp_op_const(KEVLAR_PAGE_SHIFT()));
    assert virt == old(phys) * KEVLAR_PAGE_SIZE();

    LDRglobaladdr(tmp, SecurePhysBase());
    LDRglobal(tmp, SecurePhysBase(), tmp, 0);
    assert WordAligned(tmp);
    virt += tmp;
    assert WordAligned(virt);
    virt += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
}

procedure memset(inout {:operand} base:int, {:operand} val:int, inout {:operand} size:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(this, @base);
        ValidRegOperand(this, @size);
        ValidRegOperand(this, @val);
        @base != @size;
        @base != @val;
        @size != @val;
        @base != @sp;
        @val != @sp;
        @size != @sp;
        WordAligned(base);
        WordAligned(size);
        isUInt32(val);
        isUInt32(base + size);
        ValidMemRange(this, base, base + size);
        base >= StackBase() || base + size <= StackLimit();
    ensures
        // XXX: I shouldn't have to say this! :(
        MemValidityPreserving(old(this), this);
        GlobalValuePreserving(old(this),this);
        forall i:int :: (old(base) <= i < old(base + size)) && WordAligned(i) ==>
            addrval(this,i) == old(val);
        forall i:int :: !(old(base) <= i < old(base + size)) && WordAligned(i) &&
            !(StackLimit() <= i < StackBase()) &&
            ValidMem(old(this),Address(i)) ==>
                addrval(this,i) == addrval(old(this),i);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this), this, [@base,@size]);
{
    ghost var lower := base;
    ghost var limit := base + size;

    // beyond this point, "base" is where we're up to, and "size" is the limit
    size += base;

    for (; base < size; base += 4)
        invariant
            ValidState(this);
            ValidStack(this);
            sp == old(sp);
            size == limit;
            GlobalValuePreserving(old(this),this);
            ValidMemRange(old(this),lower,limit);
            MemValidityPreserving(old(this), this);
            StackPreserving(old(this),this);
            RegPreservingExcept(old(this), this, [@base,@size]);
            WordAligned(base);
            lower <= base <= limit;
            lower >= StackBase() || limit <= StackLimit();
            forall i:int :: (lower <= i < base) && WordAligned(i) ==>
                addrval(this,i) == old(val);
            forall i:int :: !(lower <= i < base) && WordAligned(i) &&
                ValidMem(old(this),Address(i)) ==>
                    addrval(this,i) == addrval(old(this),i);
        decreases
            size - base;
    {
        STR(val, base, 0);
    }
}

procedure kev_smc_init_addrspace_success(
    {:register op_r(1)} addrspace_page:int,
    {:register op_r(2)} l1pt_page:int)
    requires/ensures
        SaneState(this);
    requires
        addrspace_page != l1pt_page;
        page_is_valid(addrspace_page);
        page_is_valid(l1pt_page);
        WordAligned(l1pt_page);
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_FREE();
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_FREE();
    ensures
        StackPreserving(old(this),this);

        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_ADDRSPACE();
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                             + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(this, addrspace_page);
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_L1PTABLE();
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                             + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(this, addrspace_page);
        addrval(this, ADDRSPACE_L1PT(page_monvaddr(this, addrspace_page))) == page_monvaddr(this, l1pt_page);
        addrval(this, ADDRSPACE_L1PT_PHYS(page_monvaddr(this, addrspace_page))) == l1pt_page; 
        addrval(this, ADDRSPACE_REF(page_monvaddr(this, addrspace_page))) == 1;
        addrval(this, ADDRSPACE_STATE(page_monvaddr(this, addrspace_page))) == KEV_ADDRSPACE_INIT();
        forall i:int :: (page_monvaddr(this, l1pt_page) <= i < page_monvaddr(this, l1pt_page) + KEVLAR_PAGE_SIZE()) &&
            WordAligned(i) ==> addrval(this, i) == 0;
{
    LDRglobaladdr(r11, PageDb());

    phys2monvaddr(addrspace_page,r9,r0);
    phys2monvaddr(l1pt_page,r10,r0);

    r4 := sp_op_const(PAGEDB_ENTRY_SIZE());
    MUL(r7,addrspace_page,r4);
    assert r7 == G_PAGEDB_ENTRY(addrspace_page);

    //r4 := sp_op_const(PAGEDB_ENTRY_SIZE());
    MUL(r8,l1pt_page,r4);
    assert r8 == G_PAGEDB_ENTRY(l1pt_page);

    r4 := sp_op_const(KEV_PAGE_ADDRSPACE());
    STRglobal(r4, PageDb(), r11, r7);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                          + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_ADDRSPACE();
    r7 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    STRglobal(r9, PageDb(), r11, r7);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                          + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(this, addrspace_page);

    r4 := sp_op_const(KEV_PAGE_L1PTABLE());
    STRglobal(r4, PageDb(), r11, r8);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_L1PTABLE();
    r8 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    STRglobal(r9, PageDb(), r11, r8);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(this, addrspace_page);

    STR(r10,r9,0);
    assert addrval(this,ADDRSPACE_L1PT(page_monvaddr(this, addrspace_page))) == page_monvaddr(this, l1pt_page);

    STR(l1pt_page,r9,4);
    assert addrval(this,ADDRSPACE_L1PT_PHYS(page_monvaddr(this, addrspace_page))) == l1pt_page;

    r4 := 1;
    STR(r4,r9,8);
    assert addrval(this,ADDRSPACE_REF(page_monvaddr(this, addrspace_page))) == 1;
   
    r4 := sp_op_const(KEV_ADDRSPACE_INIT());
    STR(r4,r9,12);
    assert addrval(this,ADDRSPACE_STATE(page_monvaddr(this, addrspace_page))) == KEV_ADDRSPACE_INIT();
  
    r1 := sp_op_const(KEVLAR_PAGE_SIZE());
    r0 := 0;
    memset(r10,r0,r1); //page_monvaddr(this, l1pt_page)
}

procedure kev_smc_init_addrspace(
    {:register op_r(1)} addrspace_page:int,
    {:register op_r(2)} l1pt_page:int,
    out {:register op_r(0)} err:int)
    requires/ensures
        SaneState(this);
    ensures
        StackPreserving(old(this),this);
        addrspace_page == l1pt_page ==>
            err == KEV_ERR_INVALID_PAGENO();
        !page_is_valid(addrspace_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
        !page_is_valid(l1pt_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
        !WordAligned(l1pt_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
{
    // check alignment of l1pt page
    AND(r4,l1pt_page,3);
    assert r4 == l1pt_page % 4;

    if (addrspace_page == l1pt_page) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (addrspace_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (l1pt_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (r4 != 0) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else {
        r4 := sp_op_const(PAGEDB_ENTRY_SIZE());
        LDRglobaladdr(r6, PageDb());
        MUL(r5,addrspace_page,r4); // addrspace_page * pagedb_entry_size
        LDRglobal(r5, PageDb(), r6, r5);
        assert r5 == GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE());

        MUL(r7,l1pt_page,r4); // l1pt_page * pagedb_entry_size
        LDRglobal(r7, PageDb(), r6, r7);
        assert r7 == GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_TYPE());

        if( r5 != sp_op_const(KEV_PAGE_FREE()) ) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else if( r7 != sp_op_const(KEV_PAGE_FREE()) ) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else {
            kev_smc_init_addrspace_success(r1,r2);
            
            err := OConst(KEV_ERR_SUCCESS());
        }
    }
}

procedure smc_handler(
    {:register op_r(0)} callno:int,
    {:register op_r(1)} arg1:int,
    {:register op_r(2)} arg2:int,
    {:register op_r(3)} arg3:int,
    {:register op_r(4)} arg4:int,
    out {:register op_r(0)} err:int,
    out {:register op_r(1)} retval:int)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this,120);
    ensures
        NonvolatileRegPreserving(old(this),this);
{
    ghost var stack_bytes := 120;

    fcall_prologue(stack_bytes);

    retval := 0;

    if(callno == sp_op_const(KEV_SMC_QUERY())) {
        err := sp_op_const(KEV_MAGIC());
    } else if(callno == sp_op_const(KEV_SMC_GETPHYSPAGES())) {
        retval := sp_op_const(KEVLAR_SECURE_NPAGES());
        err := sp_op_const(KEV_ERR_SUCCESS());
    } else if(callno == sp_op_const(KEV_SMC_INIT_ADDRSPACE())) {
        kev_smc_init_addrspace(arg1, arg2, err);
    }

    // remind the verifier to think about our invariant...
    assert SaneState(this);

    fcall_epilogue(stack_bytes-40);

    // zero other volatiles to prevent information leakage
    r2 := 0;
    r3 := 0;

    // TODO: return path (movs pc, lr etc.)
}

#verbatim
function method PageDb(): operand { op_sym("g_pagedb") }
function method SecurePhysBase(): operand { op_sym("g_secure_physbase") }

function method MyGlobalDecls(): globaldecls
    ensures ValidGlobalDecls(MyGlobalDecls());
{
    GlobalDecls(map[SecurePhysBase() := 4, //BytesPerWord()
                    PageDb() := G_PAGEDB_SIZE()])
}

predicate SaneGlobals(s:state)
{
    MyGlobalDecls() == TheGlobalDecls()
        && ValidGlobalState(s)
        && WordAligned(GlobalContents(s, SecurePhysBase(), 0))
        && GlobalContents(s, SecurePhysBase(), 0)
            <= KEVLAR_PHYSMEM_LIMIT() - KEVLAR_SECURE_RESERVE()
        // XXX: workaround so dafny sees that these are distinct
        && SecurePhysBase() != PageDb()
}

predicate SaneMemRanges(s:state)
{
    ValidState(s) && SaneGlobals(s)
    // our phys mapping must be valid to the top of the secure region
    && ValidMemRange(s, KEVLAR_DIRECTMAP_VBASE(),
        (KEVLAR_DIRECTMAP_VBASE() + GlobalContents(s, SecurePhysBase(), 0)
            + KEVLAR_SECURE_RESERVE()))
    // the stack must be mapped
    && ValidMemRange(s, StackLimit(), StackBase())
}

predicate SaneState(s:state)
{
    ValidState(s) && ValidStack(s) && SaneGlobals(s) && SaneMemRanges(s)
}

method Main()
{
    printHeader();
    var n := printFunction("smc_handler", sp_code_smc_handler(), 0);
    printBss(MyGlobalDecls());
    printFooter();
}
#endverbatim
