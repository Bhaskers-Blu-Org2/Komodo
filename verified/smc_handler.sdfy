#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

// loads the pagedb_entry address for pageno into entry
procedure pagedb_entry(
    {:register op_r(0)} pageno:int,
    out {:register op_r(1)} entry:int)
    requires/ensures
        ValidState(this);
        0 <= r0 < 256;
        //can_fcall(this);
        // ValidMem(this, Address(G_PAGEDB_ENTRY(pageno)));
        
        //can pop one allowing fcall_epilogue
        ValidMemRange(this, sp, sp+40);
        MemRangeIs32(this, sp, sp+40); 
    ensures
        entry == G_PAGEDB_ENTRY(pageno);
{
    //fcall_prologue(1);
    entry := G_PAGEDB();

    for (r9:= 0; r9 < r0; r9++)
      invariant
        ValidState(this);
        // isUInt32(entry);
        0 <= r0 < 256;
        0 <= r9 <= r0;
        r0 == old(r0);
        entry == G_PAGEDB_ENTRY(r9);
        // Allows store.
        // ValidMem(this, Address(G_PAGEDB_ENTRY(r0)));

        // Allows fcall_epilogue;
        ValidMemRange(this, sp, sp+40);
        MemRangeIs32(this, sp, sp+40); 
      decreases
        r0 - r9;
    {
        ADD(entry, entry, PAGEDB_ENTRY_SIZE());
    }
    
    // STR(entry, entry, 0);
    // fcall_epilogue(0); 
}

procedure kev_smc_init_addrspace(
    {:register op_r(0)} addrspace_page:int,
    {:register op_r(1)} l1pt_page:int,
    out {:register op_r(11)} err:int)
    requires/ensures
        ValidState(this);
        can_fcall_n(this,3);
{
    err := 0;

    r4 := KEVLAR_SECURE_NPAGES();
    // r5 := PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page));  //addr of type
    // LDR(r5, r5, 0); // type
    // r6 := PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page));  //addr of type
    // LDR(r6, r6, 0); // type


    if( addrspace_page >= r4 ) {
        err := KEV_ERR_INVALID_PAGENO();
    } else if( l1pt_page >= r4 ) {
        err := KEV_ERR_INVALID_PAGENO();
    } else {  //TODO
        
    }

}

procedure smc_handler(
    {:register op_r(4)} callno:int,
    {:register op_r(0)} arg1:int,
    {:register op_r(1)} arg2:int,
    {:register op_r(2)} arg3:int,
    {:register op_r(3)} arg4:int,
    out {:register op_r(11)} err:int,
    out {:register op_r(12)} retval:int)
    requires/ensures
        ValidState(this);
        can_fcall_n(this,3);
    requires
        callno == KEV_SMC_INIT_ADDRSPACE() ==>
            ValidMem(this, Address(PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(arg1)))) &&
            isUInt32(addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(arg1))));
{
    
    retval := 0;
    
    if(callno == KEV_SMC_QUERY()) {
        err := KEV_MAGIC();
    } else if(callno == KEV_SMC_GETPHYSPAGES()) {
        retval := KEVLAR_SECURE_NPAGES();
        err := KEV_ERR_SUCCESS();
    } else if(callno == KEV_SMC_INIT_ADDRSPACE()) {
        kev_smc_init_addrspace(arg1, arg2, err);
    }

}

procedure main(){}

#verbatim

method Main()
{
  printHeader();
  var n := printCode(sp_code_main(), 0);
  printFooter();
}
#endverbatim
