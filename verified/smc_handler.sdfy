procedure operator(:=) (out{:operand} dst:int, {:operand} src:int)   := MOV

procedure kev_smc_get_phys_pages() //arg1, arg2

procedure fcall_prologue()
    requires/ensures
        ValidState(this);
    requires
        36 <= sp < MaxVal();
        ValidMemRange(this, sp-36, sp);
        MemRangeIs32(this, sp-36, sp); 
    ensures
        sp == old(sp-36);
        ValidMemRange(this, sp, sp+36);
        MemRangeIs32(this, sp, sp+36); 
{

    //push link register onto stack
    SUB(sp, sp, 4);
    STR(lr, sp, 0);

    //push r4-r11 onto stack
    SUB(sp,  sp, 4);
    STR(r4,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r5,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r6,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r7,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r8,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r9,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r10, sp, 0);
    SUB(sp,  sp, 4);
    STR(r11, sp, 0);

    // Move function arguments in r0-r3 into r4-r7
    r4 := r0;
    r5 := r1;
    r6 := r2;
    r7 := r3;
}

procedure fcall_epilogue()
    requires/ensures
        ValidState(this);
    requires
        0 <= sp + 36 < MaxVal();
        ValidMemRange(this, sp, sp+36);
        MemRangeIs32(this,  sp, sp+36);
    ensures
        sp == old(sp+36);
        ValidMemRange(this, sp-36, sp);
        MemRangeIs32(this,  sp-36, sp);
{
    //pop r11 down to r4 from stack
    // ghost var old_sp := sp;
    // assert isUInt32(addrval(this, sp));
    // assert isUInt32(addrval(this, sp+4));
    // assert isUInt32(addrval(this, sp+8));
    // assert isUInt32(addrval(this, sp+12));
    // assert isUInt32(addrval(this, sp+16));
    // assert isUInt32(addrval(this, sp+20));
    // assert isUInt32(addrval(this, sp+24));
    // assert isUInt32(addrval(this, sp+28));
    // assert isUInt32(addrval(this, sp+32));
    // assert isUInt32(addrval(this, sp+36));

    LDR(r11, sp, 0);
    ADD(sp, sp, 4);
    // assert sp == old_sp + 4;
    // assert isUInt32(addrval(this, sp));
    LDR(r10, sp, 0);
    ADD(sp, sp, 4);
    // assert sp == old_sp + 8;
    // assert isUInt32(addrval(this, sp));
    LDR(r9, sp, 0);
    ADD(sp, sp, 4);
    // assert sp == old_sp + 12;
    // assert isUInt32(addrval(this, sp));
    LDR(r8, sp, 0);
    ADD(sp, sp, 4);
    // assert sp == old_sp + 16;
    // assert isUInt32(addrval(this, sp));
    LDR(r7, sp, 0);
    ADD(sp, sp, 4);
    // assert sp == old_sp + 20;
    // assert isUInt32(addrval(this, sp));
    LDR(r6, sp, 0);
    ADD(sp, sp, 4);
    // assert sp == old_sp + 24;
    // assert isUInt32(addrval(this, sp));
    LDR(r5, sp, 0);
    ADD(sp, sp, 4);
    // assert sp == old_sp + 28;
    // assert isUInt32(addrval(this, sp));
    LDR(r4, sp, 0);
    ADD(sp, sp, 4);
    // assert sp == old_sp + 32;
    // assert isUInt32(addrval(this, sp));

    //pop link register from stack
    LDR(lr, sp, 0);
    ADD(sp, sp, 4);
    // assert sp == old_sp + 36;
    // assert isUInt32(addrval(this, sp));

    //Move function arguments back into r0-r3
    r0 := r4;
    r1 := r5;
    r2 := r6;
    r3 := r7;
}

procedure smc_handler()
    requires
        ValidState(this);
        sp >= 36;
        ValidMemRange(this, sp-36, sp);
        MemRangeIs32(this, sp-36, sp);
{
    fcall_prologue();
    fcall_epilogue();

    //Here, callno is used as an input to select the particular call and
    //as the return value
    // if(callno == KEV_SMC_QUERY()) {
    //     callno := KEV_MAGIC();
    // } else(callno == KEV_SMC_GETPHYSPAGES()) {
    //     callno := kev_smc_get_phys_pages();
    // }

}

procedure main(){}

#verbatim

method Main()
{
  printHeader();
  var n := printCode(sp_code_main(), 0);
  printFooter();
}
#endverbatim
