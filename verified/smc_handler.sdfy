#token += precedence :=
procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

#verbatim
function page_paddr(pagenr:PageNr):int
    requires validPageNr(pagenr)
    ensures WordAligned(page_paddr(pagenr))
{
    SecurePhysBaseValue() + KEVLAR_PAGE_SIZE() * pagenr
}

function page_monvaddr(pagenr:PageNr):int
    requires validPageNr(pagenr)
    ensures WordAligned(page_monvaddr(pagenr))
{
    page_paddr(pagenr) + KEVLAR_DIRECTMAP_VBASE()
}

predicate addrInPage(m:mem, p:PageNr)
    requires validPageNr(p)
{
    WordAligned(m) && page_monvaddr(p) <= m < page_monvaddr(p) + KEVLAR_PAGE_SIZE()
}

predicate memContainsPage(memmap: map<mem, int>, p:PageNr)
    requires validPageNr(p)
{
    forall m :: addrInPage(m,p) ==> m in memmap
}

function extractPage(s:memstate, p:PageNr): map<mem, int>
    requires SaneMem(s)
    requires validPageNr(p)
    ensures memContainsPage(extractPage(s,p), p)
{
    // XXX: expanded addrInPage() to help Dafny see a bounded set
    (map m | WordAligned(m)
        && page_monvaddr(p) <= m < page_monvaddr(p) + KEVLAR_PAGE_SIZE()
        :: s.addresses[m])
}

function extractPageDbEntry(s:memstate, p:PageNr): seq<int>
    requires SaneMem(s)
    requires validPageNr(p)
    ensures |extractPageDbEntry(s,p)| == BytesToWords(PAGEDB_ENTRY_SIZE())
    ensures forall o :: WordAligned(o) && 0 <= o < PAGEDB_ENTRY_SIZE()
        ==> GlobalWord(s, PageDb(), G_PAGEDB_ENTRY(p) + o)
            == extractPageDbEntry(s,p)[BytesToWords(o)]
{
    var fulldb := GlobalFullContents(s, PageDb());
    assert |fulldb| == BytesToWords(G_PAGEDB_SIZE());
    var entrylen := BytesToWords(PAGEDB_ENTRY_SIZE());
    fulldb[p*entrylen..p*entrylen+entrylen]
}

predicate pageDbCorresponds(s:memstate, pagedb:PageDb)
    requires SaneMem(s)
    requires pageDbClosedRefs(pagedb)
{
    // XXX: unpack the entry and page contents here to help dafny see
    // that we have no other dependencies on the state
    var db := (map p | 0 <= p < KEVLAR_SECURE_NPAGES() :: extractPageDbEntry(s,p));
    var secpages := (map p | 0 <= p < KEVLAR_SECURE_NPAGES() :: extractPage(s,p));
    forall p {:trigger validPageNr(p)} :: validPageNr(p)
        ==> (pageDbEntryCorresponds(p, pagedb[p], db[p])
            && pageContentsCorresponds(p, pagedb[p], secpages[p]))
}

predicate pageDbCorrespondsExcluding(s:memstate, pagedb:PageDb, modifiedPage:PageNr)
    requires SaneMem(s)
    requires pageDbClosedRefs(pagedb)
{
    forall p {:trigger validPageNr(p)} :: validPageNr(p) && p != modifiedPage
        ==> (pageDbEntryCorresponds(p, pagedb[p], extractPageDbEntry(s, p))
            && pageContentsCorresponds(p, pagedb[p], extractPage(s, p)))
}

predicate pageDbCorrespondsOnly(s:memstate, pagedb:PageDb, p:PageNr)
    requires SaneMem(s)
    requires pageDbClosedRefs(pagedb)
    requires validPageNr(p)
{
    pageDbEntryCorresponds(p, pagedb[p], extractPageDbEntry(s, p))
    && pageContentsCorresponds(p, pagedb[p], extractPage(s, p))
}

predicate {:opaque} pageDbEntryCorresponds(p:PageNr, e:PageDbEntry, entryWords:seq<int>)
    requires validPageNr(p)
    requires |entryWords| == BytesToWords(PAGEDB_ENTRY_SIZE())
    requires e.PageDbEntryTyped?
        ==> validPageNr(e.addrspace) && closedRefsPageDbEntry(e.entry)
{
    pageDbEntryTypeVal(e) == entryWords[BytesToWords(PAGEDB_ENTRY_TYPE())]
    && match e {
        case PageDbEntryFree => true
        case PageDbEntryTyped(addrspace, entry) =>
            entryWords[BytesToWords(PAGEDB_ENTRY_ADDRSPACE())]
                == page_monvaddr(addrspace)
    }
}

predicate {:opaque} pageContentsCorresponds(p:PageNr, e:PageDbEntry, page:map<mem, int>)
    requires validPageNr(p)
    requires memContainsPage(page, p)
    requires e.PageDbEntryFree? || closedRefsPageDbEntry(e.entry)
{
    e.PageDbEntryFree? || (e.PageDbEntryTyped? && (
        var et := e.entry;
        (et.Addrspace? && pageDbAddrspaceCorresponds(p, et, page))
        || (et.Dispatcher? /* && pageDbDispatcherCorresponds(p, et, page) */)
        || (et.L1PTable? /* && pageDbL1PTableCorresponds(p, et, page) */)
        || (et.L2PTable? /* && pageDbL2PTableCorresponds(p, et, page) */)
        || et.DataPage?))
}

predicate pageDbAddrspaceCorresponds(p:PageNr, e:PageDbEntryTyped, page:map<mem, int>)
    requires validPageNr(p)
    requires memContainsPage(page, p)
    requires e.Addrspace?
    requires closedRefsPageDbEntry(e)
{
    var base := page_monvaddr(p);
    assert base in page;
    page[ADDRSPACE_L1PT(base)] == page_monvaddr(e.l1ptnr)
    && page[ADDRSPACE_L1PT_PHYS(base)] == page_paddr(e.l1ptnr)
    && page[ADDRSPACE_REF(base)] == e.refcount
    && page[ADDRSPACE_STATE(base)] == pageDbAddrspaceStateVal(e.state)
}

function pageDbEntryTypeVal(e: PageDbEntry): int
    ensures isUInt32(pageDbEntryTypeVal(e))
{
    if e.PageDbEntryFree? then KEV_PAGE_FREE()
    else match e.entry {
    case Addrspace(l1pt, ref, state) => KEV_PAGE_ADDRSPACE()
    case Dispatcher(ep, entered) => KEV_PAGE_DISPATCHER()
    case L1PTable(pt) => KEV_PAGE_L1PTABLE()
    case L2PTable(pt) => KEV_PAGE_L2PTABLE()
    case DataPage => KEV_PAGE_DATA()
    }
}

function pageDbAddrspaceStateVal(s: AddrspaceState): int
    ensures isUInt32(pageDbAddrspaceStateVal(s))
{
    match s {
    case InitState => KEV_ADDRSPACE_INIT()
    case FinalState => KEV_ADDRSPACE_FINAL()
    case StoppedState => KEV_ADDRSPACE_STOPPED()
    }
}

#endverbatim

procedure page_paddr_impl(out {:operand} phys:int, {:operand} pagenr:int, out {:operand} tmp:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@phys);
        ValidRegOperand(@pagenr);
        ValidRegOperand(@tmp);
        // NB: @phys == @pagenr is supported
        @phys != @tmp;
        @pagenr != @tmp;
        @phys != op_sp();
        @tmp != op_sp();
        validPageNr(pagenr);
    ensures
        AlwaysInvariant(old(this),this);
        AllMemInvariant(old(this),this);
        RegPreservingExcept(old(this), this, [@phys, @tmp]);
        phys == page_paddr(old(pagenr));
{
    tmp := sp_op_const(KEVLAR_PAGE_SIZE());
    MUL(phys,pagenr,tmp);
    // LSL(phys, pagenr, sp_op_const(KEVLAR_PAGE_SHIFT()));
    assert phys == old(pagenr) * KEVLAR_PAGE_SIZE();

    LDRglobaladdr(tmp, SecurePhysBase());
    LDRglobal(tmp, SecurePhysBase(), tmp, 0);
    assert WordAligned(tmp);
    phys += tmp;
}

procedure page_monvaddr_impl(out {:operand} virt:int, {:operand} pagenr:int, out {:operand} tmp:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@virt);
        ValidRegOperand(@pagenr);
        ValidRegOperand(@tmp);
        // NB: @pagenr == @virt is supported
        @pagenr != @tmp;
        @virt != @tmp;
        @virt != op_sp();
        @tmp != op_sp();
        validPageNr(pagenr);
    ensures
        AlwaysInvariant(old(this),this);
        AllMemInvariant(old(this),this);
        RegPreservingExcept(old(this), this, [@virt, @tmp]);
        virt == page_monvaddr(old(pagenr));
{
    page_paddr_impl(virt, pagenr, tmp);
    virt += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
}

procedure memset(inout {:operand} base:int, {:operand} val:int, inout {:operand} size:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@base);
        ValidRegOperand(@size);
        ValidRegOperand(@val);
        @base != @size;
        @base != @val;
        @size != @val;
        @base != @sp;
        @val != @sp;
        @size != @sp;
        WordAligned(base);
        WordAligned(size);
        isUInt32(val);
        isUInt32(base + size);
        ValidMemRange(this.m, base, base + size);
        base >= StackBase() || base + size <= StackLimit();
    ensures
        AlwaysInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this), this, [@base,@size]);
        MemPreservingExcept(old(this), this, old(base), old(base + size));
        forall i :: old(base) <= i < old(base + size) && WordAligned(i)
            ==> addrval(this,i) == old(val);
{
    ghost var lower := base;
    ghost var limit := base + size;

    // beyond this point, "base" is where we're up to, and "size" is the limit
    size += base;

    for (; base < size; base += 4)
        invariant
            AlwaysInvariant(old(this),this);
            GlobalsInvariant(old(this),this);
            SaneState(this);
            WordAligned(base);
            size == limit;
            lower <= base <= limit;
            lower >= StackBase() || limit <= StackLimit();
            forall i :: (lower <= i < base) && WordAligned(i)
                ==> addrval(this,i) == old(val);
            MemPreservingExcept(old(this), this, lower, limit);
            RegPreservingExcept(old(this), this, [@base,@size]);
        decreases
            size - base;
    {
        ghost var prevThis := this;
        STR(val, base, 0);
        assert forall p :: ValidMem(prevThis.m, p) && p != base ==> addrval(prevThis, p) == addrval(this, p);
    }
}

/* Register allocation for init_addrspace paths:
 * r0 temp / err out
 * r1 addrspace_pagenr in
 * r2 l1pt_pagenr in
 * r3 temp
 * r4 addrspace_page pagedb entry offset
 * r5 l1pt_page pagedb entry offset
 * r6 addrspace monvaddr
 * r7 l1pt paddr & monvaddr
 * r12 pagedb global base
 */

#verbatim
function initAddrspaceEntry(addrspace_page:int, l1pt_page:int): PageDbEntry
{
    PageDbEntryTyped(addrspace_page, Addrspace(l1pt_page, 1, InitState))
}

function initL1PTEntry(addrspace_page:int): PageDbEntry
{
    PageDbEntryTyped(addrspace_page, L1PTable(SeqRepeat(NR_L1PTES(), Nothing)))
}
#endverbatim

procedure init_addrspace_mem(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R6)} addrspace_va:int)
    requires/ensures
        SaneState(this);
    requires
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        addrspace_page != l1pt_page;
        addrspace_va == page_monvaddr(addrspace_page);
    ensures
        AlwaysInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
        StackPreserving(old(this),this);
        forall i :: ValidMem(this.m, i)
            && !(page_monvaddr(addrspace_page) <= i < page_monvaddr(addrspace_page) + KEVLAR_PAGE_SIZE())
            && !(page_monvaddr(l1pt_page) <= i < page_monvaddr(l1pt_page) + KEVLAR_PAGE_SIZE())
            ==> addrval(this,i) == addrval(old(this),i);
        RegPreservingExcept(old(this),this,[@r0, @r3, @r7]);
        pageContentsCorresponds(old(addrspace_page), initAddrspaceEntry(addrspace_page, l1pt_page), extractPage(this.m, old(addrspace_page)));
        pageContentsCorresponds(old(l1pt_page), initL1PTEntry(addrspace_page), extractPage(this.m, old(l1pt_page)));
{
    reveal_pageContentsCorresponds();

    page_paddr_impl(r7,l1pt_page,r0);

    STR(r7,r6,4);
    assert addrval(this,ADDRSPACE_L1PT_PHYS(addrspace_va)) == page_paddr(l1pt_page);

    r7 += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
    assert r7 == page_monvaddr(l1pt_page);
    STR(r7,r6,0);
    assert addrval(this,ADDRSPACE_L1PT(addrspace_va)) == page_monvaddr(l1pt_page);

    r0 := 1;
    STR(r0,r6,8);
    assert addrval(this,ADDRSPACE_REF(addrspace_va)) == 1;

    r0 := sp_op_const(KEV_ADDRSPACE_INIT());
    STR(r0,r6,12);
    assert addrval(this,ADDRSPACE_STATE(addrspace_va)) == KEV_ADDRSPACE_INIT();

    r3 := sp_op_const(KEVLAR_PAGE_SIZE());
    r0 := 0;
    memset(r7,r0,r3);
}

procedure init_addrspace_pagedb(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R4)} addrspace_entry:int,
    {:register OReg(R5)} l1pt_entry:int,
    out {:register OReg(R6)} addrspace_va:int,
    {:register OReg(R12)} pagedb_base:int)
    requires/ensures
        SaneState(this);
    requires
        addrspace_page != l1pt_page;
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        addrspace_entry == G_PAGEDB_ENTRY(addrspace_page);
        l1pt_entry == G_PAGEDB_ENTRY(l1pt_page);
        pagedb_base == AddressOfGlobal(PageDb());
    ensures
        AlwaysInvariant(old(this),this);
        AddrMemInvariant(old(this),this);
        RegPreservingExcept(old(this),this,[@r0, @r4, @r5, @r6]);
        addrspace_va == page_monvaddr(old(addrspace_page));
        forall p :: validPageNr(p) && p != addrspace_page && p != l1pt_page
            ==> extractPageDbEntry(old(this).m, p) == extractPageDbEntry(this.m, p);
        pageDbEntryCorresponds(addrspace_page,
                               initAddrspaceEntry(addrspace_page, l1pt_page),
                               extractPageDbEntry(this.m, addrspace_page));
        pageDbEntryCorresponds(l1pt_page, initL1PTEntry(addrspace_page),
                               extractPageDbEntry(this.m, l1pt_page));
{
    reveal_pageDbEntryCorresponds();

    /* update addrspace entry in pagedb */
    r0 := sp_op_const(KEV_PAGE_ADDRSPACE());
    STRglobal(r0, PageDb(), r12, r4);
    assert GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE())
        == KEV_PAGE_ADDRSPACE();

    page_monvaddr_impl(r6,addrspace_page,r0);
    r4 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    assert r4 == G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_ADDRSPACE();
    STRglobal(r6, PageDb(), r12, r4);
    assert extractPageDbEntry(this.m, addrspace_page)[BytesToWords(PAGEDB_ENTRY_ADDRSPACE())]
           == page_monvaddr(addrspace_page);

    assert extractPageDbEntry(this.m, addrspace_page) == [KEV_PAGE_ADDRSPACE(), old(page_monvaddr(addrspace_page))];

    /* Update l1pt entry in pagedb */
    r0 := sp_op_const(KEV_PAGE_L1PTABLE());
    STRglobal(r0, PageDb(), r12, r5);
    assert GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_L1PTABLE();
    r5 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    assert r5 == G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_ADDRSPACE();
    STRglobal(r6, PageDb(), r12, r5);
    assert GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(addrspace_page);

    assert extractPageDbEntry(this.m, l1pt_page) == [KEV_PAGE_L1PTABLE(), old(page_monvaddr(addrspace_page))];
}

procedure init_addrspace(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R4)} addrspace_entry:int,
    {:register OReg(R5)} l1pt_entry:int,
    {:register OReg(R12)} pagedb_base:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        addrspace_page != l1pt_page;
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        l1pt_page % 4 == 0;
        addrspace_entry == G_PAGEDB_ENTRY(addrspace_page);
        l1pt_entry == G_PAGEDB_ENTRY(l1pt_page);
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        pageIsFree(pagedb_in, addrspace_page);
        pageIsFree(pagedb_in, l1pt_page);
    ensures
        AlwaysInvariant(old(this),this);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this),this,[@r0, @r3, @r4, @r5, @r6, @r7]);
        old(initAddrspace(pagedb_in, addrspace_page, l1pt_page)) == Pair(pagedb, KEV_ERR_SUCCESS());
        pageDbCorresponds(this.m, pagedb);
{
    ghost var gaddrspace_entry := initAddrspaceEntry(addrspace_page, l1pt_page);
    ghost var gl1pt_entry := initL1PTEntry(addrspace_page);
    pagedb := pagedb_in[addrspace_page := gaddrspace_entry][l1pt_page := gl1pt_entry];

    /* Update entries in PageDb */
    init_addrspace_pagedb(addrspace_page, l1pt_page, addrspace_entry, l1pt_entry, r6, pagedb_base);
    assert pageDbEntryCorresponds(addrspace_page, gaddrspace_entry,
                                  extractPageDbEntry(this.m, addrspace_page));
    assert pageDbEntryCorresponds(l1pt_page, gl1pt_entry,
                                  extractPageDbEntry(this.m, l1pt_page));

    /* Update pages in memory */
    init_addrspace_mem(addrspace_page, l1pt_page, r6);

    assert pageDbCorrespondsOnly(this.m, pagedb, addrspace_page);
    assert pageDbCorrespondsOnly(this.m, pagedb, l1pt_page);

    // other pages haven't changed
    assert forall p :: validPageNr(p) && p != addrspace_page && p != l1pt_page
        ==> extractPageDbEntry(old(this).m, p) == extractPageDbEntry(this.m, p)
            && extractPage(old(this).m, p) == extractPage(this.m, p);
    assert forall p :: validPageNr(p) && p != addrspace_page && p != l1pt_page
        ==> pageDbCorrespondsOnly(old(this).m, pagedb, p);
}

procedure kev_smc_init_addrspace(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        StackPreserving(old(this),this);
        old(initAddrspace(pagedb_in, addrspace_page, l1pt_page)) == Pair(pagedb, err);
        pageDbCorresponds(this.m, pagedb);
        validPageDb(pagedb);
{
    reveal_pageDbEntryCorresponds();
    pagedb := pagedb_in;

    // check alignment of l1pt page
    AND(r0,l1pt_page,3);
    assert r0 == l1pt_page % 4;

    if (addrspace_page == l1pt_page) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (addrspace_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (l1pt_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (r0 != 0) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else {
        LDRglobaladdr(r12, PageDb());
        assert validPageNr(addrspace_page) && validPageNr(l1pt_page);
        r0 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r4,addrspace_page,r0);
        assert r4 == G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r3, PageDb(), r12, r4);
        assert pageDbEntryCorresponds(addrspace_page, pagedb[addrspace_page], extractPageDbEntry(this.m, addrspace_page));
        assert r3 == GlobalWord(this.m, PageDb(), r4) == pageDbEntryTypeVal(pagedb[addrspace_page]);
        if (r3 == sp_op_const(KEV_PAGE_FREE())) {
            assert pageIsFree(pagedb, addrspace_page);
            assert r0 == PAGEDB_ENTRY_SIZE();
            MUL(r5,l1pt_page,r0);
            assert r5 == G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_TYPE();
            LDRglobal(r0, PageDb(), r12, r5);
            assert pageDbEntryCorresponds(l1pt_page, pagedb[l1pt_page], extractPageDbEntry(this.m, l1pt_page));
            assert r0 == GlobalWord(this.m, PageDb(), r5) == pageDbEntryTypeVal(pagedb[l1pt_page]);
            if (r0 == sp_op_const(KEV_PAGE_FREE())) {
                assert pageIsFree(pagedb, l1pt_page);
                pagedb := init_addrspace(addrspace_page, l1pt_page, r4, r5, r12, pagedb);
                err := OConst(KEV_ERR_SUCCESS());
            } else {
                err := sp_op_const(KEV_ERR_PAGEINUSE());
            }
        } else {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        }
    }
}

#verbatim
lemma SameMemAndGlobalsImpliesSamePageDb(s:state, s':state, pagedb:PageDb)
    requires SaneState(s) && SaneState(s')
    requires AlwaysInvariant(s,s')
    requires pageDbClosedRefs(pagedb)
    requires pageDbCorresponds(s.m, pagedb)
    requires NonStackMemPreserving(s,s')
    requires GlobalsInvariant(s,s')
    ensures pageDbCorresponds(s'.m, pagedb)
{
    assert GlobalFullContents(s.m, PageDb()) == GlobalFullContents(s'.m, PageDb());
    assert forall p :: validPageNr(p) ==> extractPage(s.m, p) == extractPage(s'.m, p);
}
#endverbatim

procedure smc_handler(
    {:register OReg(R0)} callno:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    {:register OReg(R4)} arg4:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} retval:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this,120);
    requires
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        NonvolatileRegPreserving(old(this),this);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ghost var stack_bytes := 120;
    pagedb := pagedb_in;
    retval := 0;

    fcall_prologue(stack_bytes);
    SameMemAndGlobalsImpliesSamePageDb(old(this), this, pagedb);

    if(callno == sp_op_const(KEV_SMC_QUERY())) {
        err := sp_op_const(KEV_MAGIC());
    } else if(callno == sp_op_const(KEV_SMC_GETPHYSPAGES())) {
        retval := sp_op_const(KEVLAR_SECURE_NPAGES());
        err := sp_op_const(KEV_ERR_SUCCESS());
    } else if(callno == sp_op_const(KEV_SMC_INIT_ADDRSPACE())) {
        pagedb := kev_smc_init_addrspace(arg1, arg2, err, pagedb);
    }

    ghost var prePopThis := this;
    fcall_epilogue(stack_bytes-40);
    SameMemAndGlobalsImpliesSamePageDb(prePopThis, this, pagedb);

    // zero other volatiles to prevent information leakage
    r2 := 0;
    r3 := 0;

    // TODO: return path (movs pc, lr etc.)
}

#verbatim
function method {:opaque} PageDb(): operand { op_sym("g_pagedb") }
function method {:opaque} SecurePhysBase(): operand { op_sym("g_secure_physbase") }

// the phys base is unknown, but never changes
function {:axiom} SecurePhysBaseValue(): int
    ensures 0 < SecurePhysBaseValue() <= KEVLAR_PHYSMEM_LIMIT() - KEVLAR_SECURE_RESERVE();
    ensures WordAligned(SecurePhysBaseValue());

function method MyGlobalDecls(): globaldecls
    ensures ValidGlobalDecls(MyGlobalDecls());
{
    reveal_PageDb(); reveal_SecurePhysBase();
    GlobalDecls(map[SecurePhysBase() := 4, //BytesPerWord()
                    PageDb() := G_PAGEDB_SIZE()])
}

predicate SaneMem(s:memstate)
{
    ValidMemState(s)
    // TODO: our insecure phys mapping must be valid
    //&& ValidMemRange(s, KEVLAR_DIRECTMAP_VBASE(),
    //    (KEVLAR_DIRECTMAP_VBASE() + MonitorPhysBaseValue()))
    // our secure phys mapping must be valid
    && ValidMemRange(s, KEVLAR_DIRECTMAP_VBASE() + SecurePhysBaseValue(),
        (KEVLAR_DIRECTMAP_VBASE() + SecurePhysBaseValue() + KEVLAR_SECURE_RESERVE()))
    // the stack must be mapped
    && ValidMemRange(s, StackLimit(), StackBase())
    // globals are as we expect
    && MyGlobalDecls() == TheGlobalDecls()
    && GlobalFullContents(s, SecurePhysBase()) == [SecurePhysBaseValue()]
    // XXX: workaround so dafny sees that these are distinct
    && SecurePhysBase() != PageDb()
}

predicate SaneState(s:state)
{
    ValidState(s) && ValidStack(s) && SaneMem(s.m) && s.mod == Monitor
}

method Main()
{
    printHeader();
    var n := printFunction("smc_handler", sp_code_smc_handler(), 0);
    printBss(MyGlobalDecls());
    printFooter();
}
#endverbatim
