#verbatim
predicate can_fcall(s:sp_state)
{
    ValidState(s) &&
    36 <= eval_op(s, op_sp()) < MaxVal() &&
    ValidMemRange(s, eval_op(s, op_sp())-36, eval_op(s, op_sp()) ) &&
    MemRangeIs32(s, eval_op(s, op_sp())-36, eval_op(s, op_sp()))
}
#endverbatim

#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

procedure fcall_prologue()
    requires/ensures
        ValidState(this);
    requires
        36 <= sp < MaxVal();
        ValidMemRange(this, sp-36, sp);
        MemRangeIs32(this, sp-36, sp); 
    ensures
        sp == old(sp-36);
        ValidMemRange(this, sp, sp+36);
        MemRangeIs32(this, sp, sp+36); 
{

    //push link register onto stack
    SUB(sp, sp, 4);
    STR(lr, sp, 0);

    //push r4-r11 onto stack
    SUB(sp,  sp, 4);
    STR(r4,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r5,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r6,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r7,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r8,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r9,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r10, sp, 0);
    SUB(sp,  sp, 4);
    STR(r11, sp, 0);

    // Move function arguments in r0-r3 into r4-r7
    // r4 := r0;
    // r5 := r1;
    // r6 := r2;
    // r7 := r3;
}

procedure fcall_epilogue()
    requires/ensures
        ValidState(this);
    requires
        0 <= sp + 36 < MaxVal();
        ValidMemRange(this, sp, sp+36);
        MemRangeIs32(this,  sp, sp+36);
    ensures
        sp == old(sp+36);
        ValidMemRange(this, sp-36, sp);
        MemRangeIs32(this,  sp-36, sp);
{
    //pop r11 down to r4 from stack
    LDR(r11, sp, 0);
    ADD(sp, sp, 4);
    LDR(r10, sp, 0);
    ADD(sp, sp, 4);
    LDR(r9, sp, 0);
    ADD(sp, sp, 4);
    LDR(r8, sp, 0);
    ADD(sp, sp, 4);
    LDR(r7, sp, 0);
    ADD(sp, sp, 4);
    LDR(r6, sp, 0);
    ADD(sp, sp, 4);
    LDR(r5, sp, 0);
    ADD(sp, sp, 4);
    LDR(r4, sp, 0);
    ADD(sp, sp, 4);

    //pop link register from stack
    LDR(lr, sp, 0);
    ADD(sp, sp, 4);

    //Move function arguments back into r0-r3
    // r0 := r4;
    // r1 := r5;
    // r2 := r6;
    // r3 := r7;
}

// loads the pagedb_entry address for pageno into entry
procedure pagedb_entry(
    {:operand} pageno:int,
    out {:operand} entry:int)
    requires/ensures
        @pageno != @entry;
        @entry != op_r(9);
        @pageno != op_r(9);
        ValidState(this);
        ValidOperand(this, @pageno);
        ValidDestinationOperand(this, @entry);
        0 <= pageno < 256;
    ensures
        entry == 0x4000_0000 + pageno * 5;
{
    entry := 0x4000_0000; // G_PAGEDB()
   
    assert entry <= 0x4000_0000 + r9 * 5;
    for (r9:= 0; r9 < pageno; r9++)
      invariant
        @entry != @pageno;
        @entry != op_r(9);
        @pageno != op_r(9);
        ValidState(this);
        ValidOperand(this, @pageno);
        ValidDestinationOperand(this, @entry);
        isUInt32(entry);
        0 <= r9 <= pageno;
        entry == 0x4000_0000 + r9 * 5;
        0 <= pageno < 256;
      decreases
        pageno - r9;
    {
        ADD(entry, entry, 5);
    }

    assert r9 == pageno;
    assert entry == 0x4000_0000 + r9 * 5;
    assert entry == 0x4000_0000 + pageno * 5;

    
}

procedure kev_smc_init_addrspace(
    {:register op_r(0)} addrspace_page:int,
    {:register op_r(1)} l1pt_page:int,
    out {:register op_r(0)} err:int)
    requires/ensures
        can_fcall(this);
{
    fcall_prologue();
    err := 0;

    r4 := KEVLAR_SECURE_NPAGES() % pow2_32();
    // r5 := PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page));  //addr of type
    // LDR(r5, r5, 0); // type
    // r6 := PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page));  //addr of type
    // LDR(r6, r6, 0); // type
    if( addrspace_page >= r4 ) {
        err := KEV_ERR_INVALID_PAGENO();
    } else if( l1pt_page >= r4 ) {
        err := KEV_ERR_INVALID_PAGENO();
    } else { //todo
        err := KEV_ERR_SUCCESS();
    }


    fcall_epilogue();
}

procedure smc_handler(
    {:register op_r(4)} callno:int,
    {:register op_r(0)} arg1:int,
    {:register op_r(1)} arg2:int,
    {:register op_r(2)} arg3:int,
    {:register op_r(3)} arg4:int,
    out {:register op_r(0)} err:int,
    out {:register op_r(1)} retval:int)
    requires/ensures
        can_fcall(this);
{
    
    retval := 0;
    
    if(callno == KEV_SMC_QUERY()) {
        err := KEV_MAGIC();
    } else if(callno == KEV_SMC_GETPHYSPAGES()) {
        // assume 0 <= KEVLAR_SECURE_NPAGES() < pow2_32(); // Really want to inline constants
        retval := KEVLAR_SECURE_NPAGES() % pow2_32();
        err := KEV_ERR_SUCCESS();
    } else if(callno == KEV_SMC_INIT_ADDRSPACE()) {
        kev_smc_init_addrspace(arg1, arg2, err);
    }

}

procedure main(){}

#verbatim

method Main()
{
  printHeader();
  var n := printCode(sp_code_main(), 0);
  printFooter();
}
#endverbatim
