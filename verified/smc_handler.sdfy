#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

#verbatim
predicate page_is_valid(page:int)
{
    0 <= page < KEVLAR_SECURE_NPAGES()
}

lemma valid_pagenr_ensures_valid_mem(s:state, pagenr: int)
      requires SaneState(s)
      requires page_is_valid(pagenr)
      ensures ValidMemRange(s, page_monvaddr(s, pagenr), page_monvaddr(s, pagenr) + KEVLAR_PAGE_SIZE())
{}

function page_paddr(s:state,pagenr:int):int
    requires page_is_valid(pagenr)
    requires SaneGlobals(s)
    ensures WordAligned(page_paddr(s,pagenr))
{
    GlobalContents(s, SecurePhysBase(), 0) + KEVLAR_PAGE_SIZE() * pagenr
}

function page_monvaddr(s:state,pagenr:int):int
    requires page_is_valid(pagenr)
    requires SaneGlobals(s)
    ensures WordAligned(page_monvaddr(s,pagenr))
{
    page_paddr(s,pagenr) + KEVLAR_DIRECTMAP_VBASE()
}

predicate pageDbCorresponds(s:state, pagedb:PageDb)
    requires SaneState(s)
    requires validPageDb(pagedb)
{
    forall p :: validPageNr(p) ==> pageDbEntryCorresponds(s, p, pagedb[p])
}

predicate pageDbEntryCorresponds(s:state, p: PageNr, e: PageDbEntry)
    requires SaneState(s)
    requires validPageNr(p)
{
    pageDbEntryTypeVal(e) == GlobalContents(s, PageDb(), G_PAGEDB_ENTRY(p)
                                            + PAGEDB_ENTRY_TYPE())
    && match e {
        case PageDbEntryFree => true
        case PageDbEntryTyped(addrspace, entry) =>
            pageDbTypedEntryCorresponds(s, p, entry)
            && GlobalContents(s, PageDb(), G_PAGEDB_ENTRY(p)
                           + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(s, addrspace)
    }
}

predicate pageDbTypedEntryCorresponds(s:state, p:PageNr, e:PageDbEntryTyped)
    requires SaneState(s)
    requires validPageNr(p)
{
    (e.Addrspace? && pageDbAddrspaceCorresponds(s, p, e))
    || (e.Dispatcher? /* && pageDbDispatcherCorresponds(s, p, e) */)
    || (e.L1PTable? /* && pageDbL1PTableCorresponds(s, p, e) */)
    || (e.L2PTable? /* && pageDbL2PTableCorresponds(s, p, e) */)
    || e.DataPage?
}

predicate pageDbAddrspaceCorresponds(s:state, p:PageNr, e:PageDbEntryTyped)
    requires SaneState(s)
    requires validPageNr(p)
    requires e.Addrspace?
{
    var base := page_monvaddr(s, p);
    addrval(s, ADDRSPACE_L1PT(base)) == page_monvaddr(s, e.l1ptnr)
    && addrval(s, ADDRSPACE_L1PT_PHYS(base)) == page_paddr(s, e.l1ptnr)
    && addrval(s, ADDRSPACE_REF(base)) == e.refcount
    && addrval(s, ADDRSPACE_STATE(base)) == pageDbAddrspaceStateVal(e.state)
}

function pageDbEntryTypeVal(e: PageDbEntry): int
    ensures isUInt32(pageDbEntryTypeVal(e))
{
    if e.PageDbEntryFree? then KEV_PAGE_FREE()
    else match e.entry {
    case Addrspace(l1pt, ref, state) => KEV_PAGE_ADDRSPACE()
    case Dispatcher(ep, entered) => KEV_PAGE_DISPATCHER()
    case L1PTable(pt) => KEV_PAGE_L1PTABLE()
    case L2PTable(pt) => KEV_PAGE_L2PTABLE()
    case DataPage => KEV_PAGE_DATA()
    }
}

function pageDbAddrspaceStateVal(s: AddrspaceState): int
    ensures isUInt32(pageDbAddrspaceStateVal(s))
{
    match s {
    case InitState => KEV_ADDRSPACE_INIT()
    case FinalState => KEV_ADDRSPACE_FINAL()
    case StoppedState => KEV_ADDRSPACE_STOPPED()
    }
}

#endverbatim

procedure page_paddr_impl(out {:operand} phys:int, {:operand} pagenr:int, out {:operand} tmp:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(this, @phys);
        ValidRegOperand(this, @pagenr);
        ValidRegOperand(this, @tmp);
        // NB: @phys == @pagenr is supported
        @phys != @tmp;
        @pagenr != @tmp;
        @phys != op_sp();
        @tmp != op_sp();
        page_is_valid(pagenr);
    ensures
        GlobalValuePreserving(old(this),this);
        RegPreservingExcept(old(this), this, [@phys, @tmp]);
        MemPreserving(old(this),this);
        WordAligned(phys);
        phys == page_paddr(old(this), old(pagenr));
{
    tmp := sp_op_const(KEVLAR_PAGE_SIZE());
    MUL(phys,pagenr,tmp);
    // LSL(phys, pagenr, sp_op_const(KEVLAR_PAGE_SHIFT()));
    assert phys == old(pagenr) * KEVLAR_PAGE_SIZE();

    LDRglobaladdr(tmp, SecurePhysBase());
    LDRglobal(tmp, SecurePhysBase(), tmp, 0);
    assert WordAligned(tmp);
    phys += tmp;
}

procedure page_monvaddr_impl(out {:operand} virt:int, {:operand} pagenr:int, out {:operand} tmp:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(this, @virt);
        ValidRegOperand(this, @pagenr);
        ValidRegOperand(this, @tmp);
        // NB: @pagenr == @virt is supported
        @pagenr != @tmp;
        @virt != @tmp;
        @virt != op_sp();
        @tmp != op_sp();
        page_is_valid(pagenr);
    ensures
        GlobalValuePreserving(old(this),this);
        RegPreservingExcept(old(this), this, [@virt, @tmp]);
        MemPreserving(old(this),this);
        WordAligned(virt);
        virt == page_monvaddr(old(this), old(pagenr));
{
    page_paddr_impl(virt, pagenr, tmp);
    virt += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
}

procedure memset(inout {:operand} base:int, {:operand} val:int, inout {:operand} size:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(this, @base);
        ValidRegOperand(this, @size);
        ValidRegOperand(this, @val);
        @base != @size;
        @base != @val;
        @size != @val;
        @base != @sp;
        @val != @sp;
        @size != @sp;
        WordAligned(base);
        WordAligned(size);
        isUInt32(val);
        isUInt32(base + size);
        ValidMemRange(this, base, base + size);
        base >= StackBase() || base + size <= StackLimit();
    ensures
        // XXX: I shouldn't have to say this! :(
        MemValidityPreserving(old(this), this);
        GlobalValuePreserving(old(this),this);
        forall i:int :: (old(base) <= i < old(base + size)) && WordAligned(i) ==>
            addrval(this,i) == old(val);
        forall i:int :: !(old(base) <= i < old(base + size)) && WordAligned(i) &&
            !(StackLimit() <= i < StackBase()) &&
            ValidMem(old(this),Address(i)) ==>
                addrval(this,i) == addrval(old(this),i);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this), this, [@base,@size]);
{
    ghost var lower := base;
    ghost var limit := base + size;

    // beyond this point, "base" is where we're up to, and "size" is the limit
    size += base;

    for (; base < size; base += 4)
        invariant
            ValidState(this);
            ValidStack(this);
            sp == old(sp);
            size == limit;
            GlobalValuePreserving(old(this),this);
            ValidMemRange(old(this),lower,limit);
            MemValidityPreserving(old(this), this);
            StackPreserving(old(this),this);
            RegPreservingExcept(old(this), this, [@base,@size]);
            WordAligned(base);
            lower <= base <= limit;
            lower >= StackBase() || limit <= StackLimit();
            forall i:int :: (lower <= i < base) && WordAligned(i) ==>
                addrval(this,i) == old(val);
            forall i:int :: !(lower <= i < base) && WordAligned(i) &&
                ValidMem(old(this),Address(i)) ==>
                    addrval(this,i) == addrval(old(this),i);
        decreases
            size - base;
    {
        STR(val, base, 0);
    }
}

/* Register allocation for init_addrspace paths:
 * r0 temp / err out
 * r1 addrspace_pagenr in
 * r2 l1pt_pagenr in
 * r3 temp
 * r4 addrspace_page pagedb entry offset
 * r5 l1pt_page pagedb entry offset
 * r6 addrspace monvaddr
 * r7 l1pt paddr & monvaddr
 * r12 pagedb global base
 */

procedure kev_smc_init_addrspace_success(
    {:register op_r(1)} addrspace_page:int,
    {:register op_r(2)} l1pt_page:int,
    {:register op_r(4)} addrspace_entry:int,
    {:register op_r(5)} l1pt_entry:int,
    {:register op_r(12)} pagedb_base:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        addrspace_page != l1pt_page;
        page_is_valid(addrspace_page);
        page_is_valid(l1pt_page);
        l1pt_page % 4 == 0;
        addrspace_entry == G_PAGEDB_ENTRY(addrspace_page);
        l1pt_entry == G_PAGEDB_ENTRY(l1pt_page);
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        pageDbCorresponds(this, pagedb_in);
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_FREE();
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_FREE();
    ensures
        StackPreserving(old(this),this);
        old(initAddrspace(pagedb_in, addrspace_page, l1pt_page)) == Pair(pagedb, KEV_ERR_SUCCESS());
        pageDbCorresponds(this, pagedb);
        validPageDb(pagedb);

/*
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_ADDRSPACE();
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                             + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(this, addrspace_page);
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                             + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_L1PTABLE();
        GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                             + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(this, addrspace_page);
        addrval(this, ADDRSPACE_L1PT(page_monvaddr(this, addrspace_page))) == page_monvaddr(this, l1pt_page);
        addrval(this, ADDRSPACE_L1PT_PHYS(page_monvaddr(this, addrspace_page))) == l1pt_page; 
        addrval(this, ADDRSPACE_REF(page_monvaddr(this, addrspace_page))) == 1;
        addrval(this, ADDRSPACE_STATE(page_monvaddr(this, addrspace_page))) == KEV_ADDRSPACE_INIT();
        forall i:int :: (page_monvaddr(this, l1pt_page) <= i < page_monvaddr(this, l1pt_page) + KEVLAR_PAGE_SIZE()) &&
            WordAligned(i) ==> addrval(this, i) == 0;
*/
{
    r0 := sp_op_const(KEV_PAGE_ADDRSPACE());
    STRglobal(r0, PageDb(), r12, r4);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                          + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_ADDRSPACE();
    page_monvaddr_impl(r6,addrspace_page,r0);
    r4 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    STRglobal(r6, PageDb(), r12, r4);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page)
                          + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(this, addrspace_page);

    r0 := sp_op_const(KEV_PAGE_L1PTABLE());
    STRglobal(r0, PageDb(), r12, r5);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_L1PTABLE();
    r5 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    STRglobal(r6, PageDb(), r12, r5);
    assert GlobalContents(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(this, addrspace_page);

    page_paddr_impl(r7,l1pt_page,r0);
    STR(r7,r6,4);
    assert addrval(this,ADDRSPACE_L1PT_PHYS(page_monvaddr(this, addrspace_page))) == page_paddr(this, l1pt_page);

    r7 += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
    assert r7 == page_monvaddr(this, l1pt_page);
    STR(r7,r6,0);
    assert addrval(this,ADDRSPACE_L1PT(page_monvaddr(this, addrspace_page))) == page_monvaddr(this, l1pt_page);

    r0 := 1;
    STR(r0,r6,8);
    assert addrval(this,ADDRSPACE_REF(page_monvaddr(this, addrspace_page))) == 1;

    r0 := sp_op_const(KEV_ADDRSPACE_INIT());
    STR(r0,r6,12);
    assert addrval(this,ADDRSPACE_STATE(page_monvaddr(this, addrspace_page))) == KEV_ADDRSPACE_INIT();
  
    r3 := sp_op_const(KEVLAR_PAGE_SIZE());
    r0 := 0;
    memset(r7,r0,r3); //page_monvaddr(this, l1pt_page)
}

procedure kev_smc_init_addrspace(
    {:register op_r(1)} addrspace_page:int,
    {:register op_r(2)} l1pt_page:int,
    out {:register op_r(0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbCorresponds(this, pagedb_in);
    ensures
        StackPreserving(old(this),this);
        old(initAddrspace(pagedb_in, addrspace_page, l1pt_page)) == Pair(pagedb, err);
        pageDbCorresponds(this, pagedb);
        validPageDb(pagedb);
{
    pagedb := pagedb_in;
    assert pageDbCorresponds(this, pagedb);

    // check alignment of l1pt page
    AND(r0,l1pt_page,3);
    assert r0 == l1pt_page % 4;

    if (addrspace_page == l1pt_page) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
        assert pageDbCorresponds(this, pagedb);
    } else if (addrspace_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
        assert pageDbCorresponds(this, pagedb);
    } else if (l1pt_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
        assert pageDbCorresponds(this, pagedb);
    } else if (r0 != 0) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
        assert pageDbCorresponds(this, pagedb);
    } else {
        r0 := sp_op_const(PAGEDB_ENTRY_SIZE());
        LDRglobaladdr(r12, PageDb());
        MUL(r4,addrspace_page,r0);
        assert r4 == G_PAGEDB_ENTRY(addrspace_page);
        LDRglobal(r3, PageDb(), r12, r4);
        assert r3 == pageDbEntryTypeVal(pagedb[addrspace_page]);

        MUL(r5,l1pt_page,r0);
        assert r5 == G_PAGEDB_ENTRY(l1pt_page);
        LDRglobal(r0, PageDb(), r12, r5);
        assert r0 == pageDbEntryTypeVal(pagedb[l1pt_page]);

        if( r3 != sp_op_const(KEV_PAGE_FREE()) ) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else if( r0 != sp_op_const(KEV_PAGE_FREE()) ) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else {
            assert pagedb == pagedb_in && pageDbCorresponds(this, pagedb);
            pagedb := kev_smc_init_addrspace_success(addrspace_page, l1pt_page, r4, r5, r12, pagedb);
            assert pageDbCorresponds(this, pagedb);
            err := OConst(KEV_ERR_SUCCESS());
        }
        assert pageDbCorresponds(this, pagedb);
    }
}

procedure smc_handler(
    {:register op_r(0)} callno:int,
    {:register op_r(1)} arg1:int,
    {:register op_r(2)} arg2:int,
    {:register op_r(3)} arg3:int,
    {:register op_r(4)} arg4:int,
    out {:register op_r(0)} err:int,
    out {:register op_r(1)} retval:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this,120);
    requires
        validPageDb(pagedb_in);
    ensures
        NonvolatileRegPreserving(old(this),this);
        validPageDb(pagedb);
{
    ghost var stack_bytes := 120;
    pagedb := pagedb_in;

    fcall_prologue(stack_bytes);

    retval := 0;

    if(callno == sp_op_const(KEV_SMC_QUERY())) {
        err := sp_op_const(KEV_MAGIC());
    } else if(callno == sp_op_const(KEV_SMC_GETPHYSPAGES())) {
        retval := sp_op_const(KEVLAR_SECURE_NPAGES());
        err := sp_op_const(KEV_ERR_SUCCESS());
    } else if(callno == sp_op_const(KEV_SMC_INIT_ADDRSPACE())) {
        pagedb := kev_smc_init_addrspace(arg1, arg2, err, pagedb);
        retval := 0;
    }

    // remind the verifier to think about our invariant...
    assert SaneState(this);

    fcall_epilogue(stack_bytes-40);

    // zero other volatiles to prevent information leakage
    r2 := 0;
    r3 := 0;

    // TODO: return path (movs pc, lr etc.)
}

#verbatim
function method PageDb(): operand { op_sym("g_pagedb") }
function method SecurePhysBase(): operand { op_sym("g_secure_physbase") }

function method MyGlobalDecls(): globaldecls
    ensures ValidGlobalDecls(MyGlobalDecls());
{
    GlobalDecls(map[SecurePhysBase() := 4, //BytesPerWord()
                    PageDb() := G_PAGEDB_SIZE()])
}

predicate SaneGlobals(s:state)
{
    MyGlobalDecls() == TheGlobalDecls()
        && ValidGlobalState(s)
        && WordAligned(GlobalContents(s, SecurePhysBase(), 0))
        && GlobalContents(s, SecurePhysBase(), 0)
            <= KEVLAR_PHYSMEM_LIMIT() - KEVLAR_SECURE_RESERVE()
        // XXX: workaround so dafny sees that these are distinct
        && SecurePhysBase() != PageDb()
}

predicate SaneMemRanges(s:state)
{
    ValidState(s) && SaneGlobals(s)
    // our phys mapping must be valid to the top of the secure region
    && ValidMemRange(s, KEVLAR_DIRECTMAP_VBASE(),
        (KEVLAR_DIRECTMAP_VBASE() + GlobalContents(s, SecurePhysBase(), 0)
            + KEVLAR_SECURE_RESERVE()))
    // the stack must be mapped
    && ValidMemRange(s, StackLimit(), StackBase())
}

predicate SaneState(s:state)
{
    s.mod == Monitor && ValidState(s) && ValidStack(s) && SaneGlobals(s) && SaneMemRanges(s)
}

method Main()
{
    printHeader();
    var n := printFunction("smc_handler", sp_code_smc_handler(), 0);
    printBss(MyGlobalDecls());
    printFooter();
}
#endverbatim
