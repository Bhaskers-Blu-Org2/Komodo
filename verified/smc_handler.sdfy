#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

#verbatim
predicate page_is_valid(page:int)
{
    0 <= page < KEVLAR_SECURE_NPAGES()
}

function vmap(phys:int):int
{
   KEVLAR_DIRECTMAP_VBASE() + G_SECURE_PHYSBASE() +
        KEVLAR_PAGE_SIZE() * phys
}

predicate ValidAddrspace(s:state,base:int)
{
    ValidMem(s,Address(ADDRSPACE_L1PT(base))) &&
    ValidMem(s,Address(ADDRSPACE_L1PT_PHYS(base))) &&
    ValidMem(s,Address(ADDRSPACE_REF(base))) &&
    ValidMem(s,Address(ADDRSPACE_STATE(base)))
}

#endverbatim

procedure phys2monvaddr({:register op_r(1)} phys:int, out {:register op_r(0)} virt:int, ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
        fcall_depth > 1;
        can_fcall_n(this,fcall_depth);
    requires
        page_is_valid(phys);
    ensures
        virt == KEVLAR_DIRECTMAP_VBASE() + G_SECURE_PHYSBASE() +
            KEVLAR_PAGE_SIZE() * phys;
        WordAligned(virt);
        MemValidityPreserving(old(this),this);
        RegPreserving(old(this),this);
        StackValuePreserving(old(this),this,fcall_depth);
        NonStackValuePreserving(old(this),this);
{
    fcall_prologue(fcall_depth);
    MUL(virt,phys,sp_op_const(KEVLAR_PAGE_SIZE()));
    virt += sp_op_const(G_SECURE_PHYSBASE());
    virt += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
    fcall_epilogue(fcall_depth-1);
}

//This is not quite the same as std::memset
procedure memset({:register op_r(0)} lower:int, {:register op_r(1)} upper:int,
    {:register op_r(2)} val:int, ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemRange(this,lower,upper);
        WordAligned(lower);
        WordAligned(upper);
        ValidMemIs32(this);
        fcall_depth > 1;
        can_fcall_n(this,fcall_depth);
    requires
        lower < upper;
        lower >= STACK_UPPER() || upper < STACK_LOWER();
    ensures
        MemValidityPreserving(old(this),this);
        forall i:int :: (lower <= i < upper) && WordAligned(i) ==>
            addrval(this,i) == val;
        forall i:int :: !(lower <= i < upper) && WordAligned(i) &&
            !(STACK_LOWER() <= i < STACK_UPPER()) &&
            ValidMem(old(this),Address(i)) ==>
                addrval(this,i) == addrval(old(this),i);
        RegPreserving(old(this),this);
        StackValuePreserving(old(this),this,fcall_depth);
        r0 == old(r0);
        r1 == old(r1);
        r2 == old(r2);

{
    fcall_prologue(fcall_depth);

    ghost var loop_old_sp := sp;
    ghost var pre_loop_s := this;

    assert upper == old(upper);
    assert upper == r1;

    for (r9 := lower; r9 < upper; r9+=4)
        invariant
            ValidState(this);
            ValidStack(this);
            ValidMemIs32(this);
            sp == loop_old_sp;
            MemValidityPreserving(old(this),pre_loop_s);
            MemValidityPreserving(pre_loop_s,this);
            ValidMemRange(old(this),lower,upper);
            StackValuePreserving(pre_loop_s,this,fcall_depth-1);
            can_fcall_n(this,fcall_depth-1);
         
            WordAligned(r9);
               
            r0 == old(lower);
            r1 == old(upper);
            r2 == old(val);
            lower < upper;
            lower <= r9 <= upper;
            lower >= STACK_UPPER() || upper < STACK_LOWER();
            
            forall i:int :: (lower <= i < r9) && WordAligned(i) ==>
                addrval(this,i) == val;
            forall i:int :: !(lower <= i < r9 ) && WordAligned(i) &&
                !(STACK_LOWER() <= i < STACK_UPPER()) &&
                ValidMem(pre_loop_s,Address(i)) ==>
                    addrval(this,i) == addrval(pre_loop_s,i);

        decreases
            upper - r9;
    {
        STR(r2, r9, 0);
    }
            
    fcall_epilogue(fcall_depth-1);
}

procedure kev_smc_init_addrspace_success(
    {:register op_r(0)} addrspace_page:int,
    {:register op_r(1)} l1pt_page:int,
    out {:register op_r(0)} err:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        fcall_depth > 2;
        can_fcall_n(this,fcall_depth);
        ValidMemRange(this,G_PAGEDB(),G_PAGEDB_END());
        ValidMemIs32(this);
    requires
        addrspace_page != l1pt_page;
        page_is_valid(addrspace_page);
        page_is_valid(l1pt_page);
        WordAligned(l1pt_page); 
        ValidAddrspace(this,vmap(addrspace_page));
        addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page))) ==
            KEV_PAGE_FREE();
        addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page))) ==
            KEV_PAGE_FREE();
    ensures
        MemValidityPreserving(old(this),this);
        sp == old(sp);
        StackValuePreserving(old(this),this,fcall_depth);

        addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page))) ==
            KEV_PAGE_ADDRSPACE();
        addrval(this, PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(addrspace_page))) ==
            vmap(addrspace_page);
        addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page))) ==
            KEV_PAGE_L1PTABLE();
        addrval(this, PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(l1pt_page))) ==
           vmap(addrspace_page);
        addrval(this, ADDRSPACE_L1PT(vmap(addrspace_page))) == vmap(l1pt_page);
        addrval(this, ADDRSPACE_L1PT_PHYS(vmap(addrspace_page))) == l1pt_page; 
        addrval(this, ADDRSPACE_REF(vmap(addrspace_page))) == 1;
        addrval(this, ADDRSPACE_STATE(vmap(addrspace_page))) ==
            KEV_ADDRSPACE_INIT();
{
   fcall_prologue(fcall_depth);

   r5 := addrspace_page;
   r6 := l1pt_page;

   phys2monvaddr(r1,r0,fcall_depth-1);
   r9 := r0;
   assert r9 == vmap(l1pt_page);

   r1 := r5;
   phys2monvaddr(r1,r0,fcall_depth-1);
   r10 := r0;
   assert r10 == vmap(addrspace_page);

   r0 := r5;
   r1 := r6;

   MUL(r7,r0,sp_op_const(PAGEDB_ENTRY_SIZE()));
   r7 += sp_op_const(G_PAGEDB());
   assert r7 == G_PAGEDB_ENTRY(addrspace_page);
   
   MUL(r8,r1,sp_op_const(PAGEDB_ENTRY_SIZE()));
   r8 += sp_op_const(G_PAGEDB());
   assert r8 == G_PAGEDB_ENTRY(l1pt_page);

   STR(sp_op_const(KEV_PAGE_ADDRSPACE()), r7, 0);
   assert addrval(this,PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page)))
       == KEV_PAGE_ADDRSPACE();
   STR(r10, r7, 4);
   assert addrval(this,PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(addrspace_page)))
       == vmap(addrspace_page);
   
   STR(sp_op_const(KEV_PAGE_L1PTABLE()), r8,0);
   assert addrval(this,PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page)))
       == KEV_PAGE_L1PTABLE();
   
   STR(r10, r8, 4);
   assert addrval(this,PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(l1pt_page)))
       == vmap(addrspace_page);

   STR(r9,r10,0);
   assert addrval(this,ADDRSPACE_L1PT(vmap(addrspace_page))) ==
       vmap(l1pt_page);

   STR(r1,r10,4);
   assert addrval(this,ADDRSPACE_L1PT_PHYS(vmap(addrspace_page))) == l1pt_page;

   STR(1,r10,8);
   assert addrval(this,ADDRSPACE_REF(vmap(addrspace_page))) == 1;

   STR(sp_op_const(KEV_ADDRSPACE_INIT()),r10,12);
   assert addrval(this,ADDRSPACE_STATE(vmap(addrspace_page))) ==
       KEV_ADDRSPACE_INIT();
   
   fcall_epilogue(fcall_depth-1);
}

procedure kev_smc_init_addrspace(
    {:register op_r(0)} addrspace_page:int,
    {:register op_r(1)} l1pt_page:int,
    out {:register op_r(3)} err:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        fcall_depth > 3;
        can_fcall_n(this,fcall_depth);
        ValidMemRange(this,G_PAGEDB(),G_PAGEDB_END());
        ValidAddrspace(this,vmap(addrspace_page));
        ValidMemIs32(this);
    requires
        addrspace_page != l1pt_page;
    ensures
        //RegPreserving(old(this),this);
        MemValidityPreserving(old(this),this); 
        sp == old(sp);
        StackValuePreserving(old(this),this,fcall_depth);

        !page_is_valid(addrspace_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
        !page_is_valid(l1pt_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
        !WordAligned(l1pt_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
        page_is_valid(addrspace_page) && page_is_valid(l1pt_page) && WordAligned(l1pt_page) &&
            (addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page))) !=
                KEV_PAGE_FREE()) ==> err == KEV_ERR_PAGEINUSE();
        page_is_valid(addrspace_page) && page_is_valid(l1pt_page) && WordAligned(l1pt_page) &&
            (addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page))) !=
                KEV_PAGE_FREE()) ==> err == KEV_ERR_PAGEINUSE();
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page))) ==
                KEV_PAGE_ADDRSPACE());
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(addrspace_page))) ==
                vmap(addrspace_page));
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page))) ==
                KEV_PAGE_L1PTABLE());
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(l1pt_page))) ==
                vmap(addrspace_page));
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_L1PT(vmap(addrspace_page))) ==
                vmap(l1pt_page)); 
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_L1PT_PHYS(vmap(addrspace_page))) ==
                l1pt_page); 
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_REF(vmap(addrspace_page))) == 1);
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_STATE(vmap(addrspace_page))) == KEV_ADDRSPACE_INIT());
{
    fcall_prologue(fcall_depth);

    assert 0 <= r1 < MaxVal();
    AND(r4,r1,3);
    assert r4 == r1 % 4;

    if( addrspace_page >= sp_op_const(KEVLAR_SECURE_NPAGES()) ) { 
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if( addrspace_page < 0 ) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if( l1pt_page >= sp_op_const(KEVLAR_SECURE_NPAGES()) ) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if( addrspace_page < 0 ) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if( r4 != 0 ) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else { 
        assert WordAligned(l1pt_page);
        MUL(r7,r0,sp_op_const(PAGEDB_ENTRY_SIZE()));
        r7 += sp_op_const(G_PAGEDB());
        LDR(r7,r7,0);
        assert r7 == addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page)));

        MUL(r8,r1,sp_op_const(PAGEDB_ENTRY_SIZE()));
        r8 += sp_op_const(G_PAGEDB());
        LDR(r8,r8,0);
        assert r8 == addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page)));

        if( r7 != sp_op_const(KEV_PAGE_FREE()) ) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else if( r8 != sp_op_const(KEV_PAGE_FREE()) ) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else {
            kev_smc_init_addrspace_success(r0,r1,err,fcall_depth-1);
            
            err := OConst(KEV_ERR_SUCCESS());
        }

    }
    assert ValidState(this);
    fcall_epilogue(fcall_depth-1);
}

procedure smc_handler(
    {:register op_r(4)} callno:int,
    {:register op_r(0)} arg1:int,
    {:register op_r(1)} arg2:int,
    {:register op_r(2)} arg3:int,
    {:register op_r(3)} arg4:int,
    out {:register op_r(11)} err:int,
    out {:register op_r(12)} retval:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
        fcall_depth > 20;
        can_fcall_n(this,fcall_depth);
    requires
        ValidMemRange(this,G_PAGEDB(),G_PAGEDB_END());
        callno == KEV_SMC_INIT_ADDRSPACE() ==>
            ValidMemRange(this,arg1,arg1+KEVLAR_PAGE_SIZE()) &&
            ValidMemRange(this,arg2,arg2+KEVLAR_PAGE_SIZE()) &&
            // TODO violating these precond should throw errors. We shouldn't
            // assume trusted code won't violate them.
            (arg1 != arg2) &&
            //WordAligned(arg2) && // TODO REMOVE ME
            (G_PAGEDB() <= arg1 < G_PAGEDB_END()) &&
            (G_PAGEDB() <= arg2 < G_PAGEDB_END()) &&
            ValidAddrspace(this,vmap(arg1)); // && 
            // ValidMemRange(this,vmap(arg1),vmap(arg1)*ADDRSPACE_SIZE());

            // !(STACK_LOWER() <= arg1 < STACK_UPPER()) &&
            // !(STACK_LOWER() <= arg2 < STACK_UPPER());
{
    
    retval := 0;
    
    if(callno == sp_op_const(KEV_SMC_QUERY())) {
        err := sp_op_const(KEV_MAGIC());
    } else if(callno == sp_op_const(KEV_SMC_GETPHYSPAGES())) {
        retval := sp_op_const(KEVLAR_SECURE_NPAGES());
        err := sp_op_const(KEV_ERR_SUCCESS());
    } else if(callno == sp_op_const(KEV_SMC_INIT_ADDRSPACE())) {
        kev_smc_init_addrspace(arg1, arg2, r3, fcall_depth);
        err := r3;
    }

}

procedure main(){}

#verbatim

method Main()
{
  printHeader();
  var n := printCode(sp_code_main(), 0);
  printFooter();
}
#endverbatim
