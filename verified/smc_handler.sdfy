#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

#verbatim
predicate page_is_valid(page:int)
{
    0 <= page < KEVLAR_SECURE_NPAGES()
}

function vmap(phys:int):int
{
    phys + KEVLAR_DIRECTMAP_VBASE()
}

predicate ValidAddrspace(s:state,base:int)
{
    ValidMem(s,Address(ADDRSPACE_L1PT(base))) &&
    ValidMem(s,Address(ADDRSPACE_L1PT_PHYS(base))) &&
    ValidMem(s,Address(ADDRSPACE_REF(base))) &&
    ValidMem(s,Address(ADDRSPACE_STATE(base)))
}

#endverbatim

// procedure phys2monvaddr({:operand} phys:int, out {:operand} virt:int)
//     requires/ensures
//         ValidState(this);
//         ValidStack(this);
//         ValidOperand(this,@phys);
//         ValidDestinationOperand(this,@virt);
//         isUInt32(virt);
//     requires
//         isUInt32(KEVLAR_DIRECTMAP_VBASE()+phys);
//         isUInt32(phys);
//     ensures
//         virt == old(KEVLAR_DIRECTMAP_VBASE() + phys);
//         MemValidityPreserving(old(this),this);
//         MemValuePreserving(old(this),this);
// {
//     ADD(virt,KEVLAR_DIRECTMAP_VBASE(),phys);
// }

//This is not quite the same as std::memset
procedure memset({:register op_r(0)} lower:int, {:register op_r(1)} upper:int,
    {:register op_r(2)} val:int, ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemRange(this,lower,upper);
        ValidMemIs32(this);
        fcall_depth > 1;
        can_fcall_n(this,fcall_depth);
    requires
        lower < upper;
        lower >= STACK_UPPER() || upper < STACK_LOWER();
    ensures
        MemValidityPreserving(old(this),this);
        forall i:int :: old(lower) <= i < old(upper) ==>
            addrval(this,i) == old(val);
        forall i:int :: !(old(lower) <= i < old(upper)) &&
            !(STACK_LOWER() <= i < STACK_UPPER()) &&
            ValidMem(old(this),Address(i)) ==>
                addrval(this,i) == addrval(old(this),i);
        RegPreserving(old(this),this);
        StackValuePreserving(old(this),this,fcall_depth);
        r0 == old(r0);
        r1 == old(r1);
        r2 == old(r2);

{
    fcall_prologue(fcall_depth);

    ghost var loop_old_sp := sp;
    ghost var pre_loop_s := this;

    assert upper == old(upper);
    assert upper == r1;

    for (r9 := lower; r9 < upper; r9++)
        invariant
            ValidState(this);
            ValidStack(this);
            ValidMemIs32(this);
            sp == loop_old_sp;
            MemValidityPreserving(old(this),pre_loop_s);
            MemValidityPreserving(pre_loop_s,this);
            ValidMemRange(old(this),lower,upper);
            StackValuePreserving(pre_loop_s,this,fcall_depth-1);
            can_fcall_n(this,fcall_depth-1);
            
            r0 == old(lower);
            r1 == old(upper);
            r2 == old(val);
            lower < upper;
            lower <= r9 <= upper;
            lower >= STACK_UPPER() || upper < STACK_LOWER();
            
            forall i:int :: lower <= i < r9 ==>
                addrval(this,i) == val;
            forall i:int :: !(lower <= i < r9 ) && 
                !(STACK_LOWER() <= i < STACK_UPPER()) &&
                ValidMem(pre_loop_s,Address(i)) ==>
                    addrval(this,i) == addrval(pre_loop_s,i);

        decreases
            upper - r9;
    {
        STR(r2, r9, 0);
    }
            
    fcall_epilogue(fcall_depth-1);
}

//loads the address of the G_PAEDB entry for pageno into entry
procedure pagedb_entry(
    {:register op_r(0)} pageno:int,
    out {:register op_r(1)} entry:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
        fcall_depth > 1;
        can_fcall_n(this,fcall_depth);
        0 <= pageno < KEVLAR_SECURE_NPAGES();
    ensures
        RegPreserving(old(this),this);
        MemValidityPreserving(old(this),this);
        NonStackValuePreserving(old(this),this);
        StackValuePreserving(old(this),this,fcall_depth);
        entry == G_PAGEDB_ENTRY(pageno);
        G_PAGEDB() <= entry < G_PAGEDB_END();
{
    fcall_prologue(fcall_depth);
    entry := sp_op_const(G_PAGEDB());

    ghost var loop_old_sp := sp;
    ghost var pre_loop_s := this;
    for (r9:= 0; r9 < pageno; r9++)
      invariant
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
        0 <= pageno < KEVLAR_SECURE_NPAGES();
        0 <= r9 <= pageno;
        r0 == old(pageno);
        entry == G_PAGEDB_ENTRY(r9);

        // Allows fcall_epilogue;
        can_fcall_n(this,fcall_depth-1);

        //All other postconditions
        MemValidityPreserving(pre_loop_s,this);
        MemValuePreserving(pre_loop_s,this);
        sp  == loop_old_sp;
      decreases
        pageno - r9;
    {
        ADD(entry, entry, sp_op_const(PAGEDB_ENTRY_SIZE()));
    }
    
    fcall_epilogue(fcall_depth-1); 
    assert r9 == old(r9);
    assert sp == old(sp);
}

procedure page_type(
    {:register op_r(0)} pageno:int,
    out {:register op_r(1)} pgtype:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
        fcall_depth > 2;
        can_fcall_n(this,fcall_depth);
        0 <= pageno < KEVLAR_SECURE_NPAGES();
        ValidMemRange(this,G_PAGEDB(),G_PAGEDB_END());
    ensures
        pgtype == addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(old(r0))));
        RegPreserving(old(this),this);
        MemValidityPreserving(old(this),this);
        NonStackValuePreserving(old(this),this);
        StackValuePreserving(old(this),this,fcall_depth);
        
{
    // not doing fcall because no local var regs were harmed
    fcall_prologue(fcall_depth);
    pagedb_entry(pageno,pgtype,fcall_depth-1);
    LDR(pgtype,pgtype,0);
    fcall_epilogue(fcall_depth-1);
}

procedure kev_smc_init_addrspace(
    {:register op_r(0)} addrspace_page:int,
    {:register op_r(1)} l1pt_page:int,
    out {:register op_r(3)} err:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        fcall_depth > 3;
        can_fcall_n(this,fcall_depth);
        ValidMemRange(this,G_PAGEDB(),G_PAGEDB_END());
        ValidAddrspace(this,vmap(addrspace_page));
        // ValidMemRange(this,vmap(addrspace_page),vmap(addrspace_page)*ADDRSPACE_SIZE());
        ValidMemIs32(this);
    requires
        addrspace_page != l1pt_page;
        // G_PAGEDB() <= addrspace_page < G_PAGEDB_END();
        // G_PAGEDB() <= l1pt_page < G_PAGEDB_END();
        // !(STACK_LOWER() <= addrspace_page < STACK_UPPER());
        // !(STACK_LOWER() <= l1pt_page < STACK_UPPER());
    ensures
        MemValidityPreserving(old(this),this); 
        //(old(addrspace_page) >= KEVLAR_SECURE_NPAGES()) ==>
        !page_is_valid(addrspace_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
        !page_is_valid(addrspace_page) ==>
            err == KEV_ERR_INVALID_PAGENO();
        page_is_valid(addrspace_page) && page_is_valid(l1pt_page) &&
            (addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page))) !=
                KEV_PAGE_FREE()) ==> err == KEV_ERR_PAGEINUSE();
        page_is_valid(addrspace_page) && page_is_valid(l1pt_page) &&
            (addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page))) !=
                KEV_PAGE_FREE()) ==> err == KEV_ERR_PAGEINUSE();
        err == KEV_ERR_SUCCESS() ==> page_is_valid(addrspace_page);
        err == KEV_ERR_SUCCESS() ==> page_is_valid(l1pt_page);
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page))) ==
                KEV_PAGE_ADDRSPACE());
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(addrspace_page))) ==
                vmap(addrspace_page));
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page))) ==
                KEV_PAGE_L1PTABLE());
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(l1pt_page))) ==
                vmap(addrspace_page));
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_L1PT(vmap(addrspace_page))) ==
                vmap(l1pt_page)); 
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_L1PT_PHYS(vmap(addrspace_page))) ==
                l1pt_page); 
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_REF(vmap(addrspace_page))) == 1);
        err == KEV_ERR_SUCCESS() ==>
            (addrval(this, ADDRSPACE_STATE(vmap(addrspace_page))) == KEV_ADDRSPACE_INIT());
{
    fcall_prologue(fcall_depth);
    ghost var saved_s := this;

    if( addrspace_page >= sp_op_const(KEVLAR_SECURE_NPAGES()) ) { 
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if( addrspace_page < 0 ) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if( l1pt_page >= sp_op_const(KEVLAR_SECURE_NPAGES()) ) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if( addrspace_page < 0 ) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else {  
        r5 := addrspace_page;
        r6 := l1pt_page;

        page_type(addrspace_page,r1,fcall_depth-1);
        r7 := r1;
        assert r7 == addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page)));

        r0 := r6;
        assert r0 == old(l1pt_page);
        page_type(r0,r1,fcall_depth-1);
        r8 := r1;
        assert r8 == addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page)));

        if( r7 != sp_op_const(KEV_PAGE_FREE()) ) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else if( r8 != sp_op_const(KEV_PAGE_FREE()) ) {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        } else {
            // assert ValidMemRange(this,G_PAGEDB(),G_PAGEDB_END());
            assert page_is_valid(addrspace_page) && page_is_valid(l1pt_page);
            assert addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page))) ==
                KEV_PAGE_FREE();
            assert addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page))) ==
                KEV_PAGE_FREE();

            //TODO check word-alignment.

            ADD(r9, r6, sp_op_const(KEVLAR_DIRECTMAP_VBASE()));
            assert r9 == vmap(l1pt_page);

            ADD(r10, r5, sp_op_const(KEVLAR_DIRECTMAP_VBASE()));
            assert r10 == vmap(addrspace_page);

            r0 := r5;
            pagedb_entry(r0,r1,fcall_depth-1);
            r7 := r1;
            assert r7 == G_PAGEDB_ENTRY(addrspace_page);
            
            r0 := r6;
            pagedb_entry(r0,r1,fcall_depth-1);
            r8 := r1;
            assert r8 == G_PAGEDB_ENTRY(l1pt_page);

            STR(sp_op_const(KEV_PAGE_ADDRSPACE()), r7, 0);
            assert addrval(this,PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page)))
                == KEV_PAGE_ADDRSPACE();
            STR(r10, r7, 1);
            assert addrval(this,PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(addrspace_page)))
                == vmap(addrspace_page);
            
            STR(sp_op_const(KEV_PAGE_L1PTABLE()), r8,0);
            assert addrval(this,PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(l1pt_page)))
                == KEV_PAGE_L1PTABLE();
            
            STR(r10, r8, 1);
            assert addrval(this,PAGEDB_ENTRY_ADDRSPACE(G_PAGEDB_ENTRY(l1pt_page)))
                == vmap(addrspace_page);

            STR(r9,r10,0);
            assert addrval(this,ADDRSPACE_L1PT(vmap(addrspace_page))) ==
                vmap(l1pt_page);

            STR(r6,r10,1);
            assert addrval(this,ADDRSPACE_L1PT_PHYS(vmap(addrspace_page))) == l1pt_page;

            STR(1,r10,2);
            assert addrval(this,ADDRSPACE_REF(vmap(addrspace_page))) == 1;

            STR(sp_op_const(KEV_ADDRSPACE_INIT()),r10,3);
            assert addrval(this,ADDRSPACE_STATE(vmap(addrspace_page))) ==
                KEV_ADDRSPACE_INIT();
           
            err := sp_op_const(KEV_ERR_SUCCESS());
        }

    }
    assert ValidState(this);
    fcall_epilogue(fcall_depth-1);
}

procedure smc_handler(
    {:register op_r(4)} callno:int,
    {:register op_r(0)} arg1:int,
    {:register op_r(1)} arg2:int,
    {:register op_r(2)} arg3:int,
    {:register op_r(3)} arg4:int,
    out {:register op_r(11)} err:int,
    out {:register op_r(12)} retval:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
        fcall_depth > 20;
        can_fcall_n(this,fcall_depth);
    requires
        ValidMemRange(this,G_PAGEDB(),G_PAGEDB_END());
        callno == KEV_SMC_INIT_ADDRSPACE() ==>
            ValidMemRange(this,arg1,arg1+KEVLAR_PAGE_SIZE()) &&
            ValidMemRange(this,arg2,arg2+KEVLAR_PAGE_SIZE()) &&
            // TODO violating these precond should throw errors. We shouldn't
            // assume trusted code won't violate them.
            (arg1 != arg2) &&
            (G_PAGEDB() <= arg1 < G_PAGEDB_END()) &&
            (G_PAGEDB() <= arg2 < G_PAGEDB_END()) &&
            ValidAddrspace(this,vmap(arg1)); // && 
            // ValidMemRange(this,vmap(arg1),vmap(arg1)*ADDRSPACE_SIZE());

            // !(STACK_LOWER() <= arg1 < STACK_UPPER()) &&
            // !(STACK_LOWER() <= arg2 < STACK_UPPER());
{
    
    retval := 0;
    
    if(callno == sp_op_const(KEV_SMC_QUERY())) {
        err := sp_op_const(KEV_MAGIC());
    } else if(callno == sp_op_const(KEV_SMC_GETPHYSPAGES())) {
        retval := sp_op_const(KEVLAR_SECURE_NPAGES());
        err := sp_op_const(KEV_ERR_SUCCESS());
    } else if(callno == sp_op_const(KEV_SMC_INIT_ADDRSPACE())) {
        kev_smc_init_addrspace(arg1, arg2, r3, fcall_depth);
        err := r3;
    }

}

procedure main(){}

#verbatim

method Main()
{
  printHeader();
  var n := printCode(sp_code_main(), 0);
  printFooter();
}
#endverbatim
