#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

#verbatim
predicate page_is_valid(page:int)
{
    0 <= page < KEVLAR_SECURE_NPAGES()
}

predicate vmap(virt:int,phys:int)
{
    virt == phys + KEVLAR_DIRECTMAP_VBASE()
}

#endverbatim

// procedure phys2monvaddr({:operand} phys:int, out {:operand} virt:int)
//     requires/ensures
//         ValidState(this);
//         ValidStack(this);
//         ValidOperand(this,@phys);
//         ValidDestinationOperand(this,@virt);
//         isUInt32(virt);
//     requires
//         isUInt32(KEVLAR_DIRECTMAP_VBASE()+phys);
//         isUInt32(phys);
//     ensures
//         virt == old(KEVLAR_DIRECTMAP_VBASE() + phys);
//         MemValidityPreserving(old(this),this);
//         MemValuePreserving(old(this),this);
// {
//     ADD(virt,KEVLAR_DIRECTMAP_VBASE(),phys);
// }

//This is not quite the same as std::memset
procedure memset({:register op_r(0)} lower:int, {:register op_r(1)} upper:int,
    {:register op_r(2)} val:int, ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemRange(this,lower,upper);
        fcall_depth > 1;
        can_fcall_n(this,fcall_depth);
    requires
        lower < upper;
        lower >= STACK_UPPER() || upper < STACK_LOWER();
    ensures
        MemValidityPreserving(old(this),this);
        forall i:int :: old(lower) <= i < old(upper) ==>
            addrval(this,i) == old(val);
        forall i:int :: !(old(lower) <= i < old(upper)) &&
            ValidMem(old(this),Address(i)) ==>
                addrval(this,i) == addrval(old(this),i);
        RegPreserving(old(this),this);
        StackValuePreserving(old(this),this,fcall_depth);
        r0 == old(r0);
        r1 == old(r1);
        r2 == old(r2);

{
    fcall_prologue(fcall_depth);

    ghost var loop_old_sp := sp;
    ghost var pre_loop_s := this;

    assert upper == old(upper);
    assert upper == r1;

    for (r9 := lower; r9 < upper; r9++)
        invariant
            ValidState(this);
            ValidStack(this);
            sp == loop_old_sp;
            MemValidityPreserving(old(this),this);
            MemValidityPreserving(pre_loop_s,this);
            StackValuePreserving(pre_loop_s,this,fcall_depth-1);
            can_fcall_n(this,fcall_depth-1);
            
            ValidMemRange(this,lower,r9);
            forall i:int :: lower <= i < r9 ==>
                addrval(this,i) == val;
            forall i:int :: !(lower <= i < upper) && ValidMem(old(this),Address(i))==>
                addrval(this,i) == addrval(old(this),i);

            r0 == old(lower);
            r1 == old(upper);
            r2 == old(val);
            lower < upper;
            lower <= r9 <= upper;
        decreases
            upper - r9;
    {
        STR(r2, r9, 0);
    }
            
    fcall_epilogue(fcall_depth-1);
}

//loads the address of the G_PAEDB entry for pageno into entry
procedure pagedb_entry(
    {:register op_r(0)} pageno:int,
    out {:register op_r(1)} entry:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        fcall_depth > 1;
        can_fcall_n(this,fcall_depth);
        0 <= pageno < KEVLAR_SECURE_NPAGES();
    ensures
        RegPreserving(old(this),this);
        MemValidityPreserving(old(this),this);
        NonStackValuePreserving(old(this),this);
        StackValuePreserving(old(this),this,fcall_depth);
        //The important part
        entry == G_PAGEDB_ENTRY(pageno);
        G_PAGEDB() <= entry < G_PAGEDB_END();
{
    fcall_prologue(fcall_depth);
    entry := G_PAGEDB();

    ghost var loop_old_sp := sp;
    ghost var pre_loop_s := this;
    for (r9:= 0; r9 < pageno; r9++)
      invariant
        ValidState(this);
        ValidStack(this);
        0 <= pageno < KEVLAR_SECURE_NPAGES();
        0 <= r9 <= pageno;
        r0 == old(pageno); // generates different dafny with pageno == old(pageno) !!
        entry == G_PAGEDB_ENTRY(r9);

        // Allows fcall_epilogue;
        can_fcall_n(this,fcall_depth-1);

        //All other postconditions
        MemValidityPreserving(pre_loop_s,this);
        MemValuePreserving(pre_loop_s,this);
        sp  == loop_old_sp;
      decreases
        pageno - r9;
    {
        ADD(entry, entry, PAGEDB_ENTRY_SIZE());
    }
    
    fcall_epilogue(fcall_depth-1); 
    assert r9 == old(r9);
    assert sp == old(sp);
}

procedure page_type(
    {:register op_r(0)} pageno:int,
    out {:register op_r(1)} pgtype:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        fcall_depth > 2;
        can_fcall_n(this,fcall_depth);
        0 <= pageno < KEVLAR_SECURE_NPAGES();
        ValidMemRange(this,G_PAGEDB(),G_PAGEDB_END());
        MemRangeIs32(this,G_PAGEDB(),G_PAGEDB_END());
    ensures
        pgtype == addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(old(r0))));
        RegPreserving(old(this),this);
        MemValidityPreserving(old(this),this);
        NonStackValuePreserving(old(this),this);
        StackValuePreserving(old(this),this,fcall_depth);
        
{
    // not doing fcall because no local var regs were harmed
    fcall_prologue(fcall_depth);
    pagedb_entry(pageno,pgtype,fcall_depth-1);
    LDR(pgtype,pgtype,0);
    fcall_epilogue(fcall_depth-1);
}

procedure kev_smc_init_addrspace(
    {:register op_r(0)} addrspace_page:int,
    {:register op_r(1)} l1pt_page:int,
    out {:register op_r(3)} err:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        fcall_depth > 3;
        can_fcall_n(this,fcall_depth);
        ValidMemRange(this,G_PAGEDB(),G_PAGEDB_END());
        MemRangeIs32(this,G_PAGEDB(),G_PAGEDB_END());
        ValidMemRange(this,addrspace_page,addrspace_page+KEVLAR_PAGE_SIZE());
        ValidMemRange(this,l1pt_page,l1pt_page+KEVLAR_PAGE_SIZE());
    ensures
        //(old(addrspace_page) >= KEVLAR_SECURE_NPAGES()) ==>
        !page_is_valid(old(addrspace_page)) ==>
            err == KEV_ERR_INVALID_PAGENO();
        !page_is_valid(old(addrspace_page)) ==>
            err == KEV_ERR_INVALID_PAGENO();
        page_is_valid(old(addrspace_page)) && page_is_valid(old(l1pt_page)) &&
            (addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(old(addrspace_page)))) !=
                KEV_PAGE_FREE()) ==> err == KEV_ERR_PAGEINUSE();
        page_is_valid(old(addrspace_page)) && page_is_valid(old(l1pt_page)) &&
            (addrval(old(this),PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(old(l1pt_page)))) !=
                KEV_PAGE_FREE()) ==> err == KEV_ERR_PAGEINUSE();
        
{
    fcall_prologue(fcall_depth);
    err := 0;

    if( addrspace_page >= KEVLAR_SECURE_NPAGES() ) { 
        err := KEV_ERR_INVALID_PAGENO();
    } else if( addrspace_page < 0 ) {
        err := KEV_ERR_INVALID_PAGENO();
    } else if( l1pt_page >= KEVLAR_SECURE_NPAGES() ) {
        err := KEV_ERR_INVALID_PAGENO();
    } else if( addrspace_page < 0 ) {
        err := KEV_ERR_INVALID_PAGENO();
    } else {  
        r5 := addrspace_page;
        r6 := l1pt_page;

        page_type(addrspace_page,r1,fcall_depth-1);
        r7 := r1;
        assert r7 == addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(old(addrspace_page))));

        r0 := r6;
        assert r0 == old(l1pt_page);
        page_type(r0,r1,fcall_depth-1);
        r8 := r1;
        assert r8 == addrval(this, PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(old(l1pt_page))));

        if( r7 != KEV_PAGE_FREE() ) {
            err := KEV_ERR_PAGEINUSE();
        } else if( r8 != KEV_PAGE_FREE() ) {
            err := KEV_ERR_PAGEINUSE();
        } else {
            assert r5 < KEVLAR_SECURE_NPAGES();
            assert r5 >= 0;
            assert isUInt32(KEVLAR_SECURE_NPAGES() + KEVLAR_PAGE_SIZE());

            r0 := r5;
            ADD(r1,r0,KEVLAR_PAGE_SIZE());
            r2 := 0;
            assert r0 == old(addrspace_page);
            
            assert ValidMemRange(this,r0,r1);
            ghost var r0_saved := r0;
            ghost var r1_saved := r1;
            memset(r0,r1,r2,fcall_depth-1);
            assert ValidMemRange(this,r0,r1);
            assert forall i:int :: r0 <= i < r1 ==> addrval(this,i) == r2;

            // r0 := r6;
            // ADD(r1,r0,KEVLAR_PAGE_SIZE());
            // memset(r0,r1,r2,fcall_depth-1);

        }

    }

    fcall_epilogue(fcall_depth-1);
}

procedure smc_handler(
    {:register op_r(4)} callno:int,
    {:register op_r(0)} arg1:int,
    {:register op_r(1)} arg2:int,
    {:register op_r(2)} arg3:int,
    {:register op_r(3)} arg4:int,
    out {:register op_r(11)} err:int,
    out {:register op_r(12)} retval:int,
    ghost fcall_depth:int)
    requires/ensures
        ValidState(this);
        fcall_depth > 20;
        can_fcall_n(this,fcall_depth);
    requires
        ValidMemRange(this,G_PAGEDB(),G_PAGEDB_END());
        MemRangeIs32(this,G_PAGEDB(),G_PAGEDB_END());
        callno == KEV_SMC_INIT_ADDRSPACE() ==>
            ValidMemRange(this,arg1,arg1+KEVLAR_PAGE_SIZE()) &&
            ValidMemRange(this,arg2,arg2+KEVLAR_PAGE_SIZE());
{
    
    retval := 0;
    
    if(callno == KEV_SMC_QUERY()) {
        err := KEV_MAGIC();
    } else if(callno == KEV_SMC_GETPHYSPAGES()) {
        retval := KEVLAR_SECURE_NPAGES();
        err := KEV_ERR_SUCCESS();
    } else if(callno == KEV_SMC_INIT_ADDRSPACE()) {
        kev_smc_init_addrspace(arg1, arg2, r3, fcall_depth);
        err := r3;
    }

}

procedure main(){}

#verbatim

method Main()
{
  printHeader();
  var n := printCode(sp_code_main(), 0);
  printFooter();
}
#endverbatim
