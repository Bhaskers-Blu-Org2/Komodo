#token += precedence :=
procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

#verbatim
/*
lemma valid_pagenr_ensures_valid_mem(s:state, pagenr: int)
      requires SaneState(s)
      requires validPageNr(pagenr)
      ensures ValidMemRange(s, page_monvaddr(s, pagenr), page_monvaddr(s, pagenr) + KEVLAR_PAGE_SIZE())
{}
*/

function page_paddr(pagenr:PageNr):int
    requires validPageNr(pagenr)
    ensures WordAligned(page_paddr(pagenr))
{
    SecurePhysBaseValue() + KEVLAR_PAGE_SIZE() * pagenr
}

function page_monvaddr(pagenr:PageNr):int
    requires validPageNr(pagenr)
    ensures WordAligned(page_monvaddr(pagenr))
{
    page_paddr(pagenr) + KEVLAR_DIRECTMAP_VBASE()
}

function addrsInPage(p:PageNr): set<mem>
    requires validPageNr(p)
{
    (set o:int | WordAligned(o) && 0 <= o < KEVLAR_PAGE_SIZE()
         :: Address(page_monvaddr(p) + o))
}

function addrsInSecurePages(): set<mem>
{
    (set o:int | WordAligned(o) && 0 <= o < KEVLAR_SECURE_RESERVE()
         :: Address(page_monvaddr(0) + o))
}

predicate memContainsPage(memmap: map<mem, int>, p:PageNr)
    requires validPageNr(p)
{
    forall m:mem :: m in addrsInPage(p) ==> m in memmap
}

function extractPageDbEntry(s:state, p:PageNr): seq<int>
    requires SaneState(s)
    requires validPageNr(p)
    ensures |extractPageDbEntry(s,p)| == PAGEDB_ENTRY_SIZE()/BytesPerWord()
    ensures forall o :: WordAligned(o) && 0 <= o < PAGEDB_ENTRY_SIZE()
        ==> GlobalWord(s, PageDb(), G_PAGEDB_ENTRY(p) + o)
            == extractPageDbEntry(s,p)[o / BytesPerWord()]
{
    var dbofstate := GlobalFullContents(s, PageDb());
    assert |dbofstate| == G_PAGEDB_SIZE() / BytesPerWord();
    var entrylen := PAGEDB_ENTRY_SIZE() / BytesPerWord();
    dbofstate[p*entrylen..p*entrylen+entrylen]
}

function extractPageDbEntryFromValue(dbval: seq<int>, p:PageNr): seq<int>
    requires validPageNr(p)
    requires |dbval| == G_PAGEDB_SIZE() / BytesPerWord()
    ensures |extractPageDbEntryFromValue(dbval,p)| == PAGEDB_ENTRY_SIZE()/BytesPerWord()
{
    var entrylen := PAGEDB_ENTRY_SIZE() / BytesPerWord();
    dbval[p*entrylen..p*entrylen+entrylen]
}

function extractPage(s:state, p:PageNr): map<mem, int>
    requires SaneState(s)
    requires validPageNr(p)
    ensures memContainsPage(extractPage(s,p), p)
{
    (map m:mem | m in addrsInPage(p) :: s.addresses[m])
}

function extractPages(memmap: map<mem, int>): map<mem, int>
    requires SaneMemRanges(memmap)
    ensures forall p :: validPageNr(p) ==> addrsInPage(p) < addrsInSecurePages()
    ensures forall p :: validPageNr(p) ==> memContainsPage(extractPages(memmap), p)
{
    (map m:mem | m in addrsInSecurePages() :: memmap[m])
}

predicate pageDbCorresponds(s:state, pagedb:PageDb)
    requires SaneState(s)
    requires pageDbClosedRefs(pagedb)
{
    // XXX: unpack the entry and page contents to help dafny see
    // that we have no other dependencies on the state
    var dbofstate := GlobalFullContents(s, PageDb());
    var secpages := extractPages(s.addresses);
    forall p {:trigger validPageNr(p)} :: validPageNr(p)
        ==> (pageDbEntryCorresponds(p, pagedb[p], extractPageDbEntryFromValue(dbofstate, p))
            && pageContentsCorresponds(p, pagedb[p], secpages))
}

predicate pageDbCorrespondsExcluding(s:state, pagedb:PageDb, modifiedPage:PageNr)
    requires SaneState(s)
    requires pageDbClosedRefs(pagedb)
{
    forall p {:trigger validPageNr(p)} :: validPageNr(p) && p != modifiedPage
        ==> (pageDbEntryCorresponds(p, pagedb[p], extractPageDbEntry(s, p))
            && pageContentsCorresponds(p, pagedb[p], extractPage(s, p)))
}

predicate pageDbCorrespondsOnly(s:state, pagedb:PageDb, p:PageNr)
    requires SaneState(s)
    requires pageDbClosedRefs(pagedb)
    requires validPageNr(p)
{
    pageDbEntryCorresponds(p, pagedb[p], extractPageDbEntry(s, p))
    && pageContentsCorresponds(p, pagedb[p], extractPage(s, p))
}

predicate {:opaque} pageDbEntryCorresponds(p:PageNr, e:PageDbEntry, entryWords:seq<int>)
    requires validPageNr(p)
    requires |entryWords| == PAGEDB_ENTRY_SIZE()/BytesPerWord()
    requires e.PageDbEntryTyped?
        ==> validPageNr(e.addrspace) && closedRefsPageDbEntry(e.entry)
{
    pageDbEntryTypeVal(e) == entryWords[PAGEDB_ENTRY_TYPE() / BytesPerWord()]
    && match e {
        case PageDbEntryFree => true
        case PageDbEntryTyped(addrspace, entry) =>
            entryWords[PAGEDB_ENTRY_ADDRSPACE()/BytesPerWord()]
                == page_monvaddr(addrspace)
    }
}

predicate {:opaque} pageContentsCorresponds(p:PageNr, e:PageDbEntry, page:map<mem, int>)
    requires validPageNr(p)
    requires memContainsPage(page, p)
    requires e.PageDbEntryFree? || closedRefsPageDbEntry(e.entry)
{
    e.PageDbEntryFree? || (e.PageDbEntryTyped? && (
        var et := e.entry;
        (et.Addrspace? && pageDbAddrspaceCorresponds(p, et, page))
        || (et.Dispatcher? /* && pageDbDispatcherCorresponds(p, et, page) */)
        || (et.L1PTable? /* && pageDbL1PTableCorresponds(p, et, page) */)
        || (et.L2PTable? /* && pageDbL2PTableCorresponds(p, et, page) */)
        || et.DataPage?))
}

predicate pageDbAddrspaceCorresponds(p:PageNr, e:PageDbEntryTyped, page:map<mem, int>)
    requires validPageNr(p)
    requires memContainsPage(page, p)
    requires e.Addrspace?
    requires closedRefsPageDbEntry(e)
{
    var base := page_monvaddr(p);
    page[Address(ADDRSPACE_L1PT(base))] == page_monvaddr(e.l1ptnr)
    && page[Address(ADDRSPACE_L1PT_PHYS(base))] == page_paddr(e.l1ptnr)
    && page[Address(ADDRSPACE_REF(base))] == e.refcount
    && page[Address(ADDRSPACE_STATE(base))] == pageDbAddrspaceStateVal(e.state)
}

function pageDbEntryTypeVal(e: PageDbEntry): int
    ensures isUInt32(pageDbEntryTypeVal(e))
{
    if e.PageDbEntryFree? then KEV_PAGE_FREE()
    else match e.entry {
    case Addrspace(l1pt, ref, state) => KEV_PAGE_ADDRSPACE()
    case Dispatcher(ep, entered) => KEV_PAGE_DISPATCHER()
    case L1PTable(pt) => KEV_PAGE_L1PTABLE()
    case L2PTable(pt) => KEV_PAGE_L2PTABLE()
    case DataPage => KEV_PAGE_DATA()
    }
}

function pageDbAddrspaceStateVal(s: AddrspaceState): int
    ensures isUInt32(pageDbAddrspaceStateVal(s))
{
    match s {
    case InitState => KEV_ADDRSPACE_INIT()
    case FinalState => KEV_ADDRSPACE_FINAL()
    case StoppedState => KEV_ADDRSPACE_STOPPED()
    }
}

#endverbatim

procedure page_paddr_impl(out {:operand} phys:int, {:operand} pagenr:int, out {:operand} tmp:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@phys);
        ValidRegOperand(@pagenr);
        ValidRegOperand(@tmp);
        // NB: @phys == @pagenr is supported
        @phys != @tmp;
        @pagenr != @tmp;
        @phys != op_sp();
        @tmp != op_sp();
        validPageNr(pagenr);
    ensures
        AlwaysInvariant(old(this),this);
        AllMemInvariant(old(this),this);
        RegPreservingExcept(old(this), this, [@phys, @tmp]);
        phys == page_paddr(old(pagenr));
{
    tmp := sp_op_const(KEVLAR_PAGE_SIZE());
    MUL(phys,pagenr,tmp);
    // LSL(phys, pagenr, sp_op_const(KEVLAR_PAGE_SHIFT()));
    assert phys == old(pagenr) * KEVLAR_PAGE_SIZE();

    LDRglobaladdr(tmp, SecurePhysBase());
    LDRglobal(tmp, SecurePhysBase(), tmp, 0);
    assert WordAligned(tmp);
    phys += tmp;
}

procedure page_monvaddr_impl(out {:operand} virt:int, {:operand} pagenr:int, out {:operand} tmp:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@virt);
        ValidRegOperand(@pagenr);
        ValidRegOperand(@tmp);
        // NB: @pagenr == @virt is supported
        @pagenr != @tmp;
        @virt != @tmp;
        @virt != op_sp();
        @tmp != op_sp();
        validPageNr(pagenr);
    ensures
        AlwaysInvariant(old(this),this);
        AllMemInvariant(old(this),this);
        RegPreservingExcept(old(this), this, [@virt, @tmp]);
        virt == page_monvaddr(old(pagenr));
{
    page_paddr_impl(virt, pagenr, tmp);
    virt += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
}

procedure memset(inout {:operand} base:int, {:operand} val:int, inout {:operand} size:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@base);
        ValidRegOperand(@size);
        ValidRegOperand(@val);
        @base != @size;
        @base != @val;
        @size != @val;
        @base != @sp;
        @val != @sp;
        @size != @sp;
        WordAligned(base);
        WordAligned(size);
        isUInt32(val);
        isUInt32(base + size);
        ValidMemRange(this.m, base, base + size);
        base >= StackBase() || base + size <= StackLimit();
    ensures
        AlwaysInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this), this, [@base,@size]);
        MemPreservingExcept(old(this), this, old(base), old(base + size));
        forall i :: old(base) <= i < old(base + size) && WordAligned(i)
            ==> addrval(this,i) == old(val);
{
    ghost var lower := base;
    ghost var limit := base + size;

    // beyond this point, "base" is where we're up to, and "size" is the limit
    size += base;

    for (; base < size; base += 4)
        invariant
            AlwaysInvariant(old(this),this);
            GlobalsInvariant(old(this),this);
            SaneState(this);
            WordAligned(base);
            size == limit;
            lower <= base <= limit;
            lower >= StackBase() || limit <= StackLimit();
            forall i :: (lower <= i < base) && WordAligned(i)
                ==> addrval(this,i) == old(val);
            MemPreservingExcept(old(this), this, lower, limit);
            RegPreservingExcept(old(this), this, [@base,@size]);
        decreases
            size - base;
    {
        ghost var prevThis := this;
        STR(val, base, 0);
        assert forall p :: ValidMem(prevThis.m, Address(p)) && p != base ==> addrval(prevThis, p) == addrval(this, p);
    }
}

/* Register allocation for init_addrspace paths:
 * r0 temp / err out
 * r1 addrspace_pagenr in
 * r2 l1pt_pagenr in
 * r3 temp
 * r4 addrspace_page pagedb entry offset
 * r5 l1pt_page pagedb entry offset
 * r6 addrspace monvaddr
 * r7 l1pt paddr & monvaddr
 * r12 pagedb global base
 */

#verbatim
function initAddrspaceEntry(addrspace_page:int, l1pt_page:int): PageDbEntry
{
    PageDbEntryTyped(addrspace_page, Addrspace(l1pt_page, 1, InitState))
}

function initL1PTEntry(addrspace_page:int): PageDbEntry
{
    PageDbEntryTyped(addrspace_page, L1PTable(SeqRepeat(NR_L1PTES(), Nothing)))
}
#endverbatim

procedure init_addrspace_pages(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R4)} addrspace_entry:int,
    {:register OReg(R5)} l1pt_entry:int,
    {:register OReg(R6)} addrspace_va:int)
    requires/ensures
        SaneState(this);
    requires
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        addrspace_page != l1pt_page;
        addrspace_entry == G_PAGEDB_ENTRY(addrspace_page);
        l1pt_entry == G_PAGEDB_ENTRY(l1pt_page);
        addrspace_va == page_monvaddr(addrspace_page);
    ensures
        StackPreserving(old(this),this);
        GlobalValuePreserving(old(this),this);
        RegPreservingExcept(old(this),this,[@r0, @r3, @r7]);
        pageContentsCorresponds(old(addrspace_page), initAddrspaceEntry(addrspace_page, l1pt_page), extractPage(this, old(addrspace_page)));
        pageContentsCorresponds(old(l1pt_page), initL1PTEntry(addrspace_page), extractPage(this, old(l1pt_page)));
{
    reveal_pageContentsCorresponds();

    page_paddr_impl(r7,l1pt_page,r0);

    STR(r7,r6,4);
    assert addrval(this,ADDRSPACE_L1PT_PHYS(addrspace_va)) == page_paddr(l1pt_page);

    r7 += sp_op_const(KEVLAR_DIRECTMAP_VBASE());
    assert r7 == page_monvaddr(l1pt_page);
    STR(r7,r6,0);
    assert addrval(this,ADDRSPACE_L1PT(addrspace_va)) == page_monvaddr(l1pt_page);

    r0 := 1;
    STR(r0,r6,8);
    assert addrval(this,ADDRSPACE_REF(addrspace_va)) == 1;

    r0 := sp_op_const(KEV_ADDRSPACE_INIT());
    STR(r0,r6,12);
    assert addrval(this,ADDRSPACE_STATE(addrspace_va)) == KEV_ADDRSPACE_INIT();

    r3 := sp_op_const(KEVLAR_PAGE_SIZE());
    r0 := 0;
    memset(r7,r0,r3);
}

procedure kev_smc_init_addrspace_success(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    {:register OReg(R4)} addrspace_entry:int,
    {:register OReg(R5)} l1pt_entry:int,
    {:register OReg(R12)} pagedb_base:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        addrspace_page != l1pt_page;
        validPageNr(addrspace_page);
        validPageNr(l1pt_page);
        l1pt_page % 4 == 0;
        addrspace_entry == G_PAGEDB_ENTRY(addrspace_page);
        l1pt_entry == G_PAGEDB_ENTRY(l1pt_page);
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        pageDbCorresponds(this, pagedb_in);
        pageIsFree(pagedb_in, addrspace_page);
        pageIsFree(pagedb_in, l1pt_page);
    ensures
        StackPreserving(old(this),this);
        old(initAddrspace(pagedb_in, addrspace_page, l1pt_page)) == Pair(pagedb, KEV_ERR_SUCCESS());
        pageDbCorresponds(this, pagedb);
        validPageDb(pagedb);
{
    reveal_pageDbEntryCorresponds();

    pagedb := pagedb_in;

    ghost var gaddrspace_entry := initAddrspaceEntry(addrspace_page, l1pt_page);
    ghost var gl1pt_entry := initL1PTEntry(addrspace_page);

    // compute addrs
    page_monvaddr_impl(r6,addrspace_page,r0);

    /* Update addrspace page in memory */
    init_addrspace_pages(addrspace_page, l1pt_page, addrspace_entry, l1pt_entry, r6);
    assert pageContentsCorresponds(addrspace_page, gaddrspace_entry,
                                   extractPage(this, addrspace_page));

    /* Update addrspace entry in PageDb */
    r0 := sp_op_const(KEV_PAGE_ADDRSPACE());
    assert r4 == G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE();
    assert r12 == AddressOfGlobal(PageDb());
    STRglobal(r0, PageDb(), r12, r4);
    //assert extractPageDbEntry(this, addrspace_page)[PAGEDB_ENTRY_TYPE()/BytesPerWord()]
    assert GlobalWord(this, PageDb(), G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE())
           == KEV_PAGE_ADDRSPACE();

    r4 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    assert r4 == G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_ADDRSPACE();
    assert r6 == page_monvaddr(addrspace_page);
    STRglobal(r6, PageDb(), r12, r4);
    assert extractPageDbEntry(this, addrspace_page)[PAGEDB_ENTRY_ADDRSPACE()/BytesPerWord()]
           == page_monvaddr(addrspace_page);
    assert pageDbEntryCorresponds(addrspace_page, gaddrspace_entry,
                                  extractPageDbEntry(this, addrspace_page));
    assert pageContentsCorresponds(addrspace_page, gaddrspace_entry,
                                   extractPage(this, addrspace_page));

    pagedb := pagedb[addrspace_page := gaddrspace_entry];
    assert pageDbCorrespondsOnly(this, pagedb, addrspace_page);

    /* Update l1pt entry in pagedb */
    r0 := sp_op_const(KEV_PAGE_L1PTABLE());
    STRglobal(r0, PageDb(), r12, r5);
    assert GlobalWord(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_TYPE()) == KEV_PAGE_L1PTABLE();
    r5 += sp_op_const(PAGEDB_ENTRY_ADDRSPACE());
    //assert r6 == page_monvaddr(addrspace_page);
    //assert r5 == G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_ADDRSPACE();
    //assert r12 == AddressOfGlobal(PageDb());
    STRglobal(r6, PageDb(), r12, r5);
    assert GlobalWord(this, PageDb(), G_PAGEDB_ENTRY(l1pt_page)
                          + PAGEDB_ENTRY_ADDRSPACE()) == page_monvaddr(addrspace_page);
    assert pageDbEntryCorresponds(l1pt_page, gl1pt_entry,
                                  extractPageDbEntry(this, l1pt_page));

    pagedb := pagedb[l1pt_page := gl1pt_entry];
    assert pageDbCorresponds(this, pagedb);
    assert validPageDb(pagedb);
}

procedure kev_smc_init_addrspace(
    {:register OReg(R1)} addrspace_page:int,
    {:register OReg(R2)} l1pt_page:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbCorresponds(this, pagedb_in);
    ensures
        StackPreserving(old(this),this);
        old(initAddrspace(pagedb_in, addrspace_page, l1pt_page)) == Pair(pagedb, err);
        pageDbCorresponds(this, pagedb);
        validPageDb(pagedb);
{
    reveal_pageDbEntryCorresponds();
    pagedb := pagedb_in;

    // check alignment of l1pt page
    AND(r0,l1pt_page,3);
    assert r0 == l1pt_page % 4;

    if (addrspace_page == l1pt_page) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (addrspace_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (l1pt_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else if (r0 != 0) {
        err := sp_op_const(KEV_ERR_INVALID_PAGENO());
    } else {
        assert validPageNr(addrspace_page) && validPageNr(l1pt_page);
        assert pageDbCorresponds(this, pagedb);
        LDRglobaladdr(r12, PageDb());
        r0 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r4,addrspace_page,r0);
        assert r4 == G_PAGEDB_ENTRY(addrspace_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r3, PageDb(), r12, r4);
        assert r3 == pageDbEntryTypeVal(pagedb[addrspace_page]);
        if (r3 == sp_op_const(KEV_PAGE_FREE())) {
            assert pageIsFree(pagedb, addrspace_page);
            assert r0 == PAGEDB_ENTRY_SIZE();
            MUL(r5,l1pt_page,r0);
            assert r5 == G_PAGEDB_ENTRY(l1pt_page) + PAGEDB_ENTRY_TYPE();
            LDRglobal(r0, PageDb(), r12, r5);
            assert r0 == pageDbEntryTypeVal(pagedb[l1pt_page]);
            if (r0 == sp_op_const(KEV_PAGE_FREE())) {
                assert pageIsFree(pagedb, l1pt_page);
                pagedb := kev_smc_init_addrspace_success(addrspace_page, l1pt_page,
                                                         r4, r5, r12, pagedb);
                err := OConst(KEV_ERR_SUCCESS());
            } else {
                err := sp_op_const(KEV_ERR_PAGEINUSE());
            }
        } else {
            err := sp_op_const(KEV_ERR_PAGEINUSE());
        }
    }
}

#verbatim
lemma SameMemAndGlobalsImpliesSamePageDb(s:state, s':state, pagedb:PageDb)
    requires SaneState(s) && SaneState(s')
    requires AlwaysInvariant(s,s')
    requires pageDbClosedRefs(pagedb)
    requires pageDbCorresponds(s.m, pagedb)
    requires NonStackMemPreserving(s,s')
    requires GlobalsInvariant(s,s')
    ensures pageDbCorresponds(s'.m, pagedb)
{
    assert GlobalFullContents(s.m, PageDb()) == GlobalFullContents(s'.m, PageDb());
    assert forall p :: validPageNr(p) ==> extractPage(s.m, p) == extractPage(s'.m, p);
    assert extractAllPages(s.m) == extractAllPages(s'.m);
}
#endverbatim

procedure smc_handler(
    {:register OReg(R0)} callno:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    {:register OReg(R4)} arg4:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} retval:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this,120);
    requires
        validPageDb(pagedb_in);
        pageDbCorresponds(this, pagedb_in);
    ensures
        NonvolatileRegPreserving(old(this),this);
        validPageDb(pagedb);
        pageDbCorresponds(this, pagedb);
{
    ghost var stack_bytes := 120;
    pagedb := pagedb_in;
    retval := 0;

    fcall_prologue(stack_bytes);
    SameMemAndGlobalsImpliesSamePageDb(old(this), this, pagedb);

    if(callno == sp_op_const(KEV_SMC_QUERY())) {
        err := sp_op_const(KEV_MAGIC());
    } else if(callno == sp_op_const(KEV_SMC_GETPHYSPAGES())) {
        retval := sp_op_const(KEVLAR_SECURE_NPAGES());
        err := sp_op_const(KEV_ERR_SUCCESS());
    } else if(callno == sp_op_const(KEV_SMC_INIT_ADDRSPACE())) {
        pagedb := kev_smc_init_addrspace(arg1, arg2, err, pagedb);
    }

    ghost var prePopThis := this;
    fcall_epilogue(stack_bytes-40);
    SameMemAndGlobalsImpliesSamePageDb(prePopThis, this, pagedb);

    // zero other volatiles to prevent information leakage
    r2 := 0;
    r3 := 0;

    // TODO: return path (movs pc, lr etc.)
}

#verbatim
function method PageDb(): operand { op_sym("g_pagedb") }
function method SecurePhysBase(): operand { op_sym("g_secure_physbase") }

// the phys base is unknown, but never changes
function {:axiom} SecurePhysBaseValue(): int
    ensures 0 < SecurePhysBaseValue() <= KEVLAR_PHYSMEM_LIMIT() - KEVLAR_SECURE_RESERVE();
    ensures WordAligned(SecurePhysBaseValue());

function method MyGlobalDecls(): globaldecls
    ensures ValidGlobalDecls(MyGlobalDecls());
{
    GlobalDecls(map[SecurePhysBase() := 4, //BytesPerWord()
                    PageDb() := G_PAGEDB_SIZE()])
}

predicate SaneMem(s:memstate)
{
    ValidMemState(s)
    // TODO: our insecure phys mapping must be valid
    //&& ValidMemRange(s, KEVLAR_DIRECTMAP_VBASE(),
    //    (KEVLAR_DIRECTMAP_VBASE() + MonitorPhysBaseValue()))
    // our secure phys mapping must be valid
    && ValidMemRange(s, KEVLAR_DIRECTMAP_VBASE() + SecurePhysBaseValue(),
        (KEVLAR_DIRECTMAP_VBASE() + SecurePhysBaseValue() + KEVLAR_SECURE_RESERVE()))
    // the stack must be mapped
    && ValidMemRange(s, StackLimit(), StackBase())
    // globals are as we expect
    && MyGlobalDecls() == TheGlobalDecls()
    && GlobalFullContents(s, SecurePhysBase()) == [SecurePhysBaseValue()]
    // XXX: workaround so dafny sees that these are distinct
    && SecurePhysBase() != PageDb()

}

predicate SaneState(s:state)
{
    ValidState(s) && ValidStack(s) && SaneMem(s.m) && s.mod == Monitor
}

method Main()
{
    printHeader();
    var n := printFunction("smc_handler", sp_code_smc_handler(), 0);
    printBss(MyGlobalDecls());
    printFooter();
}
#endverbatim
