#verbatim
predicate can_fcall(s:sp_state)
{
    ValidState(s) &&
    36 <= eval_op(s, op_sp()) < MaxVal() &&
    ValidMemRange(s, eval_op(s, op_sp())-36, eval_op(s, op_sp()) ) &&
    MemRangeIs32(s, eval_op(s, op_sp())-36, eval_op(s, op_sp())) &&
    (STACK_LOWER() + 36 <= eval_op(s,op_sp()) < STACK_UPPER())
}

predicate can_fcall_n(s:sp_state,n:int)
{
    ValidState(s) &&
    36 <= eval_op(s, op_sp()) < MaxVal() &&
    ValidMemRange(s, eval_op(s, op_sp())-36*n, eval_op(s, op_sp()) ) &&
    MemRangeIs32(s, eval_op(s, op_sp())-36*n, eval_op(s, op_sp())) &&
    (STACK_LOWER() + 36*n <= eval_op(s,op_sp()) < STACK_UPPER())
}
#endverbatim

#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

procedure fcall_prologue()
    requires/ensures
        ValidState(this);
        STACK_LOWER() <= sp < STACK_UPPER();
    requires
        36 <= sp < MaxVal();
        STACK_LOWER() + 36 <= sp;
        ValidMemRange(this, sp-36, sp);
        MemRangeIs32(this, sp-36, sp); 
    ensures
        // Moves stack pointer
        sp == old(sp-36);
        ValidMemRange(this, sp, sp+36);
        MemRangeIs32(this, sp, sp+36); 
        // keeps r0-r3
        r0 == old(r0);
        r1 == old(r1);
        r2 == old(r2);
        r3 == old(r3);
        // pushes r4-r11, sp, lr
        addrval(this, sp)    == old(r11);
        addrval(this, sp+4)  == old(r10);
        addrval(this, sp+8)  == old(r9);
        addrval(this, sp+12) == old(r8);
        addrval(this, sp+16) == old(r7);
        addrval(this, sp+20) == old(r6);
        addrval(this, sp+24) == old(r5);
        addrval(this, sp+28) == old(r4);
        addrval(this, sp+32) == old(lr);
        // preserves memory validity
        forall m:mem :: ValidMem(old(this), m) ==> ValidMem(this,m);
        // preserves values of other memory locations
        forall i:int :: !(STACK_LOWER() <= i < STACK_UPPER()) && ValidMem(old(this),Address(i)) ==>
            addrval(this,i) == addrval(old(this),i);

{

    //push link register onto stack
    SUB(sp, sp, 4);
    STR(lr, sp, 0);

    //push r4-r11 onto stack
    SUB(sp,  sp, 4);
    STR(r4,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r5,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r6,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r7,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r8,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r9,  sp, 0);
    SUB(sp,  sp, 4);
    STR(r10, sp, 0);
    SUB(sp,  sp, 4);
    STR(r11, sp, 0);

    // Move function arguments in r0-r3 into r4-r7
    // r4 := r0;
    // r5 := r1;
    // r6 := r2;
    // r7 := r3;
}

procedure fcall_epilogue()
    requires/ensures
        ValidState(this);
        STACK_LOWER() <= sp < STACK_UPPER();
    requires
        0 <= sp + 36 < MaxVal();
        sp + 36 < STACK_UPPER();
        ValidMemRange(this, sp, sp+36);
        MemRangeIs32(this,  sp, sp+36);
    ensures
        sp == old(sp+36);
        ValidMemRange(this, sp-36, sp);
        MemRangeIs32(this,  sp-36, sp);
        r0 == old(r0);
        r1 == old(r1);
        r2 == old(r2);
        r3 == old(r3);
        // pop lr, r4-r11 from stack.
        lr  == addrval(this, sp-4);
        r4  == addrval(this, sp-8);
        r5  == addrval(this, sp-12);
        r6  == addrval(this, sp-16);
        r7  == addrval(this, sp-20);
        r8  == addrval(this, sp-24);
        r9  == addrval(this, sp-28);
        r10 == addrval(this, sp-32);
        r11 == addrval(this, sp-36);
        //preserves memory validity
        forall m:mem :: ValidMem(old(this), m) ==> ValidMem(this,m);
        //preserves values in memory region outside of stack
        forall i:int :: !(STACK_LOWER() <= i < STACK_UPPER()) && ValidMem(old(this),Address(i)) ==>
            addrval(this,i) == addrval(old(this),i);
{
    //pop r11 down to r4 from stack
    LDR(r11, sp, 0);
    ADD(sp, sp, 4);
    LDR(r10, sp, 0);
    ADD(sp, sp, 4);
    LDR(r9, sp, 0);
    ADD(sp, sp, 4);
    LDR(r8, sp, 0);
    ADD(sp, sp, 4);
    LDR(r7, sp, 0);
    ADD(sp, sp, 4);
    LDR(r6, sp, 0);
    ADD(sp, sp, 4);
    LDR(r5, sp, 0);
    ADD(sp, sp, 4);
    LDR(r4, sp, 0);
    ADD(sp, sp, 4);

    //pop link register from stack
    LDR(lr, sp, 0);
    ADD(sp, sp, 4);

    //Move function arguments back into r0-r3
    // r0 := r4;
    // r1 := r5;
    // r2 := r6;
    // r3 := r7;
}

// loads the pagedb_entry address for pageno into entry
procedure pagedb_entry(
    {:register op_r(0)} pageno:int,
    out {:register op_r(1)} entry:int)
    requires/ensures
        ValidState(this);
        0 <= r0 < 256;
        ValidMem(this, Address(0x4000_0000 + old(r0) * 5));
        can_fcall(this);
    ensures
        entry == addrval(this, 0x4000_0000 + old(r0) * 5);
{
    fcall_prologue();
    entry := 0x4000_0000; // G_PAGEDB()

    for (r9:= 0; r9 < r0; r9++)
      invariant
        ValidState(this);
        isUInt32(entry);
        0 <= r0 < 256;
        0 <= r9 <= r0;
        r0 == old(r0);
        entry == 0x4000_0000 + r9 * 5;
        // Allows store.
        ValidMem(this, Address(0x4000_0000 + old(r0) * 5));
        // Allows fcall_epilogue;
        sp == old(sp-36);
        ValidMemRange(this, sp, sp+36);
        MemRangeIs32(this, sp, sp+36); 
      decreases
        r0 - r9;
    {
        ADD(entry, entry, 5);
    }
    
    assert ValidMem(this, Address(0x4000_0000 + old(r0) * 5));

    STR(entry, entry, 0);
    assert entry == addrval(this, 0x4000_0000 + old(r0) * 5);
    fcall_epilogue();
}

procedure kev_smc_init_addrspace(
    {:register op_r(0)} addrspace_page:int,
    {:register op_r(1)} l1pt_page:int,
    out {:register op_r(0)} err:int)
    requires/ensures
        can_fcall(this);
{
    fcall_prologue();
    err := 0;

    r4 := KEVLAR_SECURE_NPAGES() % pow2_32();
    // r5 := PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page));  //addr of type
    // LDR(r5, r5, 0); // type
    // r6 := PAGEDB_ENTRY_TYPE(G_PAGEDB_ENTRY(addrspace_page));  //addr of type
    // LDR(r6, r6, 0); // type
    if( addrspace_page >= r4 ) {
        err := KEV_ERR_INVALID_PAGENO();
    } else if( l1pt_page >= r4 ) {
        err := KEV_ERR_INVALID_PAGENO();
    } else { //todo
        err := KEV_ERR_SUCCESS();
    }


    fcall_epilogue();
}

procedure smc_handler(
    {:register op_r(4)} callno:int,
    {:register op_r(0)} arg1:int,
    {:register op_r(1)} arg2:int,
    {:register op_r(2)} arg3:int,
    {:register op_r(3)} arg4:int,
    out {:register op_r(0)} err:int,
    out {:register op_r(1)} retval:int)
    requires/ensures
        can_fcall(this);
{
    
    retval := 0;
    
    if(callno == KEV_SMC_QUERY()) {
        err := KEV_MAGIC();
    } else if(callno == KEV_SMC_GETPHYSPAGES()) {
        // assume 0 <= KEVLAR_SECURE_NPAGES() < pow2_32(); // Really want to inline constants
        retval := KEVLAR_SECURE_NPAGES() % pow2_32();
        err := KEV_ERR_SUCCESS();
    } else if(callno == KEV_SMC_INIT_ADDRSPACE()) {
        kev_smc_init_addrspace(arg1, arg2, err);
    }

}

procedure main(){}

#verbatim

method Main()
{
  printHeader();
  var n := printCode(sp_code_main(), 0);
  printFooter();
}
#endverbatim
