procedure wrapIncr(ghost g1:int, inout{:operand} o:int, ghost g2:int, ghost g3:int, {:inline} k:int) returns (ghost b:bool)
  requires
    ValidDestinationOperand(this, @o);
    0 <= o <= 1000;
    0 <= k <= 10;
  ensures
    ValidOperand(this, @o);
    o == old(o) + 1 + 2 * k;
{
  ADD(o, o, 1);

  // these two are equivalent:
  ADD(o, o, k);
  ADD(o, o, fromOperand(OConst(k)));
}

procedure foo(ghost x:int, inout{:register op_r(1)} a:int) returns(ghost y:int)
  requires
    ValidOperand(this, op_r(1));
    x < 100;
    a == r1;
    1 <= r1;
    r1 < 10;
  ensures
    ValidOperand(this, op_r(1));
    1 <= r1;
    r1 == old(r1);
    y == x;
{
  y := x;
  ghost var z1 := x;
  ghost var z2 := x;
  assert y == z1;
  ghost var a1 := r1;

  var{:register op_r(1)} i:int;

  if (i <= i)
  {
    ADD(i,i,1);
    assert i == a1 + 1;
    assert i == old(a) + 1;
    ghost var s1 := this;
    assert i == old[s1](i);
    SUB(a,a,1); //todo decr
    assert i == old[s1](i) - 1;
  }
  else if (i >= i)
  {
    assert true;
  }
  else
  {
    ghost var b;
    b := wrapIncr(3, r1, 4, 5, 6);
    ADD(i,i,1);
  }
}

procedure p()
  requires/ensures
    ValidOperand(this, op_r(1));
  requires
    r1 < 100;
  modifies
    r1;
  requires
    r1 >= 0;
  ensures
    r1 >= 2;
{
  ADD(r1,r1,1);
  ADD(r1,r1,1);
}

#token ++ precedence !
#token += precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV
procedure operator(++) (inout{:operand} dst:int) := incr
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals

procedure main()
  requires/ensures
    ValidOperand(this, op_r(1));
    ValidOperand(this, op_r(2));
  requires
    2 <= r1;
    r1 < 10;
  ensures
       r1 == old(r1) + 2
    || r1 == old(r1) - 2;
{
  for (r2:= 0; r2 < 10; r2++)
    invariant
      ValidOperand(this, op_r(1));
      ValidOperand(this, op_r(2));
      r2 <= 10;
      r1 == old(r1);
    decreases 10 - r2;
  {
  }
  assert r2 == 10;

  if (r1 <= r1)
  {
    //eax += ebx;
    //ADD(eax, ebx);
    assert r1 <= r1;
    ADD(r1,r1,1);
    ADD(r1,r1,1);
  }
  else if (r1 >= r1)
  {
    //ADD32(eax, 2);
    r1 += 2;
  }
  else
  {
    SUB(r1,r1,1); //todo decr
    SUB(r1,r1,1); //todo decr
  }
}


#verbatim
method Main()
{
  printHeader();
  var n := printCode(sp_code_main(), 0);
  printFooter();
}
#endverbatim

