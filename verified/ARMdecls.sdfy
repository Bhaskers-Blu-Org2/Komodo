var{:register OReg(R0)}  r0:int;
var{:register OReg(R1)}  r1:int;
var{:register OReg(R2)}  r2:int;
var{:register OReg(R3)}  r3:int;
var{:register OReg(R4)}  r4:int;
var{:register OReg(R5)}  r5:int;
var{:register OReg(R6)}  r6:int;
var{:register OReg(R7)}  r7:int;
var{:register OReg(R8)}  r8:int;
var{:register OReg(R9)}  r9:int;
var{:register OReg(R10)} r10:int;
var{:register OReg(R11)} r11:int;
var{:register OReg(R12)} r12:int;

var{:register op_sp()}  sp:int;
var{:register op_lr()}  lr:int;

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV

function{:operand} sp_op_const(n:int):operand

procedure {:instruction Ins(ADD(dst, src1, src2))}
ADD(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        isUInt32(src1 + src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 + src2), this);
        WordAligned(src1) && WordAligned(src2) ==> WordAligned(dst);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(SUB(dst, src1, src2))}
SUB(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        isUInt32(src1 - src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 - src2), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MUL(dst, src1, src2))}
MUL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@src1);
        ValidRegOperand(@src2);
        ValidDestinationOperand(@dst);
        isUInt32(src1 * src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 * src2), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(UDIV(dst, src1, src2))}
UDIV(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        src2 > 0;
        isUInt32(src1 / src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 / src2), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(AND(dst, src1, src2))}
AND(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(and32(src1, src2)), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(ORR(dst, src1, src2))}
ORR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(or32(src1,src2)), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(EOR(dst, src1, src2))}
EOR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(xor32(src1,src2)), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(ROR(dst, src1, src2))}
ROR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(ror32(src1,src2)), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LSL(dst, src1, src2))}
LSL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(shl32(src1,src2)), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LSR(dst, src1, src2))}
LSR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(shr32(src1,src2)), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MVN(dst, src))}
MVN(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src);
        ValidDestinationOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(not32(src)), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MOV(dst, src))}
MOV(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src);
        ValidDestinationOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(src), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR(rd, base, ofs))}
LDR(out{:operand} rd:int, {:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidState(this);
    requires
        ValidDestinationOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        WordAligned(base + ofs);
        ValidMem(this.m, addr_mem(this, @base, @ofs));
    ensures
        evalUpdate(old(this), @rd, MemContents(old(this.m), addr_mem(old(this), @base, @ofs)), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(STR(rd, base, ofs))}
STR({:operand} rd:int, out{:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        WordAligned(base + ofs);
        ValidMem(this.m, addr_mem(this, @base, @ofs));
    ensures
        evalMemUpdate(old(this), addr_mem(old(this), @base, @ofs), old(rd), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        GlobalsInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MRS(dst, src))}
MRS({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidSpecialOperand(this, @src);
        !ValidMcrMrcOperand(this, @src);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, SpecialOperandContents(old(this), @src), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

#verbatim
predicate is_psr(o:sp_operand)
{ // true if cpsr or spsr
    o.OSReg? && (o.sr.cpsr? || o.sr.spsr?)
}
#endverbatim

procedure {:instruction Ins(MSR(dst, src))}
MSR({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidRegOperand(@src);
    requires
        ValidSpecialOperand(this, @dst);
        !ValidMcrMrcOperand(this, @dst);
        is_psr(@dst) ==> ValidModeChange(mode_of_state(this), src);
    ensures
        evalSRegUpdate(old(this), @dst, old(src), this);
        AlwaysInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MRC(dst, src))}
MRC({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidRegOperand(@dst);
        ValidMcrMrcOperand(this, @src);
    ensures
        evalUpdate(old(this), @dst, SpecialOperandContents(old(this), @src), this);
        AlwaysInvariant(old(this), this);
        WorldInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MCR(dst, src))}
MCR({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidRegOperand(@src);
    requires
        ValidMcrMrcOperand(this, @dst);
    ensures
        evalSRegUpdate(old(this), OSReg(scr), src, this);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MOVS_PCLR)}
MOVS_PCLR()
    requires/ensures
        ValidState(this);
    requires 
        ValidSpecialOperand(this, OSReg(spsr( mode_of_state(this) )));
        ValidModeChange(mode_of_state(this),
            SpecialOperandContents(this ,OSReg(spsr(this.conf.cpsr.m))));
        mode_of_state(this) != User;
    ensures
        evalSRegUpdate(old(this), OSReg(cpsr), SpecialOperandContents(old(this),
            OSReg( old(spsr(this.conf.cpsr.m) ))), this);
        AlwaysInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR_reloc(rd, g))}
LDRglobaladdr(out{:operand} rd:int, {:operand} g:string)
    requires
        ValidState(this);
        ValidDestinationOperand(@rd);
        ValidGlobal(@g);
    ensures
        evalUpdate(old(this), @rd, AddressOfGlobal(@g), this);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR_global(rd, g, base, ofs))}
LDRglobal(out{:operand} rd:int, {:operand} g:string,
          {:operand} base:int, {:operand} ofs:int)
    requires
        ValidState(this);
        ValidDestinationOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidGlobalOffset(@g, ofs);
        AddressOfGlobal(@g) == base;
    ensures
        evalUpdate(old(this), @rd, old(GlobalWord(this.m, @g, ofs)), this);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(STR_global(rd, g, base, ofs))}
STRglobal({:operand} rd:int, {:operand} g:string,
          {:operand} base:int, {:operand} ofs:int)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidGlobalOffset(@g, ofs);
        AddressOfGlobal(@g) == base;
        isUInt32(rd);
    ensures
        evalGlobalUpdate(old(this), @g, old(ofs), old(rd), this);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AddrMemInvariant(old(this), this);
{
    reveal_sp_eval();
}
