var{:register op_r(0)}  r0:int;
var{:register op_r(1)}  r1:int;
var{:register op_r(2)}  r2:int;
var{:register op_r(3)}  r3:int;
var{:register op_r(4)}  r4:int;
var{:register op_r(5)}  r5:int;
var{:register op_r(6)}  r6:int;
var{:register op_r(7)}  r7:int;
var{:register op_r(8)}  r8:int;
var{:register op_r(9)}  r9:int;
var{:register op_r(10)} r10:int;
var{:register op_r(11)} r11:int;
var{:register op_r(12)} r12:int;

var{:register op_sp()}  sp:int;
var{:register op_lr()}  lr:int;

function{:operand} fromOperand(o:oprnd):oprnd

// var{:register op_sp(User)}      spUser:int;
// var{:register op_sp(System)}    spSystem:int;
// var{:register op_sp(Monitor)}   spMonitor:int;
// var{:register op_sp(Abort)}     spAbort:int;
// var{:register op_sp(Undefined)} spUndefined:int;
// var{:register op_sp(FIQ)}       spFIQ:int;
// 
// var{:register op_lr(User)}      lrUser:int;
// var{:register op_lr(System)}    lrSystem:int;
// var{:register op_lr(Monitor)}   lrMonitor:int;
// var{:register op_lr(Abort)}     lrAbort:int;
// var{:register op_lr(Undefined)} lrUndefined:int;
// var{:register op_lr(FIQ)}       lrFIQ:int;

procedure ADD(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidOperand(this, @src1);
        ValidOperand(this, @src2);
        ValidDestinationOperand(this, @dst);
    requires
        isUInt32(src1);
        isUInt32(src2);
        isUInt32(src1 + src2);
    ensures
        isUInt32(dst);
        evalUpdate(old(this), @dst, old(src1 + src2), this, true);

procedure SUB(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidOperand(this, @src1);
        ValidOperand(this, @src2);
        ValidDestinationOperand(this, @dst);
    requires
        isUInt32(src1);
        isUInt32(src2);
        isUInt32(src1 - src2);
    ensures
        isUInt32(dst);
        evalUpdate(old(this), @dst, old(src1 - src2), this, true);

procedure AND(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidOperand(this, @src1);
        ValidOperand(this, @src2);
        ValidDestinationOperand(this, @dst);
        isUInt32(src1);
        isUInt32(src2);
    ensures
        isUInt32(dst);
        evalUpdate(old(this), @dst, old(and32(src1, src2)), this, true);


procedure ORR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidOperand(this, @src1);
        ValidOperand(this, @src2);
        ValidDestinationOperand(this, @dst);
    requires
        isUInt32(src1);
        isUInt32(src2);
    ensures
        isUInt32(dst);
        evalUpdate(old(this), @dst, old(or32(src1,src2)), this, true);


procedure EOR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidOperand(this, @src1);
        ValidOperand(this, @src2);
        ValidDestinationOperand(this, @dst);
    requires
        isUInt32(src1);
        isUInt32(src2);
    ensures
        isUInt32(dst);
        evalUpdate(old(this), @dst, old(xor32(src1,src2)), this, true);

procedure ROR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidOperand(this, @src1);
        ValidOperand(this, @src2);
        ValidDestinationOperand(this, @dst);
    requires
        isUInt32(src1);
        isUInt32(src2);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        isUInt32(dst);
        evalUpdate(old(this), @dst, old(ror32(src1,src2)), this, true);

procedure LSL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidOperand(this, @src1);
        ValidOperand(this, @src2);
        ValidDestinationOperand(this, @dst);
    requires
        isUInt32(src1);
        isUInt32(src2);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        isUInt32(dst);
        evalUpdate(old(this), @dst, old(shl32(src1,src2)), this, true);

procedure LSR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidOperand(this, @src1);
        ValidOperand(this, @src2);
        ValidDestinationOperand(this, @dst);
    requires
        isUInt32(src1);
        isUInt32(src2);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        isUInt32(dst);
        evalUpdate(old(this), @dst, old(shr32(src1,src2)), this, true);

procedure MVN(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidOperand(this, @src);
        ValidDestinationOperand(this, @dst);
    requires
        isUInt32(src);
    ensures
        isUInt32(dst);
        evalUpdate(old(this), @dst, old(not32(src)), this, true);
        0 <= dst < MaxVal();

procedure MOV(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidOperand(this, @src);
        ValidDestinationOperand(this, @dst);
        isUInt32(src);
    ensures
        evalUpdate(old(this), @dst, old(src), this, true);
        isUInt32(dst);
        0 <= dst < MaxVal();

procedure LDR(out{:operand} rd:int, {:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidDestinationOperand(this, @rd);
        ValidOperand(this, @base);
        ValidOperand(this, @ofs);
        isUInt32(rd);
        isUInt32(base);
        isUInt32(ofs);
    requires
        ValidMem(this, addr_mem(this, @base, @ofs));
        isUInt32(addrval(this, base + ofs));
    ensures
        evalUpdate(old(this), @rd, MemContents(old(this), addr_mem(old(this), @base, @ofs)), this, true);
        isUInt32(rd);
        0 <= rd < MaxVal();

procedure STR({:operand} rd:int, out{:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidOperand(this, @rd);
        ValidOperand(this, @base);
        ValidOperand(this, @ofs);
        isUInt32(rd);
        isUInt32(base);
        isUInt32(ofs);
    requires
        ValidMem(this, addr_mem(this, @base, @ofs));
    ensures
        evalMemUpdate(old(this), addr_mem(old(this), @base, @ofs), old(rd), this, true);
        isUInt32(addrval(this, base + ofs));

procedure CPS({:operand} mod:int)
    requires
        ValidOperand(this, @mod);
        ValidMode(mod);
        isUInt32(mod);
    ensures
        evalModeUpdate(old(this), old(mod), this, true);

procedure incr(inout{:operand} o:int)
  requires
    ValidDestinationOperand(this, @o);
    isUInt32(o);
    isUInt32(o + 1);
  ensures
    evalUpdate(old(this), @o, old(o) + 1, this, true);

procedure plusEquals(inout{:operand} o1:int, {:operand} o2:int)
    requires
        ValidDestinationOperand(this, @o1);
        ValidOperand(this, @o2);
        isUInt32(o1);
        isUInt32(o2);
        isUInt32(o1 + o2);
    ensures
        evalUpdate(old(this), @o1, old(o1 + o2), this, true);

procedure andEquals(inout{:operand} o1:int, {:operand} o2:int)
    requires
        ValidDestinationOperand(this, @o1);
        ValidOperand(this, @o2);
        isUInt32(o1);
        isUInt32(o2);
        0 <= o1 < MaxVal();
    ensures
        evalUpdate(old(this), @o1, old(and32(o1,o2)), this, true);

procedure xorEquals(inout{:operand} o1:int, {:operand} o2:int)
    requires
        ValidDestinationOperand(this, @o1);
        ValidOperand(this, @o2);
        isUInt32(o1);
        isUInt32(o2);
        0 <= o1 < MaxVal();
    ensures
        evalUpdate(old(this), @o1, old(xor32(o1,o2)), this, true);

