var{:register OReg(R0)}  r0:int;
var{:register OReg(R1)}  r1:int;
var{:register OReg(R2)}  r2:int;
var{:register OReg(R3)}  r3:int;
var{:register OReg(R4)}  r4:int;
var{:register OReg(R5)}  r5:int;
var{:register OReg(R6)}  r6:int;
var{:register OReg(R7)}  r7:int;
var{:register OReg(R8)}  r8:int;
var{:register OReg(R9)}  r9:int;
var{:register OReg(R10)} r10:int;
var{:register OReg(R11)} r11:int;
var{:register OReg(R12)} r12:int;

var{:register OSP} sp:int;
var{:register OLR} lr:int;

var{:register OReg(SP(User))}       sp_usr:int;
var{:register OReg(SP(FIQ))}        sp_fiq:int;
var{:register OReg(SP(IRQ))}        sp_irq:int;
var{:register OReg(SP(Supervisor))} sp_svc:int;
var{:register OReg(SP(Abort))}      sp_abt:int;
var{:register OReg(SP(Undefined))}  sp_und:int;
var{:register OReg(SP(Monitor))}    sp_mon:int;

var{:register OReg(LR(User))}       lr_usr:int;
var{:register OReg(LR(FIQ))}        lr_fiq:int;
var{:register OReg(LR(IRQ))}        lr_irq:int;
var{:register OReg(LR(Supervisor))} lr_svc:int;
var{:register OReg(LR(Abort))}      lr_abt:int;
var{:register OReg(LR(Undefined))}  lr_und:int;
var{:register OReg(LR(Monitor))}    lr_mon:int;

var{:register OSReg(spsr(FIQ))}        spsr_fiq:int;
var{:register OSReg(spsr(IRQ))}        spsr_irq:int;
var{:register OSReg(spsr(Supervisor))} spsr_svc:int;
var{:register OSReg(spsr(Abort))}      spsr_abt:int;
var{:register OSReg(spsr(Undefined))}  spsr_und:int;
var{:register OSReg(spsr(Monitor))}    spsr_mon:int;


procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV

function{:operand} sp_op_const(n:word):operand
/*
procedure {:instruction Ins(ADD(dst, src1, src2))}
ADD(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidSecondOperand(@src2);
        ValidRegOperand(@dst);
        isUInt32(src1 + src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 + src2), this);
        WordAligned(old(src1)) && WordAligned(old(src2)) ==> WordAligned(dst);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(ADD(dst, src1, src2))}
ADDWrap(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidSecondOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(src1 + src2) % 0x1_0000_0000, this);
        WordAligned(old(src1)) && WordAligned(old(src2)) ==> WordAligned(dst);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(SUB(dst, src1, src2))}
SUB(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        isUInt32(src1 - src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 - src2), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MUL(dst, src1, src2))}
MUL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@src1);
        ValidRegOperand(@src2);
        ValidRegOperand(@dst);
        isUInt32(src1 * src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 * src2), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(UDIV(dst, src1, src2))}
UDIV(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        src2 > 0;
        isUInt32(src1 / src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 / src2), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(AND(dst, src1, src2))}
AND(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseAnd(src1, src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(ORR(dst, src1, src2))}
ORR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseOr(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(EOR(dst, src1, src2))}
EOR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidSecondOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseXor(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LSL(dst, src1, src2))}
LSL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(LeftShift(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LSR(dst, src1, src2))}
LSR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(RightShift(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(REV(dst, src))}
REV(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@src);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(bswap32(src)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MVN(dst, src))}
MVN(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseNot(src)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MOV(dst, src))}
MOV(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidSecondOperand(@src);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(src), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR(rd, base, ofs))}
LDR(out{:operand} rd:int, {:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidMem(base + ofs);
    ensures
        evalUpdate(old(this), @rd, MemContents(old(this.m), old(base + ofs)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(STR(rd, base, ofs))}
STR({:operand} rd:int, out{:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidMem(base + ofs);
    ensures
        evalMemUpdate(old(this), old(base + ofs), old(rd), this);
        AllRegsInvariant(old(this), this);
        GlobalsInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MRS(dst, src))}
MRS({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        priv_of_state(this) == PL1;
        ValidRegOperand(@dst);
        ValidSpecialOperand(this, @src) && !ValidMcrMrcOperand(this, @src) || ValidBankedRegOperand(this, @src);
    ensures
        evalUpdate(old(this), @dst, if @src is OSReg then SpecialOperandContents(old(this), @src) else old(src), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

#verbatim
predicate is_psr(o:sp_operand)
{ // true if cpsr
    o.OSReg? && o.sr.cpsr?
}
predicate is_spsr(o:sp_operand)
{
    o.OSReg? && o.sr.spsr?
}
#endverbatim

procedure {:instruction Ins(MSR(dst, src))}
MSR({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        priv_of_state(this) == PL1;
        ValidRegOperand(@src);
        ValidSpecialOperand(this, @dst) && !ValidMcrMrcOperand(this, @dst) || ValidBankedRegOperand(this, @dst);
        is_psr(@dst) ==> ValidModeChange(this, src);
        is_spsr(@dst) ==> ValidModeEncoding(psr_mask_mode(src));
    ensures
        if @dst is OSReg then evalSRegUpdate(old(this), @dst, old(src), this)
            else evalUpdate(old(this), @dst, old(src), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MRC(dst, src))}
MRC({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidRegOperand(@dst);
        ValidMcrMrcOperand(this, @src);
    ensures
        evalUpdate(old(this), @dst, SpecialOperandContents(old(this), @src), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MCR(dst, src))}
MCR({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidRegOperand(@src);
    requires
        ValidMcrMrcOperand(this, @dst);
    ensures
        evalSRegUpdate(old(this), OSReg(scr), src, this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MOVS_PCLR_TO_USERMODE_AND_CONTINUE)}
MOVS_PCLR_TO_USERMODE_AND_CONTINUE()
    requires/ensures
       ValidState(this);
    requires 
        ValidModeChange'(this, User);
        spsr_of_state(this).m == User;
    ensures
        evalMOVSPCLRUC(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR_reloc(rd, g))}
LDRglobaladdr(out{:operand} rd:int, {:operand} g:string)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidGlobal(@g);
    ensures
        evalUpdate(old(this), @rd, AddressOfGlobal(@g), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR_global(rd, g, base, ofs))}
LDRglobal(out{:operand} rd:int, {:operand} g:string,
          {:operand} base:int, {:operand} ofs:int)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidGlobalOffset(@g, ofs);
        AddressOfGlobal(@g) == base;
    ensures
        evalUpdate(old(this), @rd, old(GlobalWord(this.m, @g, ofs)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(STR_global(rd, g, base, ofs))}
STRglobal({:operand} rd:int, {:operand} g:string,
          {:operand} base:int, {:operand} ofs:int)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidGlobalOffset(@g, ofs);
        AddressOfGlobal(@g) == base;
        isUInt32(rd);
    ensures
        evalGlobalUpdate(old(this), @g, old(ofs), old(rd), this);
        AllRegsInvariant(old(this), this);
        AddrMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

////////////////////////////////////////////////////////////////////////////////
//
//   Support for Spartan's refined mode
//
////////////////////////////////////////////////////////////////////////////////
*/
var{:state ok()}  ok:bool;
var{:state mem()} mem:memmap;

procedure {:refined} {:instruction Ins(LDR(rd, base, ofs))}
rLDR(out{:operand} rd:word, {:operand} base:word, {:operand} ofs:word)
    requires
        ValidAddr(mem, base + ofs);
    reads mem;
    ensures
        rd == mem[old(base) + old(ofs)];
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(STR(rd, base, ofs))}
rSTR({:operand} rd:reg, {:operand} base:word, {:operand} ofs:word)
    requires/ensures
        ValidAddr(mem, base + ofs);
    modifies
        mem;
    ensures
        mem == old(mem)[old(base+ofs) := rd];
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(MOV(dst, src))}
rMOV(out{:operand} dst:word, {:operand} src:snd)
    ensures
        dst == old(src);
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(EOR(dst, src1, src2))}
rEOR(out{:operand} dst:word, {:operand} src1:word, {:operand} src2:snd)
    ensures
        dst == BitwiseXor(old(src1), old(src2));
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(ADD(dst, src1, src2))}
rADDWrap(out{:operand} dst:word, {:operand} src1:word, {:operand} src2:snd)
    ensures
        dst == old(src1 + src2) % 0x1_0000_0000;
        WordAligned(old(src1)) && WordAligned(old(src2)) ==> WordAligned(dst);
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(REV(dst, src))}
rREV(out{:operand} dst:word, {:operand} src:reg)
    ensures
        dst == old(bswap32(src));
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}
