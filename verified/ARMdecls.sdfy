var{:register OReg(R0)}  r0:int;
var{:register OReg(R1)}  r1:int;
var{:register OReg(R2)}  r2:int;
var{:register OReg(R3)}  r3:int;
var{:register OReg(R4)}  r4:int;
var{:register OReg(R5)}  r5:int;
var{:register OReg(R6)}  r6:int;
var{:register OReg(R7)}  r7:int;
var{:register OReg(R8)}  r8:int;
var{:register OReg(R9)}  r9:int;
var{:register OReg(R10)} r10:int;
var{:register OReg(R11)} r11:int;
var{:register OReg(R12)} r12:int;

var{:register op_sp()}  sp:int;
var{:register op_lr()}  lr:int;

function{:operand} sp_op_const(n:int):operand

procedure ADD(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        isUInt32(src1 + src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 + src2), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure SUB(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        isUInt32(src1 - src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 - src2), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure MUL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@src1);
        ValidRegOperand(@src2);
        ValidDestinationOperand(@dst);
        isUInt32(src1 * src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 * src2), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure UDIV(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        src2 > 0;
        isUInt32(src1 / src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 / src2), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure AND(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(and32(src1, src2)), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure ORR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(or32(src1,src2)), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure EOR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(xor32(src1,src2)), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure ROR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(ror32(src1,src2)), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure LSL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(shl32(src1,src2)), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure LSR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidDestinationOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(shr32(src1,src2)), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure MVN(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src);
        ValidDestinationOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(not32(src)), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure MOV(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src);
        ValidDestinationOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(src), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure LDR(out{:operand} rd:int, {:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidState(this);
    requires
        ValidDestinationOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        WordAligned(base + ofs);
        ValidMem(this.m, addr_mem(this, @base, @ofs));
    ensures
        evalUpdate(old(this), @rd, MemContents(old(this.m), addr_mem(old(this), @base, @ofs)), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure STR({:operand} rd:int, out{:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        WordAligned(base + ofs);
        ValidMem(this.m, addr_mem(this, @base, @ofs));
    ensures
        evalMemUpdate(old(this), addr_mem(old(this), @base, @ofs), old(rd), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        GlobalsInvariant(old(this), this);

procedure CPS({:operand} mod:int)
    requires
        ValidState(this);
        ValidOperand(@mod);
        ValidModeEncoding(mod);
    ensures
        evalModeUpdate(old(this), old(mod), this, true);
        AlwaysInvariant(old(this), this);
        AllMemInvariant(old(this), this);

// procedure push({:operand} o:int)
//     requires
//         ValidDestinationOperand(@sp);
//         ValidOperand(@o);
//         isUInt32(o);
//         4 <= o < pow2_32();
//         ValidMem(this, Address(sp));
//     ensures
//         evalUpdate(old(this), @sp, old(sp-4), this, true);
//         sp == old(sp-4);
//         addrval(this, old(sp)) == o;

procedure plusEquals(inout{:operand} o1:int, {:operand} o2:int)
    requires
        ValidState(this);
        ValidDestinationOperand(@o1);
        ValidOperand(@o2);
        isUInt32(o1 + o2);
    ensures
        evalUpdate(old(this), @o1, old(o1 + o2), this, true);

procedure LDRglobaladdr(out{:operand} rd:int, {:operand} g:string)
    requires
        ValidState(this);
        ValidDestinationOperand(@rd);
        ValidGlobal(@g);
    ensures
        evalUpdate(old(this), @rd, AddressOfGlobal(@g), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure LDRglobal(out{:operand} rd:int, {:operand} g:string,
                    {:operand} base:int, {:operand} ofs:int)
    requires
        ValidState(this);
        ValidDestinationOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidGlobalOffset(@g, ofs);
        AddressOfGlobal(@g) == base;
    ensures
        evalUpdate(old(this), @rd, old(GlobalWord(this.m, @g, ofs)), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AllMemInvariant(old(this), this);

procedure STRglobal({:operand} rd:int, {:operand} g:string,
                    {:operand} base:int, {:operand} ofs:int)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidGlobalOffset(@g, ofs);
        AddressOfGlobal(@g) == base;
        isUInt32(rd);
    ensures
        evalGlobalUpdate(old(this), @g, old(ofs), old(rd), this, true);
        AlwaysInvariant(old(this), this);
        ModeInvariant(old(this), this);
        AddrMemInvariant(old(this), this);
