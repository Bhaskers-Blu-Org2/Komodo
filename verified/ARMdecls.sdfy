var{:register OReg(R0)}  r0:int;
var{:register OReg(R1)}  r1:int;
var{:register OReg(R2)}  r2:int;
var{:register OReg(R3)}  r3:int;
var{:register OReg(R4)}  r4:int;
var{:register OReg(R5)}  r5:int;
var{:register OReg(R6)}  r6:int;
var{:register OReg(R7)}  r7:int;
var{:register OReg(R8)}  r8:int;
var{:register OReg(R9)}  r9:int;
var{:register OReg(R10)} r10:int;
var{:register OReg(R11)} r11:int;
var{:register OReg(R12)} r12:int;

var{:register OSP} sp:int;
var{:register OLR} lr:int;

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV

function{:operand} sp_op_const(n:word):operand

procedure {:instruction Ins(ADD(dst, src1, src2))}
ADD(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        isUInt32(src1 + src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 + src2), this);
        WordAligned(src1) && WordAligned(src2) ==> WordAligned(dst);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(SUB(dst, src1, src2))}
SUB(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        isUInt32(src1 - src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 - src2), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MUL(dst, src1, src2))}
MUL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@src1);
        ValidRegOperand(@src2);
        ValidRegOperand(@dst);
        isUInt32(src1 * src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 * src2), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(UDIV(dst, src1, src2))}
UDIV(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        src2 > 0;
        isUInt32(src1 / src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 / src2), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(AND(dst, src1, src2))}
AND(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseAnd(src1, src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(ORR(dst, src1, src2))}
ORR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseOr(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(EOR(dst, src1, src2))}
EOR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseXor(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LSL(dst, src1, src2))}
LSL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(LeftShift(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LSR(dst, src1, src2))}
LSR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(RightShift(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MVN(dst, src))}
MVN(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseNot(src)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MOV(dst, src))}
MOV(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(src), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR(rd, base, ofs))}
LDR(out{:operand} rd:int, {:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidMem(base + ofs);
    ensures
        evalUpdate(old(this), @rd, MemContents(old(this.m), old(base + ofs)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(STR(rd, base, ofs))}
STR({:operand} rd:int, out{:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidMem(base + ofs);
    ensures
        evalMemUpdate(old(this), old(base + ofs), old(rd), this);
        AllRegsInvariant(old(this), this);
        GlobalsInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MRS(dst, src))}
MRS({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidSpecialOperand(this, @src);
        !ValidMcrMrcOperand(this, @src);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, SpecialOperandContents(old(this), @src), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

#verbatim
predicate is_psr(o:sp_operand)
{ // true if cpsr or spsr
    o.OSReg? && (o.sr.cpsr? || o.sr.spsr?)
}
#endverbatim

procedure {:instruction Ins(MSR(dst, src))}
MSR({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidRegOperand(@src);
    requires
        ValidSpecialOperand(this, @dst);
        !ValidMcrMrcOperand(this, @dst);
        is_psr(@dst) ==> ValidModeChange(this, src);
    ensures
        evalSRegUpdate(old(this), @dst, old(src), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MRC(dst, src))}
MRC({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidRegOperand(@dst);
        ValidMcrMrcOperand(this, @src);
    ensures
        evalUpdate(old(this), @dst, SpecialOperandContents(old(this), @src), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MCR(dst, src))}
MCR({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidRegOperand(@src);
    requires
        ValidMcrMrcOperand(this, @dst);
    ensures
        evalSRegUpdate(old(this), OSReg(scr), src, this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MOVS_PCLR_TO_USERMODE_AND_CONTINUE)}
MOVS_PCLR_TO_USERMODE_AND_CONTINUE()
    requires/ensures
        ValidState(this);
    requires 
        mode_of_state(this) != User;
        this.conf.spsr[mode_of_state(this)].m == User;
        ValidModeChange'(this, User);
    ensures
        evalMOVSPCLRUC(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR_reloc(rd, g))}
LDRglobaladdr(out{:operand} rd:int, {:operand} g:string)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidGlobal(@g);
    ensures
        evalUpdate(old(this), @rd, AddressOfGlobal(@g), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR_global(rd, g, base, ofs))}
LDRglobal(out{:operand} rd:int, {:operand} g:string,
          {:operand} base:int, {:operand} ofs:int)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidGlobalOffset(@g, ofs);
        AddressOfGlobal(@g) == base;
    ensures
        evalUpdate(old(this), @rd, old(GlobalWord(this.m, @g, ofs)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(STR_global(rd, g, base, ofs))}
STRglobal({:operand} rd:int, {:operand} g:string,
          {:operand} base:int, {:operand} ofs:int)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidGlobalOffset(@g, ofs);
        AddressOfGlobal(@g) == base;
        isUInt32(rd);
    ensures
        evalGlobalUpdate(old(this), @g, old(ofs), old(rd), this);
        AllRegsInvariant(old(this), this);
        AddrMemInvariant(old(this), this);
{
    reveal_sp_eval();
}
