/*
var{:register OReg(R0)}  r0:int;
var{:register OReg(R1)}  r1:int;
var{:register OReg(R2)}  r2:int;
var{:register OReg(R3)}  r3:int;
var{:register OReg(R4)}  r4:int;
var{:register OReg(R5)}  r5:int;
var{:register OReg(R6)}  r6:int;
var{:register OReg(R7)}  r7:int;
var{:register OReg(R8)}  r8:int;
var{:register OReg(R9)}  r9:int;
var{:register OReg(R10)} r10:int;
var{:register OReg(R11)} r11:int;
var{:register OReg(R12)} r12:int;

var{:register OSP} sp:int;
var{:register OLR} lr:int;

var{:register OReg(SP(User))}       sp_usr:int;
var{:register OReg(SP(FIQ))}        sp_fiq:int;
var{:register OReg(SP(IRQ))}        sp_irq:int;
var{:register OReg(SP(Supervisor))} sp_svc:int;
var{:register OReg(SP(Abort))}      sp_abt:int;
var{:register OReg(SP(Undefined))}  sp_und:int;
var{:register OReg(SP(Monitor))}    sp_mon:int;

var{:register OReg(LR(User))}       lr_usr:int;
var{:register OReg(LR(FIQ))}        lr_fiq:int;
var{:register OReg(LR(IRQ))}        lr_irq:int;
var{:register OReg(LR(Supervisor))} lr_svc:int;
var{:register OReg(LR(Abort))}      lr_abt:int;
var{:register OReg(LR(Undefined))}  lr_und:int;
var{:register OReg(LR(Monitor))}    lr_mon:int;

var{:register OSReg(spsr(FIQ))}        spsr_fiq:int;
var{:register OSReg(spsr(IRQ))}        spsr_irq:int;
var{:register OSReg(spsr(Supervisor))} spsr_svc:int;
var{:register OSReg(spsr(Abort))}      spsr_abt:int;
var{:register OSReg(spsr(Undefined))}  spsr_und:int;
var{:register OSReg(spsr(Monitor))}    spsr_mon:int;


procedure operator(:=) (out{:operand} dst:int, {:operand} src:int) := MOV

function{:operand} sp_op_const(n:word):operand
procedure {:instruction Ins(ADD(dst, src1, src2))}
ADD(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidSecondOperand(@src2);
        ValidRegOperand(@dst);
        isUInt32(src1 + src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 + src2), this);
        WordAligned(old(src1)) && WordAligned(old(src2)) ==> WordAligned(dst);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(ADD(dst, src1, src2))}
ADDWrap(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidSecondOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(src1 + src2) % 0x1_0000_0000, this);
        WordAligned(old(src1)) && WordAligned(old(src2)) ==> WordAligned(dst);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(SUB(dst, src1, src2))}
SUB(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        isUInt32(src1 - src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 - src2), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MUL(dst, src1, src2))}
MUL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@src1);
        ValidRegOperand(@src2);
        ValidRegOperand(@dst);
        isUInt32(src1 * src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 * src2), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(UDIV(dst, src1, src2))}
UDIV(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        src2 > 0;
        isUInt32(src1 / src2);
    ensures
        evalUpdate(old(this), @dst, old(src1 / src2), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(AND(dst, src1, src2))}
AND(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseAnd(src1, src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(ORR(dst, src1, src2))}
ORR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseOr(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(EOR(dst, src1, src2))}
EOR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidSecondOperand(@src2);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseXor(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LSL(dst, src1, src2))}
LSL(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(LeftShift(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LSR(dst, src1, src2))}
LSR(out{:operand} dst:int, {:operand} src1:int, {:operand} src2:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src1);
        ValidOperand(@src2);
        ValidRegOperand(@dst);
        @src2 is OConst;
        0 <= src2 < 32;
    ensures
        evalUpdate(old(this), @dst, old(RightShift(src1,src2)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(REV(dst, src))}
REV(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@src);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(bswap32(src)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MVN(dst, src))}
MVN(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidOperand(@src);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(BitwiseNot(src)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MOV(dst, src))}
MOV(out{:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        ValidSecondOperand(@src);
        ValidRegOperand(@dst);
    ensures
        evalUpdate(old(this), @dst, old(src), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR(rd, base, ofs))}
LDR(out{:operand} rd:int, {:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidMem(base + ofs);
    ensures
        evalUpdate(old(this), @rd, MemContents(old(this.m), old(base + ofs)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(STR(rd, base, ofs))}
STR({:operand} rd:int, out{:operand} base:int, {:operand} ofs:int)
    requires/ensures
        ValidState(this);
    requires
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidMem(base + ofs);
    ensures
        evalMemUpdate(old(this), old(base + ofs), old(rd), this);
        AllRegsInvariant(old(this), this);
        GlobalsInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MRS(dst, src))}
MRS({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        priv_of_state(this) == PL1;
        ValidRegOperand(@dst);
        ValidSpecialOperand(this, @src) && !ValidMcrMrcOperand(this, @src) || ValidBankedRegOperand(this, @src);
    ensures
        evalUpdate(old(this), @dst, if @src is OSReg then SpecialOperandContents(old(this), @src) else old(src), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

#verbatim
predicate is_psr(o:sp_operand)
{ // true if cpsr
    o.OSReg? && o.sr.cpsr?
}
predicate is_spsr(o:sp_operand)
{
    o.OSReg? && o.sr.spsr?
}
#endverbatim

procedure {:instruction Ins(MSR(dst, src))}
MSR({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
    requires
        priv_of_state(this) == PL1;
        ValidRegOperand(@src);
        ValidSpecialOperand(this, @dst) && !ValidMcrMrcOperand(this, @dst) || ValidBankedRegOperand(this, @dst);
        is_psr(@dst) ==> ValidModeChange(this, src);
        is_spsr(@dst) ==> ValidModeEncoding(psr_mask_mode(src));
    ensures
        if @dst is OSReg then evalSRegUpdate(old(this), @dst, old(src), this)
            else evalUpdate(old(this), @dst, old(src), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MRC(dst, src))}
MRC({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidRegOperand(@dst);
        ValidMcrMrcOperand(this, @src);
    ensures
        evalUpdate(old(this), @dst, SpecialOperandContents(old(this), @src), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MCR(dst, src))}
MCR({:operand} dst:int, {:operand} src:int)
    requires/ensures
        ValidState(this);
        ValidRegOperand(@src);
    requires
        ValidMcrMrcOperand(this, @dst);
    ensures
        evalSRegUpdate(old(this), OSReg(scr), src, this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(MOVS_PCLR_TO_USERMODE_AND_CONTINUE)}
MOVS_PCLR_TO_USERMODE_AND_CONTINUE()
    requires/ensures
       ValidState(this);
    requires 
        ValidModeChange'(this, User);
        spsr_of_state(this).m == User;
    ensures
        evalMOVSPCLRUC(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR_reloc(rd, g))}
LDRglobaladdr(out{:operand} rd:int, {:operand} g:string)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidGlobal(@g);
    ensures
        evalUpdate(old(this), @rd, AddressOfGlobal(@g), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(LDR_global(rd, g, base, ofs))}
LDRglobal(out{:operand} rd:int, {:operand} g:string,
          {:operand} base:int, {:operand} ofs:int)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidGlobalOffset(@g, ofs);
        AddressOfGlobal(@g) == base;
    ensures
        evalUpdate(old(this), @rd, old(GlobalWord(this.m, @g, ofs)), this);
        SRegsInvariant(old(this), this);
        AllMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

procedure {:instruction Ins(STR_global(rd, g, base, ofs))}
STRglobal({:operand} rd:int, {:operand} g:string,
          {:operand} base:int, {:operand} ofs:int)
    requires
        ValidState(this);
        ValidRegOperand(@rd);
        ValidOperand(@base);
        ValidOperand(@ofs);
        ValidGlobalOffset(@g, ofs);
        AddressOfGlobal(@g) == base;
        isUInt32(rd);
    ensures
        evalGlobalUpdate(old(this), @g, old(ofs), old(rd), this);
        AllRegsInvariant(old(this), this);
        AddrMemInvariant(old(this), this);
{
    reveal_sp_eval();
}

////////////////////////////////////////////////////////////////////////////////
//
//   Support for Spartan's refined mode
//
////////////////////////////////////////////////////////////////////////////////
*/
var{:state ok()}  ok:bool;
var{:state mem()} mem:memmap;
var{:state globals()} globals:map(operand, seq(word));
var{:state osp()} sp:word;
var{:state olr()} lr:word;

var{:state reg(R0)}  r0:word;
var{:state reg(R1)}  r1:word;
var{:state reg(R2)}  r2:word;
var{:state reg(R3)}  r3:word;
var{:state reg(R4)}  r4:word;
var{:state reg(R5)}  r5:word;
var{:state reg(R6)}  r6:word;
var{:state reg(R7)}  r7:word;
var{:state reg(R8)}  r8:word;
var{:state reg(R9)}  r9:word;
var{:state reg(R10)} r10:word;
var{:state reg(R11)} r11:word;
var{:state reg(R12)} r12:word;


procedure {:refined} {:instruction Ins(LDR(rd, base, ofs))}
rLDR(out{:operand} rd:word, {:operand} base:word, {:operand} ofs:word)
    requires
        ValidAddr(mem, base + ofs);
    reads mem;
    ensures
        rd == mem[old(base) + old(ofs)];
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(LDR_reloc(rd, OSymbol(g)))}
rLDRglobaladdr(out{:operand} rd:word, {:inline} g:global)
    requires ValidGlobal(OSymbol(g));
    ensures
        rd == AddressOfGlobal(OSymbol(g));
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

#verbatim

predicate ValidGlobals(globals:map<operand, seq<word>>)
{
      (forall g :: g in TheGlobalDecls() <==> g in globals)
   && (forall g :: g in TheGlobalDecls()
        ==> |globals[g]| == BytesToWords(TheGlobalDecls()[g]))
}
predicate ValidGlobalsAddr(globals:map<operand, seq<word>>, g:operand, addr:int)
{
    ValidGlobals(globals)
 && ValidGlobal(g) && WordAligned(addr) 
 && AddressOfGlobal(g) <= addr < AddressOfGlobal(g) + SizeOfGlobal(g)
}
#endverbatim

procedure {:refined} {:instruction Ins(LDR_global(rd, OSymbol(g), base, ofs))}
rLDRglobal(out{:operand} rd:word, {:inline} g:global,
          {:operand} base:word, {:operand} ofs:word)
    requires
        ValidGlobalsAddr(globals, OSymbol(g), base + ofs);
    reads
        globals;
    ensures
        rd == globals[OSymbol(g)][BytesToWords(base + ofs - AddressOfGlobal(OSymbol(g)))];
        //GlobalWord(this.m, g, base + ofs - g);
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(STR(rd, base, ofs))}
rSTR({:operand} rd:reg, {:operand} base:word, {:operand} ofs:word)
    requires/ensures
        ValidAddr(mem, base + ofs);
    modifies
        mem;
    ensures
        mem == old(mem)[old(base+ofs) := rd];
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(MOV(dst, src))}
rMOV(out{:operand} dst:word, {:operand} src:word)
    ensures
        dst == old(src);
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(MOV(dst, OShift(GetProbableReg(src), shift)))}
rMOVShift(out{:operand} dst:word, {:operand} src:snd, {:inline} shift:Shift)
    ensures
        dst == old(EvalShift(old(src), shift));
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(EOR(dst, src1, src2))}
rEOR(out{:operand} dst:word, {:operand} src1:word, {:operand} src2:word)
    ensures
        dst == BitwiseXor(old(src1), old(src2));
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(EOR(dst, src1, OShift(GetProbableReg(src2), shift)))}
rEORShift(out{:operand} dst:word, {:operand} src1:word, {:operand} src2:snd, {:inline} shift:Shift)
    ensures
        dst == BitwiseXor(old(src1), EvalShift(old(src2), shift));
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(ADD(dst, src1, src2))}
rADDWrap(out{:operand} dst:word, {:operand} src1:word, {:operand} src2:word)
    ensures
        dst == old(src1 + src2) % 0x1_0000_0000;
        //WordAligned(old(src1)) && WordAligned(old(src2)) ==> WordAligned(dst);
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(ADD(dst, src1, OShift(GetProbableReg(src2), shift)))}
rADDWrapShift(out{:operand} dst:word, {:operand} src1:word, {:operand} src2:snd, {:inline} shift:Shift)
    ensures
        dst == old(src1 + EvalShift(old(src2), shift)) % 0x1_0000_0000;
        //WordAligned(old(src1)) && WordAligned(old(EvalShift(old(src2), shift))) ==> WordAligned(dst);
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}

procedure {:refined} {:instruction Ins(AND(dst, src1, src2))}
rAND(out{:operand} dst:word, {:operand} src1:word, {:operand} src2:word)
    ensures
        dst == old(BitwiseAnd(src1, src2));
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}


procedure {:refined} {:instruction Ins(REV(dst, src))}
rREV(out{:operand} dst:word, {:operand} src:reg)
    ensures
        dst == old(bswap32(src));
{
    reveal evalCodeOpaque;
    reveal ValidRegState;
    reveal ValidMemState;
    reveal ValidConfig;
    reveal ValidSRegState;

    if ghost (!(old(this).ok && this.ok)) {
        this := old(this).(ok := false);
    } 
}
