#token += precedence :=
#token &= precedence :=
#token ^= precedence :=

procedure operator(:=) (out{:operand} dst:int, {:operand} src:int)   := MOV
procedure operator(+=) (inout{:operand} dst:int, {:operand} src:int) := plusEquals
procedure operator(&=) (inout{:operand} dst:int, {:operand} src:int) := andEquals
procedure operator(^=) (inout{:operand} dst:int, {:operand} src:int) := xorEquals

procedure ComputeOneStep_SHA256_spartan(
  {:local stack(0)} a:int,
  {:local stack(1)} b:int,
  {:local stack(2)} c:int,
  {:local stack(3)} d:int,
  {:local stack(4)} e:int,
  {:local stack(5)} f:int,
  {:local stack(6)} g:int,
  {:local stack(7)} h:int,
  {:inline} K:int,    // Round constant
  {:operand} W:int,   // Current word of input
  ghost atoh:atoh_Type,
  ghost z:SHA256Trace,
  ghost currentBlock:uint32, 
  ghost currentStep:uint32, 
  ghost numBlocks:uint32,
  ghost currentState:SHA256_state,
  out{:local stack(8)}  a_next:int,
  out{:local stack(9)}  b_next:int,
  out{:local stack(10)} c_next:int,
  out{:local stack(11)} d_next:int,
  out{:local stack(12)} e_next:int,
  out{:local stack(13)} f_next:int,
  out{:local stack(14)} g_next:int,
  out{:local stack(15)} h_next:int
)
returns (ghost next_atoh:atoh_Type, ghost next_z:SHA256Trace)
  requires/ensures
    // Spartan requirements
    StackContainsRange(this, 0, 16);
    ValidState(this);
    isUInt32(K);
    ValidOperand(this, @W);
  requires
    // TODO: Why does it timeout when these requires/ensures are folded into StackContainsRange?
    isUInt32(a);
    isUInt32(b);
    isUInt32(c);
    isUInt32(d);
    isUInt32(e);
    isUInt32(f);
    isUInt32(g);
    isUInt32(h);

    !IsMemOperand(@W);

    // SHA requirements
    currentStep <= 63;
    currentBlock < 0xFFFF_FFFE;
    K == int(K_SHA256(currentStep)); 
    atoh == atoh_c(uint32(a), uint32(b), uint32(c), uint32(d), uint32(e), uint32(f), uint32(g), uint32(h));
    currentState.atoh == atoh;
    currentState.num_blocks == numBlocks;
    0 <= int(currentStep) < SeqLength(currentState.W) && int(currentState.W[currentStep]) == W;
    IsSHA256ReadyForStep(z, currentState, int(currentBlock), int(currentStep));

  ensures
    isUInt32(a_next);
    isUInt32(b_next);
    isUInt32(c_next);
    isUInt32(d_next);
    isUInt32(e_next);
    isUInt32(f_next);
    isUInt32(g_next);
    isUInt32(h_next);
    next_atoh == atoh_c(uint32(a_next), uint32(b_next), uint32(c_next), uint32(d_next), uint32(e_next), uint32(f_next), uint32(g_next), uint32(h_next));
    IsSHA256ReadyForStep(next_z, currentState.(atoh := next_atoh), int(currentBlock), int(currentStep)+1);
{

  ghost var T1 := BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(
    BitwiseAdd32(currentState.atoh.h, BSIG1(currentState.atoh.e)), Ch(currentState.atoh.e, currentState.atoh.f,
        currentState.atoh.g)), K_SHA256(currentStep)), currentState.W[currentStep]);
  
  ghost var T2 := BitwiseAdd32(BSIG0(currentState.atoh.a),
    Maj(currentState.atoh.a,
        currentState.atoh.b,
        currentState.atoh.c));


  // Moves LDR/STR
  LDR(r0, a); 
  STR(r0, b_next);
  LDR(r1, b);
  STR(r1, c_next);
  LDR(r2, c);
  STR(r2, d_next);
  r3     := r1;

  lemma_BitwiseCommutative(uint32(r1), uint32(r0));
  r1 &= r0; // b & a
  r3 &= r2; // b & 
  lemma_BitwiseCommutative(uint32(r2), uint32(r0));
  r2 &= r0; // c & a
  r1 ^= r2;
  r1 ^= r3; // my_maj
  forall :: r1 == int(Maj(uint32(a), uint32(b), uint32(c)))
  {
    reveal_Maj();
  }

  //    After above block, live: 
  //    r0 == a
  //    r1 == my_maj

  // Calculate bsig0
  r2 := r0;
  r3 := r0;
  ROR(r0, r0, 2);
  ROR(r2, r2, 13);
  r0 ^= r2;
  ROR(r3, r3, 22);
  r0 ^= r3;   // == bsig0
  forall :: r0 == int(BSIG0(uint32(a)))
  {
    reveal_BSIG0();
  }
  r0 += r1; // == T2
  assert r0 == int(BitwiseAdd32(BSIG0(currentState.atoh.a), Maj(currentState.atoh.a, currentState.atoh.b, currentState.atoh.c)));
  //    After above block, live: 
  //    r0 == T2

  // Calculate my_ch
  LDR(r1, e);
  STR(r1, f_next);
  r3    := r1;
  MVN(r3,r3);
  LDR(r2, g);
  STR(r2, h_next);
  r3    &= r2; // !e & g
  assert r3 == int(BitwiseAnd(uint32(not32(e)), uint32(g)));
  LDR(r2, f); 
  STR(r2, g_next);
  lemma_BitwiseCommutative(uint32(r2), uint32(r1));
  r2    &= r1; // f & e  // Need commutativity
  lemma_BitwiseCommutative(uint32(r2), uint32(r3));
  r2    ^= r3; // my_ch  // Need commutativity
  // assume r2 == int(Ch(uint32(e), uint32(f), uint32(g)));
  forall :: r2 == int(Ch(uint32(e), uint32(f), uint32(g)))
  {
    reveal_Ch();
  }



  //    After above block, live: 
  //      r0 == T2
  //      r1 == e
  //      r2 == my_ch

  // Calculate bsig1                  
  r3 := r1;
  r4 := r1;
  ROR(r3, r3, 6);
  ROR(r4, r4, 11);
  r3 ^= r4;
  ROR(r1, r1, 25);
  r3 ^= r1;   // == bsig1
  forall :: r3 == int(BSIG1(uint32(e)))
  {
    reveal_BSIG1();
  }

  //    After above block, live: 
  //      r0 == T2
  //      r2 == my_ch
  //      r3 == bsig1

  assume r3 == int(BSIG1(currentState.atoh.e));
  assume r2 == int(Ch(currentState.atoh.e,
    currentState.atoh.f, currentState.atoh.g));
  // Calculate T1
  LDR(r1, h); 
  assume r1 == int(currentState.atoh.h);
  r1 += r3; // Frees r3
  r1 += r2; // Frees r2
  assume K == int(K_SHA256(currentStep));
  assume W == int(currentState.W[currentStep]);
  r1 += K;
  r2 := W;
  r1 += r2; // T1
  assume isUInt32(r1);
  assert uint32(r1) == T1;
  // assume uint32(r1) == T1;
  // assert uint32(r1) == T1;
  //    After above block, live: 
  //      r0 == T2
  //      r1 == T1
  
  // assume r0 == int(T2);   
  // assume r1 == int(T1);   
  r0 += r1; // T2 + T1 == a_next    
  // assume r0 == int(BitwiseAdd32(T1, T2));
  STR(r0, a_next); 
  assume isUInt32(d);
  LDR(r0, d);
  r0 += r1; // d + T1
  STR(r0, e_next); 

  // assume e_next == int(BitwiseAdd32(uint32(d),T1));
  // assume a_next == int(BitwiseAdd32(T1, T2));


  // OBSERVE: Triggers gallore!
  assert TBlk(currentBlock) && TBlk(currentBlock + 1) && TStep(currentStep) && TStep(currentStep + 1);

   next_atoh := atoh_c(uint32(a_next), uint32(b_next), uint32(c_next), uint32(d_next), uint32(e_next), uint32(f_next), uint32(g_next), uint32(h_next));
  next_z := SHA256Trace_c(z.M, z.H, z.W, SeqDrop(z.atoh, int(currentBlock)) + SeqBuild(SeqAppendElt(z.atoh[currentBlock], next_atoh)));
  ghost var next_s := currentState.(atoh := next_atoh); 
  // assume false;
  lemma_SHA256TransitionOKAfterSettingAtoH(z, currentState, next_z, next_s, currentBlock, currentStep);
}

//procedure main()
//  requires
//    NonEmptyStack(sp_s);
//    StackContains(sp_s, 1);
//    StackContains(sp_s, 2);
//    1 <= stackval(sp_s, stack(1));
//{
//  foo();
//}

#verbatim
method Main()
{
  printHeader();
  var n := printCode(sp_code_ComputeOneStep_SHA256_spartan(33, OId(LocalVar(5000))), 0);
  printFooter();
}
#endverbatim

