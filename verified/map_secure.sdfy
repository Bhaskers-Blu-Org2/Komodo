// include {:verbatim} "kom_common.i.dfy"
// include {:verbatim} "pagedb.i.dfy"
// include {:verbatim} "smcapi.i.dfy"
// include {:verbatim} "ptebits.i.dfy"
// 
// include "ARMdecls.sdfy"
// include "kom_utils.sdfy"
// include "allocate_page.sdfy"
// include "map_utils.sdfy"
// include "memset.sdfy"
include "map_secure_utils.sdfy"

procedure map_secure_success(
    inout operand page:reg,
    operand as_page:reg,
    operand mapping:reg,
    inout operand insecure_vaddr:reg,
    operand l1pte:reg,
    operand pagedb_base:reg,
    out operand err:reg,
    ghost phys_page: word,
    ghost pagedb_in: PageDb)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        @page == OReg(R1) && @as_page == OReg(R2) && @mapping == OReg(R3)
            && @insecure_vaddr == OReg(R4) && @l1pte == OReg(R10) && @err == OReg(R0);
        @pagedb_base == OReg(R12);
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in) && pageDbCorresponds(this.m, pagedb_in);
        // errors already checked
        isAddrspace(pagedb_in, as_page)
            && isValidMappingTarget(pagedb_in, as_page, mapping) == KOM_ERR_SUCCESS
            && (phys_page == 0 || physPageIsInsecureRam(phys_page));
        insecure_vaddr == (if phys_page == 0 then 0
                else phys_page * PAGESIZE + KOM_DIRECTMAP_VBASE);
        l1pte == mkL1Pte(pagedb_in[pagedb_in[as_page].entry.l1ptnr].entry
                            .l1pt[wordToMapping(mapping).l1index], 0);
    modifies
        globals; mem; r0; r7; r8; r9; r11; r12;
    ensures
        SmcProcedureInvariant(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PageDb()));
        tuple(pagedb, err) == old(smc_mapSecure_premium(pagedb_in, page, as_page,
            mapping, phys_page, maybeContentsOfPhysPage(this, phys_page)));
        pageDbCorresponds(this.m, pagedb);
{
    reveal smc_mapSecure_premium;
    ghost var contents := maybeContentsOfPhysPage(this, phys_page);
    ghost var specResult := smc_mapSecure_premium(pagedb_in, page, as_page,
            mapping, phys_page, contents);
    ghost var entry := PageDbEntryTyped(as_page, DataPage(fromJust(contents)));

    pagedb := allocate_page(page, as_page, const(KOM_PAGE_DATA),
                            pagedb_base, r11, r9, err, pagedb_in, entry);
    if (err == const(KOM_ERR_SUCCESS)) {
        ghost var tmpst := this;
        assert err == specErr(specResult);
        assert page == old(page) && as_page == old(as_page);
        assert pageDbCorrespondsExcluding(this.m, pagedb, page)
          && pageDbEntryCorresponds(pagedb[page], extractPageDbEntry(this.m, page));
        assert contentsOfPhysPage(old(this), old(phys_page))
            == contentsOfPhysPage(this, old(phys_page))
            by { assert InsecureMemInvariant(old(this), this); }
        assert isValidMappingTarget(pagedb, as_page, mapping) == KOM_ERR_SUCCESS
        by {
            assert isValidMappingTarget(pagedb_in, as_page, mapping)
                == KOM_ERR_SUCCESS;
            lemma_allocatePage_preservesMappingGoodness(
                pagedb_in,old(page),as_page,entry.entry,
                pagedb,err,mapping);
        }

        init_secure_page(page, insecure_vaddr, phys_page, entry.entry);
        AllButOnePagePreserving(old(page), tmpst, this);

        assert pageContentsCorresponds(old(page), entry,
                                       extractPage(this.m, old(page)))
            by { reveal pageContentsCorresponds; }
        assert page == old(page) && as_page == old(as_page);
        assert pageDbCorrespondsExcluding(this.m,pagedb,page);
        assert pageDbEntryCorresponds(pagedb[page],
                extractPageDbEntry(this.m,page));
    
        ghost var abs_mapping := wordToMapping(mapping);
        reveal wordToMapping;
        ghost var l2pte := SecureMapping(old(page), 
            abs_mapping.perm.w, abs_mapping.perm.x);
        assert validL2PTE(pagedb, as_page, l2pte);

        mkL2Pte_secure(mapping, page, abs_mapping, l2pte);
        pagedb := update_l2pte(as_page, mapping, page, l1pte, r8, r12,
                              pagedb, abs_mapping, l2pte);
    
        assert pageDbCorresponds(this.m, pagedb);
        assert pagedb == specPageDb(specResult);
        err := const(KOM_ERR_SUCCESS);
    }
}

procedure kom_smc_map_secure(
    inout operand page:reg,
    operand as_page:reg,
    operand mapping:reg,
    inout operand phys_page:reg,
    operand pagedb_base:reg,
    out operand err:reg,
    ghost pagedb_in: PageDb)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        @page == OReg(R1) && @as_page == OReg(R2) && @mapping == OReg(R3)
            && @phys_page == OReg(R4) && @err == OReg(R0);
        @pagedb_base == OReg(R12);
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    modifies
        globals; mem; r0; r7; r8; r9; r10; r11; r12;
    ensures
        SmcProcedureInvariant(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PageDb()));
        tuple(pagedb, err) == old(smc_mapSecure_premium(pagedb_in, page, as_page,
            mapping, phys_page, maybeContentsOfPhysPage(this, phys_page)));
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    reveal smc_mapSecure_premium;
    ghost var specResult := smc_mapSecure_premium(pagedb, page, as_page,
            mapping, phys_page, maybeContentsOfPhysPage(this, phys_page));

    if (as_page >= const(KOM_SECURE_NPAGES)) {
        err := const(KOM_ERR_INVALID_ADDRSPACE);
        assert err == specErr(specResult);
    } else {
        assert validPageNr(as_page);
        load_page_type(as_page, pagedb_base, err, err, pagedb);
        if (err != const(KOM_PAGE_ADDRSPACE)) {
            assert !isAddrspace(pagedb, as_page);
            err := const(KOM_ERR_INVALID_ADDRSPACE);
            assert err == specErr(specResult);
        } else {
            assert as_page == old(as_page);
            assert isAddrspace(pagedb, as_page);
            is_valid_mapping_target(as_page,mapping,r10,err,pagedb);
            // NB: r10 := l1pte
            if( err != const(KOM_ERR_SUCCESS) ) {
                assert err == specErr(specResult);
            } else {
                insecure_phys_to_virt(phys_page, err);
                if (err == 0) {
                    err := const(KOM_ERR_INVALID_PAGENO);
                    assert err == specErr(specResult);
                } else {
                    ghost var contents := maybeContentsOfPhysPage(old(this), old(phys_page));
                    assert contents is Just;
                    ghost var entry := PageDbEntryTyped(old(as_page), DataPage(fromJust(contents)));
                    assert entry.addrspace == as_page;
                    assert validAddrspacePage(pagedb, entry.addrspace);
                    assert page == old(page);
                    pagedb := map_secure_success(page, as_page, mapping,
                                                 phys_page, r10, pagedb_base, err,
                                                 old(phys_page), pagedb);
                    assert err == specErr(specResult);
                    assert pagedb == specPageDb(specResult);
                }
            }
        }
    }
}
