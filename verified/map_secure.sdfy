include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"
include {:verbatim} "ptebits.i.dfy"

include "ARMdecls-unrefined.sdfy"
include "kom_utils.sdfy"
include "allocate_page.sdfy"
include "map_utils.sdfy"

procedure update_l2pte(
    {:register OReg(R2)} as_page:int,
    {:register OReg(R3)} mapping:int,
    {:register OReg(R6)} l2pte:int,//page:int,
    {:register OReg(R10)} l1pte:int,
    ghost d:PageDb,
    ghost abs_mapping:Mapping,
    ghost l2pte_abs:L2PTE
)   returns (ghost d':PageDb)
    requires/ensures
        SaneState(this);
    requires 
        validPageDb(d) && wellFormedPageDb(d);
        abs_mapping.l1index == wordToMapping(mapping).l1index;
        abs_mapping.l2index == wordToMapping(mapping).l2index;
        l2pte_abs is SecureMapping ==> (
            pageDbCorrespondsExcluding(this.m,d,l2pte_abs.page)
            && pageDbEntryCorresponds(d[l2pte_abs.page],
                extractPageDbEntry(this.m,l2pte_abs.page)));
        !(l2pte_abs is SecureMapping) ==> pageDbCorresponds(this.m, d);
        isAddrspace(d, as_page);
        validMapping(abs_mapping,d,as_page);
        d[as_page].entry.state is InitState;
        validL2PTE(d, as_page, l2pte_abs);
        l2pte == mkL2Pte(l2pte_abs);
        l1pte == mkL1Pte(d[d[as_page].entry.l1ptnr].entry.l1pt[abs_mapping.l1index], 0);
    ensures 
        validPageDb(d');
        d' == updateL2Pte(d, as_page, abs_mapping, l2pte_abs);
        pageDbCorresponds(this.m,d');
        GlobalsInvariant(old(this),this);
        SmcProcedureInvariant(old(this),this);
{
    reveal_validPageDb();
    ghost var a := as_page;
    ghost var addrspace := d[a].entry;
    assert validAddrspace(d, a);
    ghost var l1 := d[addrspace.l1ptnr].entry;
    ghost var l1pte_abs := fromJust(l1.l1pt[abs_mapping.l1index]);
    ghost var l2pt := d[l1pte_abs].entry.l2pt;
    ghost var l2pt' := l2pt[ abs_mapping.l2index := l2pte_abs ];
    d' := updateL2Pte(d, as_page, abs_mapping, l2pte_abs);

    assert l1pte == ARM_L1PTE(page_paddr(l1pte_abs));
    lemma_ARM_L1PTE_Dual(page_paddr(l1pte_abs));
    SUB(r12,l1pte,1);
    assert r12 == page_paddr(l1pte_abs);
    ADD(r12, r12, sp_op_const(KOM_DIRECTMAP_VBASE));
    assert r12 == page_monvaddr(l1pte_abs);

    LSR(r8,mapping,12);
    AND(r8,r8,0xff);
    forall :: r8 == abs_mapping.l2index {
        reveal_wordToMapping();
        assert r8 == l2indexFromMapping(mapping);
    }
    lemma_LeftShift2(r8);
    LSL(r8,r8,2);
    assert r8 == WordsToBytes(abs_mapping.l2index);
    assert addrInPage(r12 + r8, l1pte_abs);

    assert r6 == mkL2Pte(l2pte_abs);
    STR(r6,r12,r8);

    forall :: pageDbCorrespondsOnly(this.m, d', l1pte_abs)
    {
        ghost var p := l1pte_abs;
        forall :: pageDbEntryCorresponds(d'[p], extractPageDbEntry(this.m, p)) {
            reveal_pageDbEntryCorresponds();
        }
        forall :: pageDbL2PTableCorresponds(p, d'[p].entry, extractPage(this.m, p))
        {
            ghost var base := page_monvaddr(p);
            ghost var old_page := extractPage(old(this.m), p);
            ghost var mem_page := extractPage(this.m, p);
            forall :: pageDbL2PTableCorresponds(p, d[p].entry, old_page) {
                reveal_pageContentsCorresponds();
                assert pageDbCorrespondsOnly(old(this.m), d, p);
            }
            reveal_pageDbL2PTableCorresponds();
            forall i :| 0 <= i < NR_L2PTES && i != abs_mapping.l2index
                :: mem_page[base+WordsToBytes(i)] == mkL2Pte(d'[p].entry.l2pt[i])
            {
                assert base + WordsToBytes(i) !=
                    page_monvaddr(l1pte_abs) + 
                    WordsToBytes(abs_mapping.l2index);
                assert mem_page[base+WordsToBytes(i)] == old_page[base+WordsToBytes(i)];
            }
            ghost var j := abs_mapping.l2index;
            assert mem_page[base+WordsToBytes(j)] == mkL2Pte(d'[p].entry.l2pt[j]);
        }
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(p, d'[p], extractPage(this.m, p));
    }

    assert d'[l1pte_abs] is PageDbEntryTyped &&
        d'[l1pte_abs].entry is L2PTable;

    forall :: pageDbCorrespondsExcluding(this.m, d', l1pte_abs) 
    {   
        forall i :| validPageNr(i) && i != l1pte_abs ::
            extractPage(this.m, i) == extractPage(old(this.m), i){}
        forall i :| validPageNr(i) && i != l1pte_abs && d'[i] is PageDbEntryTyped ::
            pageContentsCorresponds(i, d'[i], extractPage(this.m, i))
        {
            reveal_pageContentsCorresponds();
            assert d[i] == d'[i];
            assert extractPage(this.m, i) == extractPage(old(this.m), i);
            assert pageContentsCorresponds(i, d[i], extractPage(old(this.m),i));
            assert pageContentsCorresponds(i, d'[i], extractPage(this.m,i));
        }
    }

    lemma_updateL2PtePreservesPageDb(d,a,abs_mapping,l2pte_abs);
}

procedure is_valid_mapping_target(
    operand addr:int,
    operand mapping:int,
    out operand l1pte:int,
    out {:register OReg(R0)} err:int,
    ghost d:PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@addr, @mapping, @l1pte, @err, @r7, @r8, @r9), 7);
        @l1pte != @lr;
        validPageDb(d);
        pageDbCorresponds(this.m,d);
        isAddrspace(d,addr);
    ensures
        RegPreservingExcept(old(this), this, set(@r7,@r8,@r9,@l1pte,@err));
        AllMemInvariant(old(this),this);
        SmcProcedureInvariant(old(this),this);
        err == isValidMappingTarget(d, addr, mapping);
        err == KOM_ERR_SUCCESS ==>(
            validAddrspacePage(d,addr) && 
            l1pte == mkL1Pte(d[d[addr].entry.l1ptnr].entry.l1pt[
                wordToMapping(mapping).l1index], 0) );
{
    ghost var specResult := isValidMappingTarget(d,addr,mapping);

    assert @l1pte != @err && @l1pte != @r7 && @l1pte != @addr && @l1pte != @mapping
        && @l1pte != @r7 && @l1pte != @r8 && @l1pte != @r9;

    page_monvaddr_impl(r7,addr,r8);
    LDR(r8,r7,sp_op_const(ADDRSPACE_STATE));
    forall :: r8 == pageDbAddrspaceStateVal(d[addr].entry.state)
    {
        reveal_pageContentsCorresponds();
        reveal_pageDbAddrspaceCorresponds();
    }
    if ( r8 != sp_op_const(KOM_ADDRSPACE_INIT) ){
        err := sp_op_const(KOM_ERR_ALREADY_FINAL);
        assert err == specResult;
    } else {
        ghost var abs_mapping := wordToMapping(mapping);
        reveal_wordToMapping();
        LSR(r7,mapping,20); 
        forall :: r7 == abs_mapping.l1index {
            reveal_wordToMapping();
        }
        LSR(r8,mapping,12);
        AND(r8,r8,0xff);
        forall :: r8 == abs_mapping.l2index {
            reveal_wordToMapping();
            assert r8 == l2indexFromMapping(mapping);
        }
        if(r7 >= sp_op_const(KOM_SECURE_NPAGES)){
            err := sp_op_const(KOM_ERR_INVALID_MAPPING);
            assert err == specResult;
        } else if(r8 >= sp_op_const(KOM_SECURE_NPAGES)){
            err := sp_op_const(KOM_ERR_INVALID_MAPPING);
            assert err == specResult;
        } else {
            //if(!perm.r) then KOM_ERR_INVALID_MAPPING
            AND(r9,mapping,sp_op_const(KOM_MAPPING_R));
            forall :: r9 == 0 <==> !abs_mapping.perm.r
            {
                reveal_wordToMapping();
                assert r9 != 0 <==> permFromMapping(mapping).r;
            }
            if(r9 == 0){
                err := sp_op_const(KOM_ERR_INVALID_MAPPING);
                assert err == specResult;
            } else {
                if(r7 >= sp_op_const(NR_L1PTES)){
                    err := sp_op_const(KOM_ERR_INVALID_MAPPING);
                    assert err == specResult;
                } else if (r8 >= sp_op_const(NR_L2PTES)) {
                    err := sp_op_const(KOM_ERR_INVALID_MAPPING);
                    assert err == specResult;
                } else {
                    LDRglobaladdr(l1pte,PageDb());
                    lemma_LeftShift3(addr);
                    LSL(r9,addr,sp_op_const(PAGEDB_ENTRY_SHIFT));
                    assert r9 == G_PAGEDB_ENTRY(addr) + PAGEDB_ENTRY_TYPE;
                    LDRglobal(r9,PageDb(),l1pte,r9);
                    forall :: validAddrspacePage(d, addr) {
                        assert isAddrspace(d, addr);
                    }

                    page_monvaddr_impl(r8,addr,l1pte);

                    LDR(r9,r8,sp_op_const(ADDRSPACE_L1PT)); 

                    ghost var l1p := d[addr].entry.l1ptnr;
                    forall :: validL1PTPage(d,l1p)
                    { 
                        assert validAddrspacePage(d, addr);
                        reveal_validPageDb();
                    
                    }
                    forall :: r9 == page_monvaddr(l1p)
                    {
                        assert pageDbCorrespondsOnly(this.m, d, addr);
                        assert validAddrspacePage(d, addr);
                        reveal_pageContentsCorresponds();
                        assert pageContentsCorresponds(addr, d[addr],
                            extractPage(this.m, addr));
                        reveal_pageDbAddrspaceCorresponds();
                    }
                    
                    assert r7 == abs_mapping.l1index;
                    ghost var l1index := r7;
                    fetch_l1pte(r9,r7,r8,l1pte,d,l1p);
                    assert l1pte == 0 <==> d[l1p].entry.l1pt[l1index] == Nothing;

                    if( l1pte == 0 ) {
                        err := sp_op_const(KOM_ERR_INVALID_MAPPING);
                    } else {
                        err := sp_op_const(KOM_ERR_SUCCESS);
                    }

                }
            }
        }
    }
}

procedure phys_page_is_insecure_ram_nz(
    operand phys_page:int,
    out operand ret:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@phys_page);
        ValidRegOperand(@ret);
        @phys_page != @ret;
        @phys_page != @sp;
        @ret != @sp;
    ensures 
        RegPreservingExcept(old(this), this, set(@ret));
        AllMemInvariant(old(this),this);
        SmcProcedureInvariant(old(this),this);
        ret == 0 <==> (phys_page != 0 && !physPageIsInsecureRam(phys_page));
{
    if (phys_page == 0) {
       ret := 1;
    } else {
        LDRglobaladdr(ret, SecurePhysBaseOp());
        LDRglobal(ret, SecurePhysBaseOp(), ret, 0);
        lemma_RightShift12(ret);
        LSR(ret,ret,12);
        assert ret == SecurePhysBase() / PAGESIZE;

        if(phys_page < ret)
        {
            assert physPageIsInsecureRam(phys_page);
            ret := 1;
        } else {
            ret := 0;
        }
    }
}

#verbatim
function method L2PTE_CONST_WORD():word
    { (ARM_L2PTE_CONST_BITS | 0x2) as word }

lemma lemma_extract_kom_mapping_w(mapping:word, res:word)
    requires res == BitwiseXor(BitwiseAnd(mapping,KOM_MAPPING_W),KOM_MAPPING_W)
    ensures res == KOM_MAPPING_W || res == 0
    ensures res == 0 <==> wordToMapping(mapping).perm.w
{
    assert WordAsBits(KOM_MAPPING_W) == 2 by { reveal_WordAsBits(); }
    lemma_WordBitEquiv(KOM_MAPPING_W, 2);

    var tmp := BitwiseAnd(mapping,KOM_MAPPING_W);
    assert (tmp == KOM_MAPPING_W || tmp == 0)
        by { reveal_BitAnd(); }
    assert wordToMapping(mapping).perm.w <==> tmp != 0
        by { reveal_wordToMapping(); }

    assert res == if tmp == 0 then KOM_MAPPING_W else 0
        by { reveal_BitXor(); }
}

lemma lemma_extract_kom_mapping_x(mapping:word, res:word)
    requires res == BitwiseXor(BitwiseAnd(mapping,KOM_MAPPING_X),KOM_MAPPING_X)
    ensures res == KOM_MAPPING_X || res == 0
    ensures res == 0 <==> wordToMapping(mapping).perm.x
{
    assert WordAsBits(KOM_MAPPING_X) == 4 by { reveal_WordAsBits(); }
    lemma_WordBitEquiv(KOM_MAPPING_X, 4);

    var tmp := BitwiseAnd(mapping,KOM_MAPPING_X);
    assert (tmp == KOM_MAPPING_X || tmp == 0)
        by { reveal_BitAnd(); }
    assert wordToMapping(mapping).perm.x <==> tmp != 0
        by { reveal_wordToMapping(); }

    assert res == if tmp == 0 then KOM_MAPPING_X else 0
        by { reveal_BitXor(); }
}

lemma lemma_shift_robit()
    ensures LeftShift(0, 8) == 0;
    ensures LeftShift(KOM_MAPPING_W, 8) == BitsAsWord(ARM_L2PTE_RO_BIT);
{
    assert WordAsBits(KOM_MAPPING_W) == 2 by { reveal_WordAsBits(); }
    assert BitsAsWord(ARM_L2PTE_RO_BIT) == 0x200 by { reveal_BitsAsWord(); }
    reveal_BitShiftLeft();
}

lemma lemma_shift_nxbit()
    ensures RightShift(0, 2) == 0;
    ensures RightShift(KOM_MAPPING_X, 2) == BitsAsWord(ARM_L2PTE_NX_BIT)
{
    assert WordAsBits(KOM_MAPPING_X) == 4 by { reveal_WordAsBits(); }
    assert BitsAsWord(ARM_L2PTE_NX_BIT) == 1 by { reveal_BitsAsWord(); }
    reveal_BitShiftRight();
}

lemma lemma_ARM_L2PTE_impl(pa: word, w: bool, x:bool, ptew: word)
    requires PageAligned(pa)
    requires ptew == BitwiseOr(BitwiseOr(BitwiseOr(pa, L2PTE_CONST_WORD()),
                        if x then 0 else BitsAsWord(ARM_L2PTE_NX_BIT)),
                        if w then 0 else BitsAsWord(ARM_L2PTE_RO_BIT))
    ensures ptew == ARM_L2PTE(pa, w, x)
{
    var constbits := ARM_L2PTE_CONST_BITS | 0x2;
    assert L2PTE_CONST_WORD() == BitsAsWord(constbits) by { reveal_BitsAsWord(); }
    lemma_WordBitEquiv(L2PTE_CONST_WORD(), constbits);
    var nxbit := if x then 0 else ARM_L2PTE_NX_BIT;
    var nxword := BitsAsWord(nxbit);
    lemma_WordBitEquiv(nxword, nxbit);
    var robit := if w then 0 else ARM_L2PTE_RO_BIT;
    var roword := BitsAsWord(robit);
    lemma_WordBitEquiv(roword, robit);

    calc {
         ptew;
         BitwiseOr(BitwiseOr(BitwiseOr(pa,L2PTE_CONST_WORD()), nxword), roword);
         { lemma_BitwiseOrAssociative(pa, L2PTE_CONST_WORD(), nxword); }
         BitwiseOr(BitwiseOr(pa,BitwiseOr(L2PTE_CONST_WORD(), nxword)), roword);
         { lemma_BitwiseOrAssociative(pa, BitwiseOr(L2PTE_CONST_WORD(), nxword), roword); }
         BitwiseOr(pa,BitwiseOr(BitwiseOr(L2PTE_CONST_WORD(), nxword), roword));
         { lemma_ExpandBitwiseOr(L2PTE_CONST_WORD(), nxword, roword); }
         BitwiseOr(pa, BitsAsWord(BitOr(BitOr(constbits, nxbit), robit)));
         { lemma_BitsAsWordAsBits(BitOr(BitOr(constbits, nxbit), robit)); }
         BitsAsWord(BitOr(WordAsBits(pa), BitOr(BitOr(constbits, nxbit), robit)));
         ARM_L2PTE(pa, w, x);
     }
}
#endverbatim

procedure ARM_L2PTE_impl(
    operand mapping:int,
    inout operand pte:int, // paddr at input time; pte at return
    out operand tmp:int,
    ghost abs_mapping:Mapping
)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@mapping, @pte, @tmp), 3);
        PageAligned(pte);
        abs_mapping == wordToMapping(mapping);
    ensures
        pte == ARM_L2PTE(old(pte), abs_mapping.perm.w, abs_mapping.perm.x);
        RegPreservingExcept(old(this),this,set(@pte,@tmp));
        AllMemInvariant(old(this),this);
        SmcProcedureInvariant(old(this),this);
{
    ghost var pa := pte;

    // construct const bits in tmp reg (they're too big for an inline constant)
    tmp := 0xd00;
    ADD(tmp, tmp, 0x76);
    assert tmp == L2PTE_CONST_WORD();

    // OR in const bits
    ORR(pte, pte, tmp);
    assert pte == BitwiseOr(pa, L2PTE_CONST_WORD());

    // compute nxbit
    ghost var nxbit := if abs_mapping.perm.x then 0 else BitsAsWord(ARM_L2PTE_NX_BIT);
    AND(tmp,mapping,sp_op_const(KOM_MAPPING_X));
    EOR(tmp,tmp,sp_op_const(KOM_MAPPING_X));
    lemma_extract_kom_mapping_x(mapping, tmp);
    assert (tmp == 0 || tmp == KOM_MAPPING_X)
           && (tmp == 0 <==> abs_mapping.perm.x);
    LSR(tmp,tmp,2);
    lemma_shift_nxbit();
    assert (tmp == 0 || tmp == BitsAsWord(ARM_L2PTE_NX_BIT))
           && (tmp == 0 <==> abs_mapping.perm.x);
    assert tmp == nxbit;
    ORR(pte, pte, tmp);
    assert pte == BitwiseOr(BitwiseOr(pa, L2PTE_CONST_WORD()), nxbit);

    assert RegPreservingExcept(old(this),this,set(@pte,@tmp));

    // compute robit
    ghost var robit := if abs_mapping.perm.w then 0 else BitsAsWord(ARM_L2PTE_RO_BIT);
    AND(tmp,mapping,sp_op_const(KOM_MAPPING_W));
    EOR(tmp,tmp,sp_op_const(KOM_MAPPING_W));
    lemma_extract_kom_mapping_w(mapping, tmp);
    assert (tmp == 0 || tmp == KOM_MAPPING_W)
           && (tmp == 0 <==> abs_mapping.perm.w);
    LSL(tmp,tmp,8);
    lemma_shift_robit();
    assert (tmp == 0 || tmp == BitsAsWord(ARM_L2PTE_RO_BIT))
           && (tmp == 0 <==> abs_mapping.perm.w);
    assert tmp == robit;
    ORR(pte, pte, tmp);
    assert pte == BitwiseOr(BitwiseOr(BitwiseOr(pa, L2PTE_CONST_WORD()), nxbit), robit);

    // prove that we did the right thing
    lemma_ARM_L2PTE_impl(pa, abs_mapping.perm.w, abs_mapping.perm.x, pte);
}

procedure mkL2Pte_secure(
    {:register OReg(R3)} mapping:int,
    inout {:register OReg(R6)} pagepte:int,
    ghost abs_mapping:Mapping,
    ghost l2pte:L2PTE
)
    requires/ensures
        SaneState(this);
    requires
        abs_mapping == wordToMapping(mapping);
        l2pte is SecureMapping;
        (l2pte.page == pagepte
            && abs_mapping.perm.x == l2pte.exec
            && abs_mapping.perm.w == l2pte.write);
    ensures
        pagepte == mkL2Pte(l2pte);
        RegPreservingExcept(old(this),this,set(@r0,@pagepte));
        AllMemInvariant(old(this),this);
        SmcProcedureInvariant(old(this),this);
{
    page_paddr_impl(pagepte,pagepte,r0);
    ARM_L2PTE_impl(mapping, pagepte, r0, abs_mapping);
}

procedure kom_smc_map_secure(
    {:register OReg(R1)} page:int,
    {:register OReg(R2)} as_page:int,
    {:register OReg(R3)} mapping:int,
    {:register OReg(R4)} phys_page:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        SmcProcedureInvariant(old(this),this);
        GlobalsPreservingExcept(old(this), this, set(PageDb()));
        tuple(pagedb,err) == smc_mapSecure_premium(pagedb_in, old(page), old(as_page),
            old(mapping), old(phys_page));
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    ghost var specResult := smc_mapSecure_premium(pagedb, page, as_page,
            mapping, phys_page);

    if (as_page >= sp_op_const(KOM_SECURE_NPAGES)) {
        err := sp_op_const(KOM_ERR_INVALID_ADDRSPACE);
    } else {
        assert validPageNr(as_page);
        LDRglobaladdr(r12, PageDb());
        assert sp_eval_op_addr(this, @r12) == AddressOfGlobal(PageDb());
        lemma_LeftShift3(as_page);
        LSL(r0, as_page, sp_op_const(PAGEDB_ENTRY_SHIFT));
        assert r0 == G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE;
        LDRglobal(r0, PageDb(), r12, r0);

        forall :: r0 == pageDbEntryTypeVal(pagedb[as_page]) {
            extractPageDbToAbstractOne(this.m, as_page, PAGEDB_ENTRY_TYPE);
            reveal_pageDbEntryCorresponds();
        }

        if (r0 != sp_op_const(KOM_PAGE_ADDRSPACE)) {
            assert !isAddrspace(pagedb, as_page);
            err := sp_op_const(KOM_ERR_INVALID_ADDRSPACE);
            assert err == specErr(specResult);
        } else {
            assert as_page == old(as_page);
            assert isAddrspace(pagedb, as_page);
            is_valid_mapping_target(as_page,mapping,r10,err,pagedb);
            // NB: r10 := l1pte
            assert as_page == old(as_page);
            if( err != sp_op_const(KOM_ERR_SUCCESS) ) {
                assert err == specErr(specResult);
            } else {
                phys_page_is_insecure_ram_nz(phys_page, r0);
                if(r0 == 0) {
                    err := sp_op_const(KOM_ERR_INVALID_PAGENO);
                    assert err == specErr(specResult);
                } else {
                    ghost var entry := PageDbEntryTyped(as_page, DataPage); 
                    assert entry.addrspace == as_page;
                    assert validAddrspacePage(pagedb, entry.addrspace);
                    assert page == old(page);
                    pagedb := allocate_page(page,as_page,
                        sp_op_const(KOM_PAGE_DATA),
                        r12,r11,r9,err,pagedb,entry);
                    assert err == KOM_ERR_SUCCESS ==>
                        (pageDbCorrespondsExcluding(this.m, pagedb, page)
                        && pageDbEntryCorresponds(pagedb[page],extractPageDbEntry(this.m, page)));
                    if( err != sp_op_const(KOM_ERR_SUCCESS) ){
                        assert err == specErr(specResult);
                        assert pagedb == specPageDb(specResult);
                        assert pageDbCorresponds(this.m,pagedb);
                    } else {
                        assert err == KOM_ERR_SUCCESS;
                        assert page == old(page);
                        assert as_page == old(as_page);
                        assert pageDbCorrespondsExcluding(this.m,pagedb,page);
                        assert pageDbEntryCorresponds(pagedb[page],
                                extractPageDbEntry(this.m,page));
                        ghost var abs_mapping := wordToMapping(mapping);
                        assert isValidMappingTarget(pagedb_in, as_page, mapping)
                            == KOM_ERR_SUCCESS;
                        forall :: isValidMappingTarget(pagedb, as_page, mapping)
                            == KOM_ERR_SUCCESS
                        {
                            lemma_allocatePage_preservesMappingGoodness(
                                pagedb_in,page,as_page,entry.entry,
                                pagedb,err,mapping);
                        }
                        reveal_wordToMapping();
                        ghost var l2pte := SecureMapping(page, 
                            abs_mapping.perm.w, abs_mapping.perm.x);
                       
                        assert validL2PTE(pagedb, as_page, l2pte);
                        r6 := page;
                        mkL2Pte_secure(mapping,r6,abs_mapping,l2pte);
                        assert r10 == mkL1Pte(pagedb_in[pagedb_in[as_page].entry.l1ptnr].entry.l1pt[abs_mapping.l1index], 0);
                        assert r10 == mkL1Pte(pagedb[pagedb[as_page].entry.l1ptnr].entry.l1pt[abs_mapping.l1index], 0);
                        pagedb := update_l2pte(as_page,mapping,page,r10,pagedb,
                            abs_mapping,l2pte);
                        assert pageDbCorresponds(this.m, pagedb);
                        //assert pagedb == updateL2Pte(d', as_page, abs_mapping, l2pte);
                        err := sp_op_const(KOM_ERR_SUCCESS);
                        assert err == specErr(specResult);
                        assert pagedb == specPageDb(specResult);
                        assert pageDbCorresponds(this.m,pagedb);
                    }
                }
            }
        }
    }
}

