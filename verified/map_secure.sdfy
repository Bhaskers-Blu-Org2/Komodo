procedure is_valid_mapping_target(
    {:register OReg(R1)} addr:int,
    {:register OReg(R2)} mapping:int,
    ghost d:PageDb)
    returns ({:register OReg(R0)} err:int)
    requires/ensures
        SaneState(this);
        validPageDb(d);
        isAddrspace(d,addr);
        pageDbCorresponds(this.m,d);
    ensures
        err == isValidMappingTarget(d, addr, wordToMapping(mapping));
        RegPreservingExcept(old(this), this, set(@r0));
        AllMemInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
{
    // TODO: Something
    assume false;
}

procedure phys_page_is_insecure_ram_nz({:register OReg(R3)} phys_page:int)
    returns({:register OReg(R12)} ret:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@phys_page);
        ValidRegOperand(@r12);
        /*
        @phys_page != @ret;
        @phys_page != OSP;
        @phys_page != OLR;
        @ret != OSP;
        @ret != OSP;
        // why did I even :operand
        @phys_page != @r0;
        @phys_page != @r1;
        @phys_page != @r2;
        @ret != @r0;
        @ret != @r1;
        @ret != @r2;
        */
    ensures 
        r12 == 0 <==> phys_page != 0 && !physPageIsInsecureRam(phys_page);
        RegPreservingExcept(old(this), this, set(@r12)); // TODO FIXME
        AllMemInvariant(old(this),this);
        GlobalsInvariant(old(this),this);
{
    assume false;
}

procedure update_l2pte(
    {:register OReg(R1)} as_page:int,
    {:register OReg(R2)} mapping:int,
    {:register OReg(R6)} page:int,
    ghost d:PageDb,
    ghost abs_mapping:Mapping,
    ghost l2pte:L2PTE
)   returns (ghost d':PageDb)
    requires/ensures
        SaneState(this);
    requires 
        validPageDb(d) && wellFormedPageDb(d);
        abs_mapping == wordToMapping(mapping);
        l2pte is SecureMapping ==> (l2pte.page == r6
            && pageDbCorrespondsExcluding(this.m,d,r6)
            && pageDbEntryCorresponds(d[r6],
                extractPageDbEntry(this.m,r6)));
        isAddrspace(d, as_page);
        isValidMappingTarget(d, as_page, wordToMapping(mapping))
            == KOM_ERR_SUCCESS();
        d[as_page].entry.state is InitState;
        validL2PTE(d, as_page, l2pte);
    ensures 
        validPageDb(d');
        d' == updateL2Pte(d, as_page, abs_mapping, l2pte);
        pageDbCorresponds(this.m,d');
        GlobalsPreservingExcept(old(this),this,set(PageDb()));
{
    assume false;
}

procedure kom_smc_map_secure(
    {:register OReg(R0)} page:int,
    {:register OReg(R1)} as_page:int,
    {:register OReg(R2)} mapping:int,
    {:register OReg(R3)} phys_page:int,
    out {:register OReg(R0)} err:int,
    ghost s:SysState)
    returns (ghost s':SysState)
    requires
        this == s.hw;
        SaneState(this);
        validSysState'(s);
    ensures
        this == s'.hw;
        SaneState(this);
        tuple(s'.d,err) == smc_mapSecure_premium(s.d, page, as_page,
            wordToMapping(mapping), phys_page);
        // For now, avoid proving that we haven't trampled the current 
        // dispatcher page. We probably need to either: 1) add errors for the case 
        // that the current dispatcher page is given in R0, or 2) allow the 
        // current dispatcher to either be a valid dispatcher or free and only 
        // explicitly require it to be non-free on a resume. In the second 
        // case, we need to probably add an error for the case where its free
        almostValidSysState(s');
        pageDbCorresponds(s'.hw.m, s'.d);
{
    ghost var specResult := smc_mapSecure_premium(s.d, page, as_page,
            wordToMapping(mapping), phys_page);
    //isValidMappingTarget
    //physPageIsInsecureRam
    //allocatePage
    //SecureMapping

    r6 := page;
    //if(!isAddrspace(pageDbIn, addrspacePage)) then
    //    (pageDbIn, KOM_ERR_INVALID_ADDRSPACE())
    if (as_page >= sp_op_const(KOM_SECURE_NPAGES())) {
        err := sp_op_const(KOM_ERR_INVALID_ADDRSPACE());
        s' := s.(hw:=this);
    } else {
        LDRglobaladdr(r12, PageDb());
        assert sp_eval_op_addr(this, @r12) == AddressOfGlobal(PageDb());
        assert validPageNr(as_page);
        err := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r4,as_page,r0);
        assert r4 == G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r0, PageDb(), r12, r4);

        forall :: r0 == pageDbEntryTypeVal(s.d[as_page]) {
            reveal_pageDbEntryCorresponds();
        }

        if (r0 != sp_op_const(KOM_PAGE_ADDRSPACE())) {
            assert !isAddrspace(s.d, as_page);
            err := sp_op_const(KOM_ERR_INVALID_ADDRSPACE());
            assert !isAddrspace(s.d, as_page) ==> specErr(specResult) == 
                KOM_ERR_INVALID_ADDRSPACE();
            assert err == specErr(specResult);
            s' := s.(hw:=this);
            forall :: validSysState'(s')
                    { reveal_validPageDb(); }
        } else {
            r5 := as_page;
            err := is_valid_mapping_target(as_page,mapping,s.d);
            if( err != sp_op_const(KOM_ERR_SUCCESS()) ) {
            assert err == specErr(specResult);
                s' := s.(hw:=this);
                forall :: validSysState'(s')
                    { reveal_validPageDb(); }
            } else {
                r1 := r5;
                assert as_page == old(as_page);
                assert r1 == old(as_page);
                r12 := phys_page_is_insecure_ram_nz(phys_page);
                if(r12 == 0) {
                    err := sp_op_const(KOM_ERR_INVALID_PAGENO());
                    assert err == specErr(specResult);
                    s' := s.(hw:=this);
                    forall :: validSysState'(s')
                        { reveal_validPageDb(); }
                } else {
                    ghost var d';
                    ghost var entry := PageDbEntryTyped(as_page, DataPage); 
                    assert entry.addrspace == as_page;
                    assert validAddrspacePage(s.d, entry.addrspace);
                    assert r1 == old(as_page);
                    LDRglobaladdr(r12, PageDb());
                    assert r6 == old(page);
                    d' := allocate_page(r6,as_page,
                        sp_op_const(KOM_PAGE_DATA()),
                        r12,r11,r10,err,s.d,entry);
                    assert err == KOM_ERR_SUCCESS() ==>
                        (pageDbCorrespondsExcluding(this.m, d', r6)
                        && pageDbEntryCorresponds(d'[r6],extractPageDbEntry(this.m, r6)));
                    if( err != sp_op_const(KOM_ERR_SUCCESS()) ){
                        s' := s.(d:=d').(hw:=this);
                        assert err == specErr(specResult);
                        assert s'.d == specPageDb(specResult);
                        assert pageDbCorresponds(s'.hw.m,s'.d);
                        assert validSysState'(s');
                    } else {
                        assert r6 == old(page);
                        assert as_page == old(as_page);
                        assert validPageNr(r6);
                        assert err == KOM_ERR_SUCCESS();
                        assert pageDbCorrespondsExcluding(this.m,d',r6);
                        assert pageDbEntryCorresponds(d'[r6],
                                extractPageDbEntry(this.m,r6));
                        ghost var abs_mapping := wordToMapping(mapping);
                        assert isValidMappingTarget(s.d, as_page, abs_mapping)
                            == KOM_ERR_SUCCESS();
                        forall :: isValidMappingTarget(d', as_page, abs_mapping)
                            == KOM_ERR_SUCCESS()
                        {
                            lemma_allocatePage_preservesMappingGoodness(
                                s.d,r6,as_page,entry.entry,
                                d',err,abs_mapping);
                        }
                        ghost var l2pte := SecureMapping(r6, 
                            abs_mapping.perm.w, abs_mapping.perm.x);
                       
                        assert validL2PTE(d', as_page, l2pte);
                        forall :: wellFormedPageDb(d') { reveal_validPageDb(); }
                        ghost var d'';
                        d'' := update_l2pte(as_page,mapping,r6,d',abs_mapping,l2pte);
                        assert pageDbCorresponds(this.m, d'');
                        assert d'' == updateL2Pte(d', as_page, abs_mapping, l2pte);
                        err := sp_op_const(KOM_ERR_SUCCESS());
                        s' := s.(d:=d'').(hw:=this);
                        assert pageDbCorresponds(s'.hw.m,s'.d);
                        assert err == specErr(specResult);
                        assert s'.d == specPageDb(specResult);
                        assert almostValidSysState(s');
                    }
                }
            }
        }
    }
}

