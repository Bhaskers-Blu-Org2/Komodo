var{:register var_eax()} eax:int;
var{:register var_ebx()} ebx:int;
var{:register var_ecx()} ecx:int;
var{:register var_edx()} edx:int;
var{:register var_edi()} edi:int;
var{:register var_esi()} esi:int;
var{:register var_ebp()} ebp:int;

function{:operand} stack(slot:int):oprnd
function{:operand} fromOperand(o:oprnd):oprnd

procedure incr(inout{:operand} x:int)
  requires
    Valid32BitDestinationOperand(this, @x);
    0 <= x <= 1000;
  ensures
    evalUpdateAndHavocFlags(old(this), @x, old(x) + 1, this, true);

procedure decr(inout{:operand} x:int)
  requires
    Valid32BitDestinationOperand(this, @x);
    1 <= x <= 1000;
  ensures
    evalUpdateAndHavocFlags(old(this), @x, old(x) - 1, this, true);

procedure Mov32(out{:operand} dst:int, {:operand} src:int)
  requires/ensures
    Valid32BitOperand(this, @src);
    Valid32BitDestinationOperand(this, @dst);
  ensures
    evalUpdateAndMaintainFlags(old(this), @dst, src, this, true);
    0 <= dst < GetValueLimitForX86Type(X86Uint32);

procedure Add32(inout{:operand} dst:int, {:operand} src:int)
  requires/ensures
    Valid32BitOperand(this, @src);
    Valid32BitDestinationOperand(this, @dst);
    requires isUInt32(dst);
    requires isUInt32(src + dst);
  requires
    requires isUInt32(src);
  ensures
    evalUpdateAndHavocFlags(old(this), @dst, old(dst + src), this, true);

procedure Add32Wrap(inout{:operand} dst:int, {:operand} src:int)
  requires/ensures
    Valid32BitOperand(this, @src);
    Valid32BitDestinationOperand(this, @dst);
    requires isUInt32(dst);
  requires
    requires isUInt32(src);
  ensures
    evalUpdateAndHavocFlags(old(this), @dst, old(int(BitwiseAdd32(uint32(dst), uint32(src)))), this, true);

procedure Xor32(inout{:operand} dst:int, {:operand} src:int)
  requires/ensures
    Valid32BitOperand(this, @src);
    Valid32BitDestinationOperand(this, @dst);
    requires isUInt32(dst);
  requires
    requires isUInt32(src);
  ensures
    evalUpdateAndHavocFlags(old(this), @dst, old(xor32(dst, src)), this, true);

procedure And32(inout{:operand} dst:int, {:operand} src:int)
  requires/ensures
    Valid32BitOperand(this, @src);
    Valid32BitDestinationOperand(this, @dst);
    requires isUInt32(dst);
  requires
    requires isUInt32(src);
  ensures
    evalUpdateAndHavocFlags(old(this), @dst, old(and32(dst, src)), this, true);

procedure Not32(inout{:operand} dst:int)
  requires/ensures
    Valid32BitDestinationOperand(this, @dst);
    requires isUInt32(dst);
  ensures
    evalUpdateAndHavocFlags(old(this), @dst, old(not32(dst)), this, true);

procedure AddCarry(inout{:operand} dst:int, {:operand} src:int)

procedure GetCf(out{:operand} dst:int)

procedure Rol32(inout{:operand} dst:int, {:operand} amount:int)
  requires/ensures
    Valid32BitDestinationOperand(this, @dst);
    requires isUInt32(dst);
  requires
    @amount is OConst;
    0 <= amount < 32;
  ensures
    evalUpdateAndHavocFlags(old(this), @dst, old(rol32(dst, amount)), this, true);

procedure Ror32(inout{:operand} dst:int, {:operand} amount:int)
  requires/ensures
    Valid32BitDestinationOperand(this, @dst);
    requires isUInt32(dst);
  requires
    @amount is OConst;
    0 <= amount < 32;
  ensures
    evalUpdateAndHavocFlags(old(this), @dst, old(ror32(dst, amount)), this, true);

procedure Shl32(inout{:operand} dst:int, {:operand} amount:int)
  requires/ensures
    Valid32BitDestinationOperand(this, @dst);
    requires isUInt32(dst);
  requires
    @amount is OConst;
    0 <= amount < 32;
  ensures
    evalUpdateAndHavocFlags(old(this), @dst, old(shl32(dst, amount)), this, true);

procedure Shr32(inout{:operand} dst:int, {:operand} amount:int)
  requires/ensures
    Valid32BitDestinationOperand(this, @dst);
    requires isUInt32(dst);
  requires
    @amount is OConst;
    0 <= amount < 32;
  ensures
    evalUpdateAndHavocFlags(old(this), @dst, old(shr32(dst, amount)), this, true);
