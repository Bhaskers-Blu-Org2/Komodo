include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"
include {:verbatim} "bitvectors.i.dfy"
include {:verbatim} "ptebits.i.dfy"

include "ARMdecls.sdfy"
include "kom_utils.sdfy"
include "allocate_page.sdfy"
include "memset.sdfy"
include "map_utils.sdfy"

#verbatim
lemma SameEntriesImpliesPageDbCorresponds(s:memstate, p: PageNr,
                                          db1: PageDb, db2: PageDb)
    requires SaneMem(s)
    requires validPageNr(p)
    requires wellFormedPageDb(db1) && wellFormedPageDb(db2)
    requires pageDbCorresponds(s, db1) || pageDbCorrespondsOnly(s, db1, p)
    requires db1[p] == db2[p]
    ensures pageDbCorrespondsOnly(s, db2, p)
{
}

lemma lemma_SecurePage(pagebase:word)
    requires SaneConstants()
    requires PageAligned(pagebase) && address_is_secure(pagebase)
    ensures ValidMemRange(pagebase, pagebase + PAGESIZE)
{
    var lower := KOM_DIRECTMAP_VBASE + SecurePhysBase();
    var upper := lower + KOM_SECURE_RESERVE;
    assert PageAligned(lower);
    assert PageAligned(upper);
    assert lower <= pagebase < upper;
    assert pagebase + PAGESIZE <= upper;
}

lemma pa_implies_modl2p(p:int)
    requires PageAligned(p)
    ensures  p % ARM_L2PTABLE_BYTES == 0
{
    assert p % PAGESIZE == 0;
    assert PAGESIZE == 0x1000;
    assert ARM_L2PTABLE_BYTES == 0x400;
    assert PAGESIZE % ARM_L2PTABLE_BYTES == 0;
}
#endverbatim

// updates portion of install_l1ptes
procedure install_l1ptes'(
    operand l1base:addr,
    inout operand l2base:addr,
    inout operand l1index:int,
    ghost l2pg:PageNr)
    requires/ensures
        SaneState(this);
    requires
        //DistinctRegOperands(set(@l1base, @l2base, @l1index), 3);
        ValidRegOperand(@l1base);
        ValidRegOperand(@l2base);
        ValidRegOperand(@l1index);
        @l1base != @l2base;
        @l1base != @l1index;
        @l2base != @l1index;
        @l1base != @sp;
        @l2base != @sp;
        @l1index != @sp;
        PageAligned(l1base) && address_is_secure(l1base);
        validPageNr(l2pg) && l2base == page_paddr(l2pg);
        0 <= l1index < NR_L1PTES;
    ensures
        GlobalsInvariant(old(this),this);
        SmcProcedureInvariant(old(this),this);
        RegPreservingExcept(old(this),this, set(@l2base, @l1index));
        MemPreservingExcept(old(this),this, l1base + old(l1index) * 16,
                            l1base + (old(l1index) + 1) * 16);
        ValidMemRange(old(l1base) + old(l1index) * 16, old(l1base) + old(l1index + 1) * 16);
        forall i :: 0 <= i < 4 ==>
            MemContents(this.m, old(l1base) + old(l1index) * 16 + i*4)
                == mkL1Pte(Just(l2pg), i);
{
    lemma_SecurePage(l1base);

    lemma_LeftShift4(l1index);
    LSL(l1index, l1index, 4);
    assert l1index == old(l1index) * 16;

    pa_implies_modl2p(old(l2base));
    lemma_ARM_L1PTE_Dual(old(l2base));
    ORR(l2base, l2base, 1);
    assert l2base == mkL1Pte(Just(l2pg), 0);
    WordAlignedAdd(l1base, l1index);
    STR(l2base, l1base, l1index);

    assert RegPreservingExcept(old(this),this,set(@l1index, @l2base));

    ADD(l1index, l1index, 4);
    assert l1index == old(l1index) * 16 + WordsToBytes(1);
    lemma_ARM_L1PTE_Dual(old(l2base) + 1 * ARM_L2PTABLE_BYTES);
    ADD(l2base, l2base, const(ARM_L2PTABLE_BYTES));
    assert l2base == mkL1Pte(Just(l2pg), 1);
    STR(l2base, l1base, l1index);

    assert RegPreservingExcept(old(this),this,set(@l1index, @l2base));

    ADD(l1index, l1index, 4);
    assert l1index == old(l1index) * 16 + WordsToBytes(2);
    lemma_ARM_L1PTE_Dual(old(l2base) + 2 * ARM_L2PTABLE_BYTES);
    ADD(l2base, l2base, const(ARM_L2PTABLE_BYTES));
    assert l2base == mkL1Pte(Just(l2pg), 2);
    STR(l2base, l1base, l1index);

    assert RegPreservingExcept(old(this),this,set(@l1index, @l2base));

    ADD(l1index, l1index, 4);
    assert l1index == old(l1index) * 16 + WordsToBytes(3);
    lemma_ARM_L1PTE_Dual(old(l2base) + 3 * ARM_L2PTABLE_BYTES);
    ADD(l2base, l2base, const(ARM_L2PTABLE_BYTES));
    assert l2base == mkL1Pte(Just(l2pg), 3);
    STR(l2base, l1base, l1index);
}

procedure install_l1ptes(
    operand l1pt_va:addr,
    inout operand l2_pg:int,
    inout operand l1index:int,
    out operand tmp:int,
    ghost pagedb_in:PageDb,
    ghost as_pg:PageNr,
    ghost l1pg:PageNr) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        @l1pt_va != OSP && @l2_pg != OSP && @l1index != OSP && @tmp != OSP;
        DistinctRegOperands(set(@l1pt_va, @l2_pg, @l1index, @tmp), 4);
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        validAddrspacePage(pagedb_in, as_pg) && !stoppedAddrspace(pagedb_in[as_pg]);
        l1pg == pagedb_in[as_pg].entry.l1ptnr;
        pagedb_in[l1pg] is PageDbEntryTyped && pagedb_in[l1pg].entry is L1PTable;
        l1pt_va == page_monvaddr(l1pg);
        validPageNr(l2_pg);
        0 <= l1index < NR_L1PTES;
    ensures
        GlobalsInvariant(old(this),this);
        SmcProcedureInvariant(old(this),this);
        MemPreservingExcept(old(this),this, l1pt_va + old(l1index) * 16,
                            l1pt_va + (old(l1index) + 1) * 16);
        RegPreservingExcept(old(this),this, set(@l2_pg, @l1index, @tmp));
        pagedb == installL1PTEInPageDb(pagedb_in, l1pg, old(l2_pg), old(l1index));
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;

    ghost var oldpg := extractPage(old(this).m, l1pg);
    forall :: pageDbL1PTableCorresponds(l1pg, pagedb[l1pg].entry, oldpg)
    {
        reveal_pageContentsCorresponds();
    }

    ghost var oldl1pt := pagedb[l1pg].entry;
    ghost var newl1pt := installL1PTE(oldl1pt, l2_pg, l1index);
    assert forall i :: 0 <= i < NR_L1PTES && i != l1index
        ==> newl1pt.l1pt[i] == oldl1pt.l1pt[i];

    ghost var l2base := page_paddr(l2_pg);
    page_paddr_impl(l2_pg,l2_pg,tmp);
    assert l2_pg == l2base;
    install_l1ptes'(l1pt_va, l2_pg, l1index, old(l2_pg));

    ghost var pg := extractPage(this.m, l1pg);
    forall :: pageDbL1PTableCorresponds(l1pg, newl1pt, pg)
    {
        assert forall i :: 0 <= i < 4
            ==> pg[l1pteoffset(l1pt_va, old(l1index), i)]
                    == mkL1Pte(Just(old(l2_pg)), i);
        assert forall i, j :: 0 <= i < NR_L1PTES && 0 <= j < 4 && i != old(l1index)
            ==> (let o := l1pteoffset(l1pt_va, i, j) in pg[o] == oldpg[o]);
        reveal_pageDbL1PTableCorresponds();
    }

    pagedb := installL1PTEInPageDb(pagedb, l1pg, old(l2_pg), old(l1index));

    forall :: pageDbCorrespondsOnly(this.m, pagedb, l1pg)
    {
        assert pageContentsCorresponds(l1pg, pagedb_in[l1pg], oldpg);
        assert pagedb[l1pg] == pagedb_in[l1pg].(entry := newl1pt);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(l1pg, pagedb[l1pg], pg);
        reveal_pageDbEntryCorresponds();
    }

    forall p :| validPageNr(p) && p != l1pg :: pageDbCorrespondsOnly(this.m, pagedb, p)
    {
        AllButOnePagePreserving(l1pg, old(this), this);
        assert pageDbCorrespondsOnly(this.m, pagedb_in, p);
        SameEntriesImpliesPageDbCorresponds(this.m, p, pagedb_in, pagedb);
    }
}

procedure init_l2ptable_success(
    inout operand l2_pg:int, // trashed
    operand as_pg:int,
    inout operand l1index:int, // trashed
    out operand tmp1:int,
    out operand tmp2:int,
    out operand tmp3:int,
    ghost pagedb_in: PageDb,
    ghost l1pg: int) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        @l2_pg != OSP && @as_pg != OSP && @l1index != OSP && @tmp1 != OSP && 
            @tmp2 != OSP && @tmp3 != OSP;
        @l2_pg != OLR && @as_pg != OLR && @l1index != OLR && @tmp1 != OLR && 
            @tmp2 != OLR && @tmp3 != OLR;
        DistinctRegOperands(set(@l2_pg, @as_pg, @l1index, @tmp1, @tmp2, 
            @tmp3), 6);
        validPageNr(l2_pg);
        0 <= l1index < NR_L1PTES;
        validPageDb(pagedb_in);
        validAddrspacePage(pagedb_in, as_pg) && !stoppedAddrspace(pagedb_in[as_pg]);
        l1pg == pagedb_in[as_pg].entry.l1ptnr;
        pagedb_in[l1pg] is PageDbEntryTyped && pagedb_in[l1pg].entry is L1PTable;
        pagedb_in[l2_pg] == PageDbEntryTyped(as_pg, L2PTable(SeqRepeat(NR_L2PTES, NoMapping)));
        pageDbCorrespondsExcluding(this.m, pagedb_in, l2_pg);
        pageDbEntryCorresponds(pagedb_in[l2_pg], extractPageDbEntry(this.m, l2_pg));
    ensures
        GlobalsInvariant(old(this),this);
        SmcProcedureInvariant(old(this),this);
        //PagePreservingExcept(old(this),this, set(l1pg, l2_pg));
        RegPreservingExcept(old(this),this, set(@l2_pg, @l1index, @tmp1, @tmp2, @tmp3));
        pagedb == installL1PTEInPageDb(pagedb_in, l1pg, old(l2_pg), old(l1index));
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;

    // update L2 page contents
    page_monvaddr_impl(tmp1, l2_pg, tmp2);
    tmp2 := 0;
    tmp3 := const(PAGESIZE);
    memset(tmp1, tmp2, tmp3);

    ghost var pg := extractPage(this.m, l2_pg);
    ghost var newl2pt := L2PTable(SeqRepeat(NR_L2PTES, NoMapping));
    forall :: pageDbL2PTableCorresponds(l2_pg, newl2pt, pg)
    {
        assert forall m:addr :: addrInPage(m, l2_pg) ==> pg[m] == 0;
        reveal_pageDbL2PTableCorresponds();
    }
    forall :: pageDbCorrespondsOnly(this.m, pagedb, l2_pg) {
        assert forall m:addr :: addrInPage(m, l2_pg) ==> pg[m] == 0;
        reveal_pageContentsCorresponds();
    }
    AllButOnePagePreserving(l2_pg, old(this), this);
    assert pageDbCorresponds(this.m, pagedb);
    ghost var tmpstate := this;

    // update L1 PTE
    page_monvaddr_impl(tmp1, as_pg, tmp2);
    LDR(tmp2, tmp1, const(ADDRSPACE_L1PT));

    forall :: tmp2 == page_monvaddr(pagedb[as_pg].entry.l1ptnr)
    {
        assert AllMemInvariant(tmpstate, this);
        assert pageDbCorrespondsOnly(this.m, pagedb, as_pg);
        assert validAddrspacePage(pagedb, as_pg);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(as_pg, pagedb[as_pg],
                                       extractPage(this.m, as_pg));
        reveal_pageDbAddrspaceCorresponds();
    }

    pagedb := install_l1ptes(tmp2, l2_pg, l1index, tmp3, pagedb, old(as_pg), l1pg);

    AllButOnePagePreserving(l1pg, tmpstate, this);
}

procedure kom_smc_init_l2ptable(
    {:register OReg(R1)} pagenr:int,
    {:register OReg(R2)} as_page:int,
    {:register OReg(R3)} l1index:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        SmcProcedureInvariant(old(this),this);
        tuple(pagedb, err)
            == old(smc_initL2PTable_premium(pagedb_in, pagenr, as_page, l1index));
        pageDbCorresponds(this.m, pagedb);
{
    ghost var specResult := smc_initL2PTable(pagedb_in, pagenr, as_page, l1index);
    pagedb := pagedb_in;

    if (l1index >= const(NR_L1PTES)) {
        err := const(KOM_ERR_INVALID_MAPPING);
        assert err == specErr(specResult);
    } else if (as_page >= const(KOM_SECURE_NPAGES)) {
        err := const(KOM_ERR_INVALID_ADDRSPACE);
        assert err == specErr(specResult);
    } else {
        assert validPageNr(as_page);
        LDRglobaladdr(r12, PageDb());
        lemma_LeftShift3(as_page);
        LSL(r4,as_page,const(PAGEDB_ENTRY_SHIFT));
        assert r4 == G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE;
        LDRglobal(r4, PageDb(), r12, r4);

        forall :: r4 == pageDbEntryTypeVal(pagedb[as_page]) {
            assert r4 == GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE);
            extractPageDbToAbstract(this.m, as_page);
            assert extractPageDbEntry(this.m, as_page)[0] == r4;
            // extractPageDbToAbstractOne(this.m, as_page, PAGEDB_ENTRY_TYPE);
            reveal_pageDbEntryCorresponds();
        }

        if (r4 != const(KOM_PAGE_ADDRSPACE)) {
            err := const(KOM_ERR_INVALID_ADDRSPACE);
            assert err == specErr(specResult);
        } else {
            forall :: validAddrspacePage(pagedb, as_page) {
                assert isAddrspace(pagedb, as_page);
            }

            ghost var l1pg := pagedb[as_page].entry.l1ptnr;

            // check for stopped addrspace
            page_monvaddr_impl(r4, as_page, r5);
            LDR(r5, r4, const(ADDRSPACE_STATE));
            forall :: r5 == pageDbAddrspaceStateVal(pagedb[as_page].entry.state)
            {
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }
            if (r5 != const(KOM_ADDRSPACE_INIT)) {
                err := const(KOM_ERR_ALREADY_FINAL);
                assert err == specErr(specResult);
            } else {
                // check for L1 index in use
                LDR(r4, r4, const(ADDRSPACE_L1PT));

                forall :: r4 == page_monvaddr(l1pg) {
                    assert pageDbCorrespondsOnly(this.m, pagedb, as_page);
                    assert validAddrspacePage(pagedb, as_page);
                    reveal_pageContentsCorresponds();
                    assert pageContentsCorresponds(as_page, pagedb[as_page],
                                                   extractPage(this.m, as_page));
                    reveal_pageDbAddrspaceCorresponds();
                }

                forall :: pagedb[l1pg] is PageDbEntryTyped
                    && pagedb[l1pg].entry is L1PTable
                    && wellFormedPageDbEntryTyped(pagedb[l1pg].entry)
                {
                    assert isAddrspace(pagedb, as_page);
                    assert !stoppedAddrspace(pagedb[as_page]);
                    reveal_validPageDb();
                }

                fetch_l1pte(r4, l1index, r5, r6, pagedb, l1pg);
                if (r6 != 0) {
                    assert l1indexInUse(pagedb, as_page, l1index);
                    err := const(KOM_ERR_ADDRINUSE);
                    assert err == specErr(specResult);
                } else {
                    ghost var emptyptes := SeqRepeat(NR_L2PTES, NoMapping);
                    ghost var entry := PageDbEntryTyped(as_page, L2PTable(emptyptes));

                    pagedb := allocate_page(pagenr, as_page,
                                        const(KOM_PAGE_L2PTABLE),
                                        r12, r4, r5, err, pagedb, entry);

                    assert err == specErr(specResult);
                    if (err == const(KOM_ERR_SUCCESS)) {
                        r4 := pagenr;
                        r5 := l1index;
                        pagedb := init_l2ptable_success(r4, as_page, r5, r6, r7, r8,
                                                        pagedb, l1pg);
                        assert pagedb == specPageDb(specResult);
                    }
                }
            }
        }
    }

    assert err == specErr(specResult);
    assert err != KOM_ERR_SUCCESS ==> pagedb == pagedb_in;
    reveal_smc_initL2PTable_premium();
}
