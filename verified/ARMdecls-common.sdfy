include verbatim "ARMspartan.dfy"

var{:state ok()}  ok:bool;
var{:state mem()} mem:memmap;
var{:state globals()} globals:globalsmap;

#verbatim
function MaybeUpdateOk(s:sp_state, r:sp_state) : sp_state
{
    if !(s.ok && r.ok) then s.(ok := false) else r
}
#endverbatim

procedure operator(:=) (out operand dst:int, operand src:int) := MOV

function sp_op_const(n:word):sp_operand

procedure {:bridge} {:refined} {:instruction Ins(ADD(dst, src1, src2))}
ADD(out operand dst:word, operand src1:word, operand src2:word)
    requires
        isUInt32(src1 + src2);
    ensures
        dst == old(src1 + src2);
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(ADD(dst, src1, src2))}
ADDWrap(out operand dst:word, operand src1:word, operand src2:word)
    ensures
        dst == old(src1 + src2) % 0x1_0000_0000;
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(ADD(dst, src1, OShift(GetProbableReg(src2), shift)))}
ADDWrapShift(out operand dst:word, operand src1:word, operand src2:snd, inline shift:Shift)
    ensures
        dst == old(src1 + EvalShift(old(src2), shift)) % 0x1_0000_0000;
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(SUB(dst, src1, src2))}
SUB(out operand dst:word, operand src1:word, operand src2:word)
    requires
        isUInt32(src1 - src2);
    ensures
        dst == old(src1 - src2);
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(MUL(dst, src1, src2))}
MUL(out operand dst:word, operand src1:reg, operand src2:reg)
    requires
        isUInt32(src1 * src2);
    ensures
        dst == old(src1 * src2);
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(UDIV(dst, src1, src2))}
UDIV(out operand dst:word, operand src1:word, operand src2:word)
    requires
        src2 > 0;
        isUInt32(src1 / src2);
    ensures
        dst == old(src1 / src2);
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(AND(dst, src1, src2))}
AND(out operand dst:word, operand src1:word, operand src2:word)
    ensures
        dst == old(BitwiseAnd(src1, src2));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(ORR(dst, src1, src2))}
ORR(out operand dst:word, operand src1:word, operand src2:word)
    ensures
        dst == old(BitwiseOr(src1, src2));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(EOR(dst, src1, src2))}
EOR(out operand dst:word, operand src1:word, operand src2:word)
    ensures
        dst == old(BitwiseXor(src1, src2));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(EOR(dst, src1, OShift(GetProbableReg(src2), shift)))}
EORShift(out operand dst:word, operand src1:word, operand src2:snd, inline shift:Shift)
    ensures
        dst == BitwiseXor(old(src1), EvalShift(old(src2), shift));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(LSL(dst, src1, src2))}
LSL(out operand dst:word, operand src1:word, operand src2:word)
    requires
        0 <= src2 < 32;
    requires {:refined false}
        @src2 is OConst;
    ensures
        dst == old(LeftShift(src1, src2));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(LSR(dst, src1, src2))}
LSR(out operand dst:word, operand src1:word, operand src2:word)
    requires
        0 <= src2 < 32;
    requires {:refined false}
        @src2 is OConst;
    ensures
        dst == old(RightShift(src1, src2));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(REV(dst, src))}
REV(out operand dst:word, operand src:reg)
    ensures
        dst == old(bswap32(src));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(MVN(dst, src))}
MVN(out operand dst:word, operand src:word)
    ensures
        dst == old(BitwiseNot(src));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(MOV(dst, src))}
MOV(out operand dst:word, operand src:word)
    ensures
        dst == old(src);
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(MOV(dst, OShift(GetProbableReg(src), shift)))}
MOVShift(out operand dst:word, operand src:snd, inline shift:Shift)
    ensures
        dst == old(EvalShift(old(src), shift));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(LDR(dst, base, ofs))}
LDR(out operand dst:word, operand base:word, operand ofs:word)
    reads
        mem;
    requires
        ValidAddrMemStateOpaque(mem);
        ValidMem(base + ofs);
    ensures
        dst == AddrMemContents(mem, old(base + ofs));
    ensures {:refined false}
        this.ok ==> ValidMem(old(base + ofs))
            && dst == MemContents(this.m, old(base + ofs));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(STR(rd, base, ofs))}
STR(operand rd:reg, operand base:word, operand ofs:word)
    modifies
        mem;
    requires/ensures
        ValidAddrMemStateOpaque(mem);
    requires
        ValidMem(base + ofs);
    ensures
        mem == AddrMemUpdate(old(mem), old(base + ofs), old(rd));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:instruction Ins(MRS(dst, src))}
MRS(operand dst:int, operand src:int)
    requires/ensures
        ValidState(this) && this.ok;
    requires
        priv_of_state(this) == PL1;
        ValidRegOperand(@dst);
        ValidMrsMsrOperand(this, @src);
    ensures
        //dst == old(src);
        evalUpdate(old(this), @dst, old(src), this);
{
    reveal sp_eval;
}

procedure {:instruction Ins(MSR(dst, src))}
MSR(operand dst:int, operand src:int)
    requires/ensures
        ValidState(this) && this.ok;
    requires
        priv_of_state(this) == PL1;
        ValidMrsMsrOperand(this, @dst);
        ValidRegOperand(@src);
        @dst is OSReg && @dst.sr is cpsr ==> ValidModeChange(this, src);
        @dst is OSReg && @dst.sr is spsr ==> ValidPsrWord(src);
    ensures
        //dst == old(src);
        evalUpdate(old(this), @dst, old(src), this);
{
    reveal sp_eval;
}

procedure {:instruction Ins(MRC(dst, src))}
MRC(operand dst:int, operand src:int)
    requires/ensures
        ValidState(this) && this.ok;
    requires
        ValidRegOperand(@dst);
        ValidMcrMrcOperand(this, @src);
    ensures
        //dst == old(src);
        evalUpdate(old(this), @dst, old(src), this);
{
    reveal sp_eval;
}

procedure {:instruction Ins(MCR(dst, src))}
MCR(operand dst:int, operand src:int)
    requires/ensures
        ValidState(this) && this.ok;
    requires
        ValidMcrMrcOperand(this, @dst);
        ValidRegOperand(@src);
    ensures
        //dst == old(src);
        evalUpdate(old(this), @dst, old(src), this);
{
    reveal sp_eval;
}

procedure {:instruction Ins(MOVS_PCLR_TO_USERMODE_AND_CONTINUE)}
MOVS_PCLR_TO_USERMODE_AND_CONTINUE()
    requires/ensures
        ValidState(this) && this.ok;
    requires
        ValidModeChange'(this, User);
        spsr_of_state(this).m == User;
    ensures
        evalMOVSPCLRUC(old(this), this);
{
    reveal sp_eval;
}

procedure {:instruction Ins(CPSID_IAF(mod))} CPSID_IAF(operand mod:int)
    requires/ensures
        ValidState(this) && this.ok;
    requires
        @mod is OConst;
        ValidModeEncoding(mod) && ValidModeChange'(this, decode_mode(mod));
    ensures
        evalCPSID_IAF(old(this), old(mod), this);
{
    reveal sp_eval;
}

procedure {:bridge} {:refined} {:instruction Ins(LDR_reloc(dst, g))}
LDRglobaladdr(out operand dst:word, inline g:symbol)
    requires
        ValidGlobal(g);
    ensures
        dst == AddressOfGlobal(g);
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(LDR_global(dst, g, base, ofs))}
LDRglobal(out operand dst:word, inline g:symbol,
          operand base:word, operand ofs:word)
    reads
        globals;
    requires
        ValidGlobalStateOpaque(globals);
        ValidGlobalAddr(g, base + ofs);
    ensures
        dst == GlobalContents(globals, g, old(base + ofs));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}

procedure {:bridge} {:refined} {:instruction Ins(STR_global(rd, g, base, ofs))}
STRglobal(operand rd:reg, inline g:symbol,
          operand base:word, operand ofs:word)
    modifies
        globals;
    requires
        ValidGlobalStateOpaque(globals);
        ValidGlobalAddr(g, base + ofs);
    ensures
        ValidGlobalStateOpaque(globals);
        globals == GlobalUpdate(old(globals), g, old(base + ofs), old(rd));
{
    reveal sp_eval;
    reveal ValidRegState;
    this := MaybeUpdateOk(old(this), this);
}
