// smc_enter_premium and smc_resume premium are almost the same
procedure smc_enter_err(
    {:register OReg(R1)} pagenr:int,
    {:register OReg(R5)} is_resume:int,
    out {:register OReg(R0)} err:int,
    ghost isresumeg:bool,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        is_resume != 0 <==> isresumeg;
    ensures
        AllMemInvariant(old(this),this);
        RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
        SmcProcedureInvariant(old(this), this);
        err == smc_enter_err(pagedb, old(pagenr), isresumeg);
{
    if (pagenr >= sp_op_const(KOM_SECURE_NPAGES())) {
        assert !validPageNr(pagenr);
        err := sp_op_const(KOM_ERR_INVALID_PAGENO());
    } else {
        assert validPageNr(pagenr);
        LDRglobaladdr(r12, PageDb());
        lemma_LeftShift3(pagenr);
        LSL(r10, pagenr, sp_op_const(PAGEDB_ENTRY_SHIFT()));
        assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
        WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_TYPE(), r10);
        LDRglobal(r9, PageDb(), r12, r10);
        assert r9 == GlobalWord(this.m, PageDb(), r10);
        assert pageDbEntryCorresponds(pagedb[pagenr], extractPageDbEntry(this.m, pagenr))
            by { reveal_validPageDb(); }
        assert r9 == pageDbEntryTypeVal(pagedb[pagenr]) by {
            reveal_pageDbEntryCorresponds();
            extractPageDbToAbstractOne(this.m, pagenr, PAGEDB_ENTRY_TYPE());
            assert GlobalWord(this.m, PageDb(), r10) == 
                pageDbEntryTypeVal(pagedb[pagenr]);
        }
        assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
        if( r9 != sp_op_const(KOM_PAGE_DISPATCHER()) ) {
            assert !(pagedb[pagenr] is PageDbEntryTyped && pagedb[pagenr].entry is Dispatcher);
            err := sp_op_const(KOM_ERR_INVALID_PAGENO());
        } else {
            assert pagedb[pagenr] is PageDbEntryTyped && pagedb[pagenr].entry is Dispatcher;

            ADD(r10, r10, sp_op_const(PAGEDB_ENTRY_ADDRSPACE()));
            assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
            WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE(), r10);
           
            LDRglobal(r8, PageDb(), r12, r10);
            ghost var addrspace := pagedb[pagenr].addrspace;
            assert validPageNr(addrspace) by { reveal_validPageDb(); }
            assert r8 == page_monvaddr(addrspace) && WordAligned(r8) by {
                reveal_pageDbEntryCorresponds();
                reveal_validPageDb();
                assert pageDbCorrespondsOnly(this.m, pagedb, pagenr);
                ghost var entryWords := extractPageDbEntry(this.m, pagenr);
                assert entryWords[BytesToWords(PAGEDB_ENTRY_ADDRSPACE())] == 
                    page_monvaddr(pagedb[pagenr].addrspace);
                               
                extractPageDbToAbstractOne(this.m, pagenr, PAGEDB_ENTRY_ADDRSPACE());

                assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
                assert entryWords[BytesToWords(PAGEDB_ENTRY_ADDRSPACE())] ==
                    GlobalWord(this.m, PageDb(), r10);
                assert GlobalWord(this.m, PageDb(), r10) == 
                    page_monvaddr(pagedb[pagenr].addrspace);
            }
            WordAlignedAdd_(r8,ADDRSPACE_STATE(),r8+ADDRSPACE_STATE());
           
            assert ValidMem(r8 + ADDRSPACE_STATE()) by { reveal_validPageDb(); }
            LDR(r8, r8, sp_op_const(ADDRSPACE_STATE()));
            assert r8 == KOM_ADDRSPACE_FINAL()
                <==> pagedb[addrspace].entry.state == FinalState
            by {
                reveal_validPageDb();
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            // this particular RegPreserving assert saved 30s.
            assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
            if( r8 != sp_op_const(KOM_ADDRSPACE_FINAL()) ) {
                err := sp_op_const(KOM_ERR_NOT_FINAL());
            } else {
                assert this.m == old(this.m);
                assert SaneState(this);
                page_monvaddr_impl(r9,pagenr,r10);
                assert r9 == page_monvaddr(pagenr);
                assert MemContents(this.m, page_monvaddr(pagenr) + 
                    DISPATCHER_ENTERED()) == to_i(pagedb[pagenr].entry.entered)
                by {
                    reveal_pageContentsCorresponds();
                    reveal_pageDbDispatcherCorresponds();
                }
                LDR(r9,r9,sp_op_const(DISPATCHER_ENTERED()));
                
                assert r9 == 1 <==> pagedb[pagenr].entry.entered;
                assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
              
                // TODO make this part less ugly when you are less tired.
                if( is_resume != 0) {
                    // smc_resume
                    assert isresumeg;
                    if( r9 != 1 ) {
                        err := sp_op_const(KOM_ERR_NOT_ENTERED());
                    } else {
                        err := sp_op_const(KOM_ERR_SUCCESS());
                    }
                } else {
                    // smc_enter
                    assert !isresumeg;
                    if( r9 == 1 ) {
                        err := sp_op_const(KOM_ERR_ALREADY_ENTERED());
                    } else {
                        err := sp_op_const(KOM_ERR_SUCCESS());
                    }
                }
            }
        }
    }
}

procedure stack_banked_regs({:operand} tmp:int, ghost stack_bytes_in:int)
          returns (ghost stack_bytes:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@tmp);
        @tmp != @sp;
        stack_bytes_in >= (11*4);
        StackBytesRemaining(this, stack_bytes_in);
    ensures
        sp == old(sp)-(11*4);

        MemContents(this.m, sp+(0*4))  == old(sp_fiq);
        MemContents(this.m, sp+(1*4))  == old(sp_irq);
        MemContents(this.m, sp+(2*4))  == old(sp_svc);
        MemContents(this.m, sp+(3*4))  == old(sp_abt);
        MemContents(this.m, sp+(4*4))  == old(sp_und);
        MemContents(this.m, sp+(5*4))  == old(lr_fiq);
        MemContents(this.m, sp+(6*4))  == old(lr_irq);
        MemContents(this.m, sp+(7*4))  == old(lr_svc);
        MemContents(this.m, sp+(8*4))  == old(lr_abt);
        MemContents(this.m, sp+(9*4))  == old(lr_und);
        ValidModeEncoding(psr_mask_mode(old(spsr_mon)));
        MemContents(this.m, sp+(10*4)) == old(spsr_mon);

        RegPreservingExcept(old(this),this,set(@tmp,@sp));
        GlobalsInvariant(old(this),this);
        NonStackMemPreserving(old(this),this);
        ParentStackPreserving(old(this),this);

        stack_bytes == stack_bytes_in-(11*4);
        StackBytesRemaining(this,stack_bytes);
{
    SUB(sp, sp, sp_op_const(11*4));

    MRS(tmp, sp_fiq);
    STR(tmp, sp, sp_op_const(0*4));
    MRS(tmp, sp_irq);
    STR(tmp, sp, sp_op_const(1*4));
    MRS(tmp, sp_svc);
    STR(tmp, sp, sp_op_const(2*4));
    MRS(tmp, sp_abt);
    STR(tmp, sp, sp_op_const(3*4));
    MRS(tmp, sp_und);
    STR(tmp, sp, sp_op_const(4*4));

    MRS(tmp, lr_fiq);
    STR(tmp, sp, sp_op_const(5*4));
    MRS(tmp, lr_irq);
    STR(tmp, sp, sp_op_const(6*4));
    MRS(tmp, lr_svc);
    STR(tmp, sp, sp_op_const(7*4));
    MRS(tmp, lr_abt);
    STR(tmp, sp, sp_op_const(8*4));
    MRS(tmp, lr_und);
    STR(tmp, sp, sp_op_const(9*4));

    MRS(tmp, spsr_mon);
    STR(tmp, sp, sp_op_const(10*4));

    assert ValidModeEncoding(psr_mask_mode(tmp)) by { reveal_ValidSRegState(); }

    stack_bytes := stack_bytes_in - (11*4);
}

procedure unstack_banked_regs({:operand} tmp:int, ghost stack_bytes_in:int)
          returns (ghost stack_bytes:int)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@tmp);
        @tmp != @sp;
        isUInt32(sp + (11*4));
        sp + (11*4) <= StackBase();
        StackBytesRemaining(this, stack_bytes_in);
        ValidModeEncoding(psr_mask_mode(MemContents(this.m, sp+(10*4))));
    ensures
        sp == old(sp)+(11*4);

        sp_fiq == old(MemContents(this.m, sp+(0*4)));
        sp_irq == old(MemContents(this.m, sp+(1*4)));
        sp_svc == old(MemContents(this.m, sp+(2*4)));
        sp_abt == old(MemContents(this.m, sp+(3*4)));
        sp_und == old(MemContents(this.m, sp+(4*4)));
        lr_fiq == old(MemContents(this.m, sp+(5*4)));
        lr_irq == old(MemContents(this.m, sp+(6*4)));
        lr_svc == old(MemContents(this.m, sp+(7*4)));
        lr_abt == old(MemContents(this.m, sp+(8*4)));
        lr_und == old(MemContents(this.m, sp+(9*4)));
        spsr_mon == old(MemContents(this.m, sp+(10*4)));

        CoreRegPreservingExcept(old(this), this, set(@tmp,@sp));

        AllMemInvariant(old(this),this);

        stack_bytes == stack_bytes_in + (11*4);
        StackBytesRemaining(this, stack_bytes);
{
    LDR(tmp, sp, sp_op_const(0*4));
    MSR(sp_fiq, tmp);
    LDR(tmp, sp, sp_op_const(1*4));
    MSR(sp_irq, tmp);
    LDR(tmp, sp, sp_op_const(2*4));
    MSR(sp_svc, tmp);
    LDR(tmp, sp, sp_op_const(3*4));
    MSR(sp_abt, tmp);
    LDR(tmp, sp, sp_op_const(4*4));
    MSR(sp_und, tmp);

    LDR(tmp, sp, sp_op_const(5*4));
    MSR(lr_fiq, tmp);
    LDR(tmp, sp, sp_op_const(6*4));
    MSR(lr_irq, tmp);
    LDR(tmp, sp, sp_op_const(7*4));
    MSR(lr_svc, tmp);
    LDR(tmp, sp, sp_op_const(8*4));
    MSR(lr_abt, tmp);
    LDR(tmp, sp, sp_op_const(9*4));
    MSR(lr_und, tmp);

    LDR(tmp, sp, sp_op_const(10*4));
    MSR(spsr_mon, tmp);

    ADD(sp, sp, sp_op_const(11*4));
    stack_bytes := stack_bytes_in + (11*4);
}

#verbatim
lemma lemma_scr_entry(pre: word, post: word)
    requires post == BitwiseOr(BitwiseAnd(pre, 0xfffffffe), 6)
    ensures decode_scr(post) == SCR(Secure, true, true)
{
    assert WordAsBits(1) == 1 && WordAsBits(2) == 2 && WordAsBits(4) == 4
           && WordAsBits(6) == 6 && WordAsBits(0xfffffffe) == 0xfffffffe
        by { reveal_WordAsBits(); }
    lemma_WordBitEquiv(1,1);

    calc {
        post;
        BitwiseOr(BitwiseAnd(pre, 0xfffffffe), 6);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitOr(BitAnd(WordAsBits(pre), 0xfffffffe), 6));
    }

    calc {
        BitwiseAnd(post, 1);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitAnd(BitOr(BitAnd(WordAsBits(pre), 0xfffffffe), 6), 1));
        { reveal_BitAnd(); reveal_BitOr(); }
        BitsAsWord(0);
    }

    var x := BitAnd(WordAsBits(pre), 0xfffffffe);

    calc {
        BitwiseAnd(post, 2);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitAnd(BitOr(BitAnd(WordAsBits(pre), 0xfffffffe), 6), 2));
        BitsAsWord(BitAnd(BitOr(x, 6), 2));
        { lemma_BitOrAndRelation(x, 6, 2); }
        BitsAsWord(BitOr(BitAnd(x, 2), BitAnd(6, 2)));
        { reveal_BitAnd(); }
        BitsAsWord(BitOr(BitAnd(x, 2), 2));
        != { reveal_BitOr(); }
        BitsAsWord(0);
    }

    calc {
        BitwiseAnd(post, 4);
        { lemma_BitsAndWordConversions(); }
        BitsAsWord(BitAnd(BitOr(BitAnd(WordAsBits(pre), 0xfffffffe), 6), 4));
        BitsAsWord(BitAnd(BitOr(x, 6), 4));
        { lemma_BitOrAndRelation(x, 6, 4); }
        BitsAsWord(BitOr(BitAnd(x, 4), BitAnd(6, 4)));
        { reveal_BitAnd(); }
        BitsAsWord(BitOr(BitAnd(x, 4), 4));
        != { reveal_BitOr(); }
        BitsAsWord(0);
    }
}
#endverbatim

procedure switch_addrspace(
    {:register OReg(R1)} pagenr:int,
    ghost isresume:bool,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validPageNr(pagenr);
        validDispatcherPage(pagedb, pagenr);
        !hasStoppedAddrspace(pagedb, pagenr);
    ensures
        AllMemInvariant(old(this),this);
        CoreRegPreservingExcept(old(this), this, set(@r10,@r11,@r12));
        BankedRegsInvariant(old(this),this);
        this.conf.ttbr0.ptbase == page_paddr(l1pOfDispatcher(pagedb, pagenr));
        this.conf.scr.ns == Secure && this.conf.scr.irq && this.conf.scr.fiq;
{
    //-------------------------------------------------------------------------
    // update SCR
    //-------------------------------------------------------------------------

    // read SCR
    MRC(r10, OSReg(scr));
    ghost var old_scr := r10;

    // clear NS bit
    AND(r10, r10, 0xfffffffe);

    // set IRQ and FIQ bits
    ORR(r10, r10, 6);

    // write SCR
    lemma_scr_entry(old_scr, r10);
    MCR(OSReg(scr), r10);
    assert this.conf.scr.ns == Secure;

    //-------------------------------------------------------------------------
    // load l1p into ttbr0
    //-------------------------------------------------------------------------
    ghost var addrspace := pagedb[pagenr].addrspace;
    assert validAddrspacePage(pagedb, addrspace) by { reveal_validPageDb(); }
    ghost var l1p := l1pOfDispatcher(pagedb, pagenr);

    r11 := sp_op_const(PAGEDB_ENTRY_SIZE());
    MUL(r10,pagenr,r11);
    assert r10 == G_PAGEDB_ENTRY(pagenr);
    ADD(r10, r10, sp_op_const(PAGEDB_ENTRY_ADDRSPACE())); 
    assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
    WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE(), r10);

    LDRglobaladdr(r12, PageDb());
    LDRglobal(r11, PageDb(), r12, r10);
    assert r11 == page_monvaddr(addrspace) by {
        reveal_pageDbEntryCorresponds();
        assert validAddrspacePage(pagedb, addrspace);
    }

    LDR(r10,r11,sp_op_const(ADDRSPACE_L1PT_PHYS()));

    assert r10 == page_paddr(pagedb[addrspace].entry.l1ptnr) by {
        assert pageDbAddrspaceCorresponds(addrspace, pagedb[addrspace].entry,
            extractPage(this.m, addrspace))
        by {
            assert validAddrspacePage(pagedb, addrspace);
            assert pageDbCorrespondsOnly(this.m, pagedb, addrspace);
            reveal_pageContentsCorresponds();
        }
        reveal_pageDbAddrspaceCorresponds();
    }

    assert r10 == page_paddr(l1p);
    assert PageAligned(r10);
    MSR(OSReg(ttbr0), r10);
    assert this.conf.ttbr0.ptbase == page_paddr(l1p);
}

procedure pre_entry_enter(
    {:register OReg(R1)} pagenr:int,
    {:register OReg(R2)} arg1:int,
    {:register OReg(R3)} arg2:int,
    {:register OReg(R4)} arg3:int,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        smc_enter_err(pagedb, pagenr, false) == KOM_ERR_SUCCESS();
    ensures
        AddrMemInvariant(old(this),this);
        GlobalsPreservingExcept(old(this),this, set(CurDispatcherOp()));
        pageDbCorresponds(this.m, pagedb);
        StackPreserving(old(this),this);
        BankedRegsInvariant(old(this),this);
        preEntryEnter(old(this), this, pagedb, pagenr, arg1, arg2, arg3);
        spsr_of_state(this).m == User;
        sp == old(sp);
{
    assert validPageNr(pagenr);
    assert validDispatcherPage(pagedb, pagenr);
    assert !hasStoppedAddrspace(pagedb, pagenr);
    ghost var l1p := l1pOfDispatcher(pagedb, pagenr);

    //-------------------------------------------------------------------------
    //  Switch addrspace
    //-------------------------------------------------------------------------
    switch_addrspace(pagenr, false, pagedb);
    assert pagenr == old(pagenr);

    //-------------------------------------------------------------------------
    // Set SPSR to Usermode
    //-------------------------------------------------------------------------
    r10 := 0x10;
    assert psr_mask_mode(0x10) == 0x10 by {
        assert WordAsBits(0x10) == 0x10 && WordAsBits(0x1f) == 0x1f
            by { reveal WordAsBits; }
        assert BitAnd(0x10, 0x1f) == 0x10 by { reveal BitAnd; }
        lemma_WordBitEquiv(0x10, 0x10);
    }
    assert decode_mode(psr_mask_mode(r10)) == User;
    assert ValidModeChange'(this, User);
    assert ValidModeChange(this, r10);
    MSR(spsr_mon, r10);
    assert spsr_of_state(this).m == User;
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Load entrypoint into LR
    //-------------------------------------------------------------------------
    page_monvaddr_impl(r10,pagenr,r11);
    LDR(lr,r10,sp_op_const(DISPATCHER_ENTRYPOINT()));
    assert lr == pagedb[pagenr].entry.entrypoint
    by {
        assert pageDbCorrespondsOnly(this.m,pagedb,pagenr);
        assert validDispatcherPage(pagedb,pagenr);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(pagenr,pagedb[pagenr],
            extractPage(this.m,pagenr));
        reveal_pageDbDispatcherCorresponds();
    }

    //-------------------------------------------------------------------------
    // Update current dispatcher
    //-------------------------------------------------------------------------
    LDRglobaladdr(r12, CurDispatcherOp());
    STRglobal(pagenr, CurDispatcherOp(), r12, 0);

    //-------------------------------------------------------------------------
    //  Move arguments to regs
    //-------------------------------------------------------------------------
    r0 := arg1;
    r1 := arg2;
    r2 := arg3;
    // XXX: TODO (also in spec): zero other regs!
    //-------------------------------------------------------------------------
    lemma_SameMemAndGlobalsPreservesPageDb'(old(this), this, pagedb);
}

#verbatim
lemma lemma_validEnterPre(s0:state, s1:state, sd:PageDb, r:state, rd:PageDb, dp:word,
                           a1:word, a2:word, a3:word)
    requires ValidState(s0) && ValidState(s1) && ValidState(r) && validPageDb(sd)
    requires smc_enter_err(sd, dp, false) == KOM_ERR_SUCCESS()
    requires validEnter(SysState(s1, sd), SysState(r, rd), dp, a1, a2, a3)
    ensures validEnter(SysState(s0, sd), SysState(r, rd), dp, a1, a2, a3)
{
    reveal_validEnter();
}

lemma lemma_validEnterPost(s:state, sd:PageDb, r1:state, rd:PageDb, r2:state, dp:word,
                           a1:word, a2:word, a3:word)
    requires ValidState(s) && ValidState(r1) && ValidState(r2) && validPageDb(sd)
    requires smc_enter_err(sd, dp, false) == KOM_ERR_SUCCESS()
    requires validEnter(SysState(s, sd), SysState(r1, rd), dp, a1, a2, a3)
    requires validDispatcherPage(rd, dp)
    requires validExceptionTransition(SysState(r1, rd), SysState(r2, rd), dp)
    requires OperandContents(r1, OReg(R0)) == OperandContents(r2, OReg(R0))
    requires OperandContents(r1, OReg(R1)) == OperandContents(r2, OReg(R1))
    ensures validEnter(SysState(s, sd), SysState(r2, rd), dp, a1, a2, a3)
{
    reveal_validEnter();
    reveal_ValidRegState();

    var s1, s2, s3, ex, s4 :|
        preEntryEnter(s, s1, sd, dp, a1, a2, a3)
        && entryTransition(s1, s2)
        && userspaceExecutionAndException(s2, s3, ex, s4)
        && validExceptionTransition(SysState(s4, sd), SysState(r1, rd), dp)
        && (r1.regs[R0], r1.regs[R1], rd) == exceptionHandled(s4, sd, dp);

    assert validExceptionTransition(SysState(s4, sd), SysState(r2, rd), dp)
        by { reveal_validExceptionTransition(); }
    assert (r2.regs[R0], r2.regs[R1], rd) == exceptionHandled(s4, sd, dp);
}

function exPageDb(t: (int, int, PageDb)): PageDb { t.2 }
#endverbatim

procedure smc_enter_success(
    {:register OReg(R1)} pagenr:int,
    {:register OReg(R2)} arg1:int,
    {:register OReg(R3)} arg2:int,
    {:register OReg(R4)} arg3:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost pagedb_in: PageDb,
    ghost stack_bytes: int)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        stack_bytes >= (11*4);
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        AUCIdef();
        smc_enter_err(pagedb_in, pagenr, false) == KOM_ERR_SUCCESS();
    ensures
        SmcProcedureInvariant(old(this), this);
        validEnter(SysState(old(this), pagedb_in), SysState(this, pagedb),
                   old(pagenr),old(arg1),old(arg2),old(arg3));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    ghost var dispPg := old(pagenr);
    ghost var exs;
    assert nonStoppedDispatcher(pagedb, dispPg);

    ghost var stack_bytes_local;
    stack_bytes_local := stack_banked_regs(r0, stack_bytes);
    lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb);

    ghost var s0 := this;
    pre_entry_enter(pagenr,arg1,arg2,arg3,pagedb);
    ghost var s1 := this;
    assert preEntryEnter(old(this),this,pagedb,dispPg,old(arg1),old(arg2),old(arg3));

    MOVS_PCLR_TO_USERMODE_AND_CONTINUE();
    lemma_evalMOVSPCLRUC(s1, this, pagedb_in, dispPg);
    exs, pagedb := lemma_validEnter(s0, s1, this, pagedb_in, dispPg,
                                    old(arg1), old(arg2), old(arg3));
    ghost var s6 := this;

    stack_bytes_local := unstack_banked_regs(r2, stack_bytes_local);
    assert stack_bytes_local == stack_bytes;
    lemma_SameMemAndGlobalsPreservesPageDb(s6, this, pagedb);

    lemma_validEnterPre(old(this), s0, pagedb_in, s6, pagedb, dispPg,
                        old(arg1), old(arg2), old(arg3));

    assert validExceptionTransition(SysState(s6, pagedb), SysState(this, pagedb), dispPg)
        by { reveal_validExceptionTransition(); }
    lemma_validEnterPost(old(this), pagedb_in, s6, pagedb, this,
                         dispPg, old(arg1), old(arg2), old(arg3));

    assume SmcProcedureInvariant(old(this), this); // TODO
}

procedure kom_smc_enter(
    {:register OReg(R1)} disppg:int,
    {:register OReg(R2)} arg1:int,
    {:register OReg(R3)} arg2:int,
    {:register OReg(R4)} arg3:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost pagedb_in:PageDb,
    ghost stack_bytes: int)
    returns (ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        stack_bytes >= (11*4);
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        AUCIdef();
    ensures
        SmcProcedureInvariant(old(this), this);
        smc_enter(old(this), pagedb_in, this, pagedb, old(disppg),
                  old(arg1), old(arg2), old(arg3));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    r5 := 0; // do an error check for enter, not resume
    smc_enter_err(disppg,r5,err,false,pagedb_in);
    if(err != sp_op_const(KOM_ERR_SUCCESS()) ) {
        pagedb := pagedb_in;
        val := 0;
    } else {
        ghost var s0 := this;
        pagedb := smc_enter_success(disppg, arg1, arg2, arg3, err, val, pagedb_in,
                                    stack_bytes);
        lemma_validEnterPre(old(this), s0, pagedb_in, this, pagedb, old(disppg),
                            old(arg1), old(arg2), old(arg3));
    }
}
