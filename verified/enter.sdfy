procedure pre_entry_enter(
    {:register OReg(R1)} pagenr:int,
    {:register OReg(R2)} arg1:int,
    {:register OReg(R3)} arg2:int,
    {:register OReg(R4)} arg3:int,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        smc_enter_err(pagedb, pagenr, false) == KOM_ERR_SUCCESS();
    ensures
        AddrMemInvariant(old(this),this);
        GlobalsPreservingExcept(old(this),this, set(CurDispatcherOp()));
        pageDbCorresponds(this.m, pagedb);
        StackPreserving(old(this),this);
        BankedRegsInvariant(old(this),this);
        preEntryEnter(old(this), this, pagedb, pagenr, arg1, arg2, arg3);
        spsr_of_state(this).m == User;
        sp == old(sp);
{
    assert validPageNr(pagenr);
    assert validDispatcherPage(pagedb, pagenr);
    assert !hasStoppedAddrspace(pagedb, pagenr);
    ghost var l1p := l1pOfDispatcher(pagedb, pagenr);

    //-------------------------------------------------------------------------
    //  Switch addrspace
    //-------------------------------------------------------------------------
    switch_addrspace(pagenr, false, pagedb);
    assert pagenr == old(pagenr);

    //-------------------------------------------------------------------------
    // Set SPSR to Usermode
    //-------------------------------------------------------------------------
    r10 := 0x10;
    assert psr_mask_mode(0x10) == 0x10 by {
        assert WordAsBits(0x10) == 0x10 && WordAsBits(0x1f) == 0x1f
            by { reveal WordAsBits; }
        assert BitAnd(0x10, 0x1f) == 0x10 by { reveal BitAnd; }
        lemma_WordBitEquiv(0x10, 0x10);
    }
    assert decode_mode(psr_mask_mode(r10)) == User;
    assert ValidModeChange'(this, User);
    assert ValidModeChange(this, r10);
    MSR(spsr_mon, r10);
    assert spsr_of_state(this).m == User;
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Load entrypoint into LR
    //-------------------------------------------------------------------------
    page_monvaddr_impl(r10,pagenr,r11);
    LDR(lr,r10,sp_op_const(DISPATCHER_ENTRYPOINT()));
    assert lr == pagedb[pagenr].entry.entrypoint
    by {
        assert pageDbCorrespondsOnly(this.m,pagedb,pagenr);
        assert validDispatcherPage(pagedb,pagenr);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(pagenr,pagedb[pagenr],
            extractPage(this.m,pagenr));
        reveal_pageDbDispatcherCorresponds();
    }

    //-------------------------------------------------------------------------
    // Update current dispatcher
    //-------------------------------------------------------------------------
    LDRglobaladdr(r12, CurDispatcherOp());
    STRglobal(pagenr, CurDispatcherOp(), r12, 0);

    //-------------------------------------------------------------------------
    //  Move arguments to regs
    //-------------------------------------------------------------------------
    r0 := arg1;
    r1 := arg2;
    r2 := arg3;
    // XXX: TODO (also in spec): zero other regs!
    //-------------------------------------------------------------------------
    lemma_SameMemAndGlobalsPreservesPageDb'(old(this), this, pagedb);
}

#verbatim
lemma lemma_validEnterPre(s0:state, s1:state, sd:PageDb, r:state, rd:PageDb, dp:word,
                           a1:word, a2:word, a3:word)
    requires ValidState(s0) && ValidState(s1) && ValidState(r) && validPageDb(sd)
    requires smc_enter_err(sd, dp, false) == KOM_ERR_SUCCESS()
    requires validEnter(SysState(s1, sd), SysState(r, rd), dp, a1, a2, a3)
    ensures validEnter(SysState(s0, sd), SysState(r, rd), dp, a1, a2, a3)
{
    reveal_validEnter();
}

lemma lemma_validEnterPost(s:state, sd:PageDb, r1:state, rd:PageDb, r2:state, dp:word,
                           a1:word, a2:word, a3:word)
    requires ValidState(s) && ValidState(r1) && ValidState(r2) && validPageDb(sd)
    requires smc_enter_err(sd, dp, false) == KOM_ERR_SUCCESS()
    requires validEnter(SysState(s, sd), SysState(r1, rd), dp, a1, a2, a3)
    requires validDispatcherPage(rd, dp)
    requires validExceptionTransition(SysState(r1, rd), SysState(r2, rd), dp)
    requires OperandContents(r1, OReg(R0)) == OperandContents(r2, OReg(R0))
    requires OperandContents(r1, OReg(R1)) == OperandContents(r2, OReg(R1))
    ensures validEnter(SysState(s, sd), SysState(r2, rd), dp, a1, a2, a3)
{
    reveal_validEnter();
    reveal_ValidRegState();

    var s1, s2, s3, ex, s4 :|
        preEntryEnter(s, s1, sd, dp, a1, a2, a3)
        && entryTransition(s1, s2)
        && userspaceExecutionAndException(s2, s3, ex, s4)
        && validExceptionTransition(SysState(s4, sd), SysState(r1, rd), dp)
        && (r1.regs[R0], r1.regs[R1], rd) == exceptionHandled(s4, sd, dp);

    assert validExceptionTransition(SysState(s4, sd), SysState(r2, rd), dp)
        by { reveal_validExceptionTransition(); }
    assert (r2.regs[R0], r2.regs[R1], rd) == exceptionHandled(s4, sd, dp);
}
#endverbatim

procedure smc_enter_success(
    {:register OReg(R1)} pagenr:int,
    {:register OReg(R2)} arg1:int,
    {:register OReg(R3)} arg2:int,
    {:register OReg(R4)} arg3:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost pagedb_in: PageDb,
    ghost stack_bytes: int)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        stack_bytes >= banked_regs_framesize();
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        AUCIdef();
        smc_enter_err(pagedb_in, pagenr, false) == KOM_ERR_SUCCESS();
    ensures
        EnterResumeSmcProcedureInvariant(old(this), this);
        validEnter(SysState(old(this), pagedb_in), SysState(this, pagedb),
                   old(pagenr),old(arg1),old(arg2),old(arg3));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    ghost var dispPg := old(pagenr);
    ghost var exs;
    assert nonStoppedDispatcher(pagedb, dispPg);

    ghost var stack_bytes_local;
    stack_bytes_local := stack_banked_regs(r0, stack_bytes);
    lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb);

    ghost var s0 := this;
    pre_entry_enter(pagenr,arg1,arg2,arg3,pagedb);
    ghost var s1 := this;
    assert preEntryEnter(old(this),this,pagedb,dispPg,old(arg1),old(arg2),old(arg3));

    MOVS_PCLR_TO_USERMODE_AND_CONTINUE();
    lemma_evalMOVSPCLRUC(s1, this, pagedb_in, dispPg);
    exs, pagedb := lemma_validEnter(s0, s1, this, pagedb_in, dispPg,
                                    old(arg1), old(arg2), old(arg3));
    ghost var s6 := this;
    ghost var s6_sp := sp;

    lemma_wellformed_banked_regs_stackframe_preserved(s0.m, this.m, sp);
    stack_bytes_local := unstack_banked_regs(r2, stack_bytes_local);
    assert stack_bytes_local == stack_bytes;
    lemma_SameMemAndGlobalsPreservesPageDb(s6, this, pagedb);

    assert StackPreserving(old(this), this);
    lemma_stackunstack_banked_regs(old(this), s0.m, this, s6.m, s6_sp);

    leave_secure_world(r2);

    lemma_validEnterPre(old(this), s0, pagedb_in, s6, pagedb, dispPg,
                        old(arg1), old(arg2), old(arg3));

    assert validExceptionTransition(SysState(s6, pagedb), SysState(this, pagedb), dispPg)
        by { reveal_validExceptionTransition(); }
    lemma_validEnterPost(old(this), pagedb_in, s6, pagedb, this,
                         dispPg, old(arg1), old(arg2), old(arg3));
}

procedure kom_smc_enter(
    {:register OReg(R1)} disppg:int,
    {:register OReg(R2)} arg1:int,
    {:register OReg(R3)} arg2:int,
    {:register OReg(R4)} arg3:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost pagedb_in:PageDb,
    ghost stack_bytes: int)
    returns (ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        stack_bytes >= banked_regs_framesize();
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        AUCIdef();
        this.conf.scr.ns == NotSecure; // FIXME: cleanup
    ensures
        EnterResumeSmcProcedureInvariant(old(this), this);
        smc_enter(old(this), pagedb_in, this, pagedb, old(disppg),
                  old(arg1), old(arg2), old(arg3));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    r5 := 0; // do an error check for enter, not resume
    smc_enter_err(disppg,r5,err,false,pagedb_in);
    if(err != sp_op_const(KOM_ERR_SUCCESS()) ) {
        pagedb := pagedb_in;
        val := 0;
    } else {
        ghost var s0 := this;
        pagedb := smc_enter_success(disppg, arg1, arg2, arg3, err, val, pagedb_in,
                                    stack_bytes);
        lemma_validEnterPre(old(this), s0, pagedb_in, this, pagedb, old(disppg),
                            old(arg1), old(arg2), old(arg3));
    }
}
