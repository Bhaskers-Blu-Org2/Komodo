///////////////////////////////////////////////////
//
//  Filling in additional SHA functionality
//
///////////////////////////////////////////////////


include{:verbatim} "sha256.i.dfy"
//include verbatim "sha256-refined-helpers.i.dfy"
//include verbatim "sha256-refined-invariants.i.dfy"
include{:verbatim} "bit-vector-lemmas.i.dfy"

include "../ARMdecls.sdfy"


procedure {:refined} load_32_bit_const(
    inline c:word,
    out operand dst:word
    ) 
ensures 
    dst == c;
{
    MOV(dst, const(c / 0x1_0000_0000));
    ADDWrapShift(dst, const(c % 0x1_0000_0000), dst, LSLShift(16));
    lemma_32bit_const_load(c);
}

procedure {:refined} sha256_init() returns (ghost trace_out:SHA256_trace)
requires/ensures
    ValidAddrMemStateOpaque(mem);
    ValidAddrs(r0, 8);
reads r0; 
modifies mem; r1;
ensures
    forall addr :: ValidMem(addr) && (addr < r0 || addr >= r0 + 8*4)
                ==> AddrMemContents(old(mem), addr) == AddrMemContents(mem, addr);
    IsCompleteSHA256Trace(trace_out);
    SHA256TraceIsCorrect(trace_out);
    forall i :: 0 <= i < 8 ==> trace_out.H[i] == AddrMemContents(mem, r0 + 4*i);
{
    load_32_bit_const(1779033703, r1);
    STR(r1, r0, 0);
    load_32_bit_const(3144134277, r1);
    STR(r1, r0, 4);
    load_32_bit_const(1013904242, r1);
    STR(r1, r0, 8);
    load_32_bit_const(2773480762, r1);
    STR(r1, r0, 12);
    load_32_bit_const(1359893119, r1);
    STR(r1, r0, 16);
    load_32_bit_const(2600822924, r1);
    STR(r1, r0, 20);
    load_32_bit_const(528734635, r1);
    STR(r1, r0, 24);
    load_32_bit_const(1541459225, r1);
    STR(r1, r0, 28);

    reveal InitialH_SHA256;
}

// TODO: Update to satisfy all of sha256_block_order's pre/post-conditions
procedure {:refined} sha256_finalize(
        ghost trace_in:SHA256_trace,
        ghost input:seq(word)
    ) returns (
        ghost trace_out:SHA256_trace
    )
requires/ensures
    ValidAddrMemStateOpaque(mem);
reads r0; r1; sp; globals;
modifies mem; sp; r2;
requires 
    // 
    // sha256_block_data_order's requires:
    // 
    IsCompleteSHA256Trace(trace_in);
    SHA256TraceIsCorrect(trace_in);

    // Stack is accessible
    sp >= 116 + 64;                  // Add some stack for storing the last block
    ValidAddrs(sp-(116+64), 29 + 16);

    // K table is valid
    SaneShaGlobal(globals);
    lr == AddressOfGlobal(K_SHA256s());
    ValidGlobalAddr(K_SHA256s(), lr);

    let ctx := r0 in
     // Old H values are laid out in memory pointed at by ctx
        ValidAddrs(ctx, 8)
     && last(trace_in.H)[0] == AddrMemContents(mem, ctx + 0*4)
     && last(trace_in.H)[1] == AddrMemContents(mem, ctx + 1*4)
     && last(trace_in.H)[2] == AddrMemContents(mem, ctx + 2*4)
     && last(trace_in.H)[3] == AddrMemContents(mem, ctx + 3*4)
     && last(trace_in.H)[4] == AddrMemContents(mem, ctx + 4*4)
     && last(trace_in.H)[5] == AddrMemContents(mem, ctx + 5*4)
     && last(trace_in.H)[6] == AddrMemContents(mem, ctx + 6*4)
     && last(trace_in.H)[7] == AddrMemContents(mem, ctx + 7*4)

     // Anti-aliasing
     && (ctx + 32 < sp - 116 || ctx > sp)                              // ctx != sp
    ;
ensures
    // Framing
    forall addr :: ValidMem(addr) && (addr < r0 || addr >= r0 + 8*4)
                ==> AddrMemContents(old(mem), addr) == AddrMemContents(mem, addr);
    // Need more framing copied from block_data_order

    forall i :: 0 <= i < 8 ==> trace_out.H[i] == AddrMemContents(mem, r0 + 4*i);

//    SHA(input) == seq(AddrMemContents(mem, old(r0) + 0*4),
//                      AddrMemContents(mem, old(r0) + 1*4),
//                      AddrMemContents(mem, old(r0) + 2*4),
//                      AddrMemContents(mem, old(r0) + 3*4),
//                      AddrMemContents(mem, old(r0) + 4*4),
//                      AddrMemContents(mem, old(r0) + 5*4),
//                      AddrMemContents(mem, old(r0) + 6*4),
//                      AddrMemContents(mem, old(r0) + 7*4))
{
    SUB(sp, sp, 64);      // Make room for the final 256-bit input buffer

    STR(0x80, sp, 0);

    // Fill sp buffer with 0s
    STR(0, sp,  4); 
    STR(0, sp,  8);
    STR(0, sp, 16);
    STR(0, sp, 20);
    STR(0, sp, 24);
    STR(0, sp, 28);
    STR(0, sp, 32);
    STR(0, sp, 36);
    STR(0, sp, 40);
    STR(0, sp, 44);
    STR(0, sp, 48);
    STR(0, sp, 52);
    STR(0, sp, 56);

    // Store the length
    STR(r1, sp, 60);

    // Parameters to sha256_block_data_order
    // r0 is already set to ctx
    MOV(sp, r1);    // input_ptr
    MOV(1, r2);     // num_blocks

    // Compute one last compression
    ghost var last_block := seq(0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, r1);
    sha256_block_data_order(trace_in, last_block);

    // Probably need to call lemma_SHA256FinalHelper1 here
}

