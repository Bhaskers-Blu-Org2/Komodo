///////////////////////////////////////////////////
//
//  Filling in additional SHA functionality
//
///////////////////////////////////////////////////


include{:verbatim} "sha256.i.dfy"
//include verbatim "sha256-refined-helpers.i.dfy"
include{:verbatim} "sha256-refined-invariants.i.dfy"
include{:verbatim} "bit-vector-lemmas.i.dfy"
include "sha256-refined.sdfy"

include "../ARMdecls.sdfy"


#verbatim
lemma lemma_load_32_bit_const(c:word)
    ensures c == (c / 0x1000000 * 0x1000000)
               + (c / 0x10000 % 0x100 * 0x10000)
               + (c / 0x100 % 0x100 * 0x100)
               + (c % 0x100);
{
    ghost var top := c / 0x10000 * 0x10000;
    ghost var c0:word := c / 0x1000000 % 0x100 * 0x1000000;
    assert c0 == c / 0x1000000 * 0x1000000;
    ghost var c1:word := c / 0x10000 % 0x100 * 0x10000;
    assert top == c0 + c1;

    ghost var bottom := c % 0x10000;
    ghost var c2:word := c / 0x100 % 0x100 * 0x100;
    ghost var c3:word := c % 0x100;
    calc {
         bottom;
         c3 + c2;
    }
    assert c == top + bottom;
}
#endverbatim

procedure {:refined} load_32_bit_const(
    out operand dst:word,
    inline c:word
    ) 
ensures 
    dst == c;
{
    // TODO: add MOVW/MOVT instructions, and reduce this to two steps
    lemma_load_32_bit_const(c);
    MOV(dst, const(c / 0x1000000 * 0x1000000));
    ADD(dst, dst, const(c / 0x10000 % 0x100 * 0x10000));
    ADD(dst, dst, const(c / 0x100 % 0x100 * 0x100));
    ADD(dst, dst, const(c % 0x100));
}

procedure {:refined} sha256_init() returns (ghost trace_out:SHA256Trace)
requires/ensures
    ValidAddrMemStateOpaque(mem);
requires
    ValidMemRange(r0, r0 + SHA_CTXSIZE * WORDSIZE);
requires {:refined false}
    mode_of_state(this) == Monitor;
reads r0; 
modifies mem; r1;
ensures
    AddrMemPreservingExcept(old(mem), mem, old(r0), old(r0) + SHA_CTXSIZE * WORDSIZE);
    IsCompleteSHA256Trace(trace_out);
    SHA256TraceIsCorrect(trace_out);
    forall i :: 0 <= i < SHA_CTXSIZE ==> trace_out.H[0][i] == AddrMemContents(mem, old(r0) + i*WORDSIZE);
{
    load_32_bit_const(r1, 1779033703);
    STR(r1, r0, 0);
    load_32_bit_const(r1, 3144134277);
    STR(r1, r0, 4);
    load_32_bit_const(r1, 1013904242);
    STR(r1, r0, 8);
    load_32_bit_const(r1, 2773480762);
    STR(r1, r0, 12);
    load_32_bit_const(r1, 1359893119);
    STR(r1, r0, 16);
    load_32_bit_const(r1, 2600822924);
    STR(r1, r0, 20);
    load_32_bit_const(r1, 528734635);
    STR(r1, r0, 24);
    load_32_bit_const(r1, 1541459225);
    STR(r1, r0, 28);

    reveal InitialH_SHA256;

    ghost var initial_Hs := seq(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225);
    trace_out := SHA256Trace_c(seq(), // Empty M
                               seq(initial_Hs), // Initial Hs
                               seq(), // Empty Ws
                               seq()  // Empty atohs
                              );
}

// TODO: Update to satisfy all of sha256_block_order's pre/post-conditions
procedure {:refined} sha256_finalize(
        ghost trace_in:SHA256Trace,
        ghost input:seq(word)
    ) returns (
        ghost trace_out:SHA256Trace
    )
requires/ensures
    ValidAddrMemStateOpaque(mem);
reads globals;
modifies mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
requires 
    // 
    // sha256_block_data_order's requires:
    // 
    IsCompleteSHA256Trace(trace_in);
    SHA256TraceIsCorrect(trace_in);

    // Stack is accessible
    sp >= ((29 + 16) * WORDSIZE);   // Add some stack for storing the last block
    ValidMemRange(sp - ((29 + 16) * WORDSIZE), sp);

    // K table is valid
    SaneShaGlobal(globals);
    lr == AddressOfGlobal(K_SHA256s());

    let ctx := r0 in
     // Old H values are laid out in memory pointed at by ctx
        ValidMemRange(ctx, ctx + 8*WORDSIZE)
     && last(trace_in.H)[0] == AddrMemContents(mem, ctx + 0*WORDSIZE)
     && last(trace_in.H)[1] == AddrMemContents(mem, ctx + 1*WORDSIZE)
     && last(trace_in.H)[2] == AddrMemContents(mem, ctx + 2*WORDSIZE)
     && last(trace_in.H)[3] == AddrMemContents(mem, ctx + 3*WORDSIZE)
     && last(trace_in.H)[4] == AddrMemContents(mem, ctx + 4*WORDSIZE)
     && last(trace_in.H)[5] == AddrMemContents(mem, ctx + 5*WORDSIZE)
     && last(trace_in.H)[6] == AddrMemContents(mem, ctx + 6*WORDSIZE)
     && last(trace_in.H)[7] == AddrMemContents(mem, ctx + 7*WORDSIZE)

     // Anti-aliasing
     && (ctx + 32 < sp - 116 || ctx > sp)                              // ctx != sp
    ;
ensures
    // Framing
    AddrMemPreservingExcept(old(mem), mem, old(r0), old(r0) + 8 * WORDSIZE);
    // Need more framing copied from block_data_order

    forall i :: 0 <= i < 8 ==> last(trace_out.H)[i] == AddrMemContents(mem, old(r0) + i*WORDSIZE);

//    SHA(input) == seq(AddrMemContents(mem, old(r0) + 0*4),
//                      AddrMemContents(mem, old(r0) + 1*4),
//                      AddrMemContents(mem, old(r0) + 2*4),
//                      AddrMemContents(mem, old(r0) + 3*4),
//                      AddrMemContents(mem, old(r0) + 4*4),
//                      AddrMemContents(mem, old(r0) + 5*4),
//                      AddrMemContents(mem, old(r0) + 6*4),
//                      AddrMemContents(mem, old(r0) + 7*4))
{
    SUB(sp, sp, 64);      // Make room for the final 256-bit input buffer

    STR(0x80, sp, 0);

    // Fill sp buffer with 0s
    STR(0, sp,  4); 
    STR(0, sp,  8);
    STR(0, sp, 16);
    STR(0, sp, 20);
    STR(0, sp, 24);
    STR(0, sp, 28);
    STR(0, sp, 32);
    STR(0, sp, 36);
    STR(0, sp, 40);
    STR(0, sp, 44);
    STR(0, sp, 48);
    STR(0, sp, 52);
    STR(0, sp, 56);

    // Store the length
    STR(r1, sp, 60);

    // Parameters to sha256_block_data_order
    // r0 is already set to ctx
    MOV(sp, r1);    // input_ptr
    MOV(1, r2);     // num_blocks

    // Compute one last compression
    ghost var last_block := seq(0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, r1);
    sha256_block_data_order(trace_in, last_block);

    // Probably need to call lemma_SHA256FinalHelper1 here
}
