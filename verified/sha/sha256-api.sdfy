///////////////////////////////////////////////////
//
//  Filling in additional SHA functionality
//
///////////////////////////////////////////////////


include{:verbatim} "sha256.i.dfy"
include{:verbatim} "sha256-invariants.i.dfy"
include{:verbatim} "bit-vector-lemmas.i.dfy"
include "sha256-block-data-order.sdfy"
include{:verbatim} "memory-helpers.i.dfy"

include "../valedecls.sdfy"

procedure {:refined} load_32_bit_const(
    out operand dst:word,
    inline c:word
    )
requires {:refined false}
    !interrupts_enabled(this);
ensures 
    dst == c;
{
    // TODO: add MOVW/MOVT instructions, and reduce this to two steps
    lemma_load_32_bit_const(c);
    MOV(dst, const(c / 0x1000000 * 0x1000000));
    ADD(dst, dst, const(c / 0x10000 % 0x100 * 0x10000));
    ADD(dst, dst, const(c / 0x100 % 0x100 * 0x100));
    ADD(dst, dst, const(c % 0x100));
}

procedure {:refined} sha256_init() returns (ghost trace_out:SHA256Trace)
requires/ensures
    ValidAddrMemStateOpaque(mem);
requires
    ValidMemRange(r0, r0 + SHA_CTXSIZE * WORDSIZE);
requires {:refined false}
    !interrupts_enabled(this);
    mode_of_state(this) == Monitor;
reads r0; 
modifies mem; r1;
ensures
    AddrMemPreservingExcept(old(mem), mem, old(r0), old(r0) + SHA_CTXSIZE * WORDSIZE);
    IsCompleteSHA256Trace(trace_out);
    SHA256TraceIsCorrect(trace_out);
    SeqLength(trace_out.M) == 0;
    forall i :: 0 <= i < SHA_CTXSIZE ==> trace_out.H[0][i] == AddrMemContents(mem, old(r0) + i*WORDSIZE);
    last(trace_out.H)[0] == AddrMemContents(mem, r0 + 0*WORDSIZE);
    last(trace_out.H)[1] == AddrMemContents(mem, r0 + 1*WORDSIZE);
    last(trace_out.H)[2] == AddrMemContents(mem, r0 + 2*WORDSIZE);
    last(trace_out.H)[3] == AddrMemContents(mem, r0 + 3*WORDSIZE);
    last(trace_out.H)[4] == AddrMemContents(mem, r0 + 4*WORDSIZE);
    last(trace_out.H)[5] == AddrMemContents(mem, r0 + 5*WORDSIZE);
    last(trace_out.H)[6] == AddrMemContents(mem, r0 + 6*WORDSIZE);
    last(trace_out.H)[7] == AddrMemContents(mem, r0 + 7*WORDSIZE);
{
    load_32_bit_const(r1, 1779033703);
    STR(r1, r0, 0);
    load_32_bit_const(r1, 3144134277);
    STR(r1, r0, 4);
    load_32_bit_const(r1, 1013904242);
    STR(r1, r0, 8);
    load_32_bit_const(r1, 2773480762);
    STR(r1, r0, 12);
    load_32_bit_const(r1, 1359893119);
    STR(r1, r0, 16);
    load_32_bit_const(r1, 2600822924);
    STR(r1, r0, 20);
    load_32_bit_const(r1, 528734635);
    STR(r1, r0, 24);
    load_32_bit_const(r1, 1541459225);
    STR(r1, r0, 28);

    reveal InitialH_SHA256;

    ghost var initial_Hs := seq(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225);
    trace_out := SHA256Trace_c(seq(), // Empty M
                               seq(initial_Hs), // Initial Hs
                               seq(), // Empty Ws
                               seq()  // Empty atohs
                              );
    assert {:split_here}{:refined} true;    // Split right before we try to prove the preconditions for the abstract lemma
}

#verbatim

const STACKSIZE_SHA_FINALIZE:int := 16 + STACKSIZE_SHA_UPDATE;    // Need 16 more words to store the padding block

#endverbatim

procedure {:refined}{:bridge} sha256_finalize(
        ghost trace_in:SHA256Trace
    ) 
requires/ensures
    ValidAddrMemStateOpaque(mem);
reads globals;
modifies mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
requires {:refined false}
    !interrupts_enabled(this);
requires 
    // 
    // sha256_block_data_order's requires:
    // 
    IsCompleteSHA256Trace(trace_in);
    SHA256TraceIsCorrect(trace_in);

    // Stack is accessible
    sp >= (STACKSIZE_SHA_FINALIZE * WORDSIZE);   // Add some stack for storing the last block
    ValidMemRange(sp -  STACKSIZE_SHA_FINALIZE * WORDSIZE, sp);

    // K table is valid
    SaneShaGlobal(globals);
    lr == AddressOfGlobal(K_SHA256s());

    let ctx := r0 in
    let num_bits := r2 in // Number of bits we've hashed so far

     // Old H values are laid out in memory pointed at by ctx
        ValidMemRange(ctx, ctx + SHA_CTXSIZE*WORDSIZE)
     && last(trace_in.H)[0] == AddrMemContents(mem, ctx + 0*WORDSIZE)
     && last(trace_in.H)[1] == AddrMemContents(mem, ctx + 1*WORDSIZE)
     && last(trace_in.H)[2] == AddrMemContents(mem, ctx + 2*WORDSIZE)
     && last(trace_in.H)[3] == AddrMemContents(mem, ctx + 3*WORDSIZE)
     && last(trace_in.H)[4] == AddrMemContents(mem, ctx + 4*WORDSIZE)
     && last(trace_in.H)[5] == AddrMemContents(mem, ctx + 5*WORDSIZE)
     && last(trace_in.H)[6] == AddrMemContents(mem, ctx + 6*WORDSIZE)
     && last(trace_in.H)[7] == AddrMemContents(mem, ctx + 7*WORDSIZE)
     
     // Total number of hashed bits can't exceed 2^64
     && num_bits == SeqLength(trace_in.M) * 16 * 32 // M comes in chunks of 16 words, each of which is 32 bits//SeqLength(trace_in.M)*64
     //&& SeqLength(WordSeqToBytes(ConcatenateSeqs(trace_in.M)))*8 < 0x1_0000_0000_0000_0000

     // Anti-aliasing
     && (ctx + SHA_CTXSIZE*WORDSIZE < sp - STACKSIZE_SHA_FINALIZE * WORDSIZE || ctx > sp)                              // ctx != sp
    ;
ensures
    // Framing
    ValidAddrMemStateOpaque(old(mem)); 
    ValidAddrMemStateOpaque(mem); 

    // Memory framing:  We only touch the stack and 8 words pointed to by ctx_ptr
    AddrMemPreservingExcept2(old(mem), mem, 
                             sp - STACKSIZE_SHA_FINALIZE * WORDSIZE, sp, 
                             old(r0), old(r0) + SHA_CTXSIZE * WORDSIZE);

    // Calling convention
    r4 == old(r4);
    r5 == old(r5);
    r6 == old(r6);
    r7 == old(r7);
    r8 == old(r8);
    r9 == old(r9);
    r10== old(r10);
    r11== old(r11);
    sp == old(sp);  
    lr == old(lr);

    // SHA results
    SeqLength(WordSeqToBytes(ConcatenateSeqs(trace_in.M))) <= MaxBytesForSHA();
    let hash := seq(AddrMemContents(mem, old(r0) + 0*WORDSIZE),
                    AddrMemContents(mem, old(r0) + 1*WORDSIZE),
                    AddrMemContents(mem, old(r0) + 2*WORDSIZE),
                    AddrMemContents(mem, old(r0) + 3*WORDSIZE),
                    AddrMemContents(mem, old(r0) + 4*WORDSIZE),
                    AddrMemContents(mem, old(r0) + 5*WORDSIZE),
                    AddrMemContents(mem, old(r0) + 6*WORDSIZE),
                    AddrMemContents(mem, old(r0) + 7*WORDSIZE)) in
    hash == SHA256(WordSeqToBytes(ConcatenateSeqs(trace_in.M)));
{
    ghost var length_in_bits := r2;
    SUB(sp, sp, 64);      // Make room for the final 256-bit input buffer

    //STR(0x80, sp, 0);
    MOV(r3, 0x80000000);
    STR(r3, sp, const(0*WORDSIZE));

    // Fill sp buffer with 0s
    MOV(r3, 0);
    STR(r3, sp,  const(1*WORDSIZE)); 
    STR(r3, sp,  const(2*WORDSIZE)); 
    STR(r3, sp,  const(3*WORDSIZE)); 
    STR(r3, sp,  const(4*WORDSIZE)); 
    STR(r3, sp,  const(5*WORDSIZE)); 
    STR(r3, sp,  const(6*WORDSIZE)); 
    STR(r3, sp,  const(7*WORDSIZE)); 
    STR(r3, sp,  const(8*WORDSIZE)); 
    STR(r3, sp,  const(9*WORDSIZE)); 
    STR(r3, sp,  const(10*WORDSIZE)); 
    STR(r3, sp,  const(11*WORDSIZE)); 
    STR(r3, sp,  const(12*WORDSIZE)); 
    STR(r3, sp,  const(13*WORDSIZE)); 
    STR(r3, sp,  const(14*WORDSIZE)); 

    // Store the length
    //STR(r2, sp, 60);
    STR(r2, sp, const(15*WORDSIZE));

    assert AddrMemContents(mem, sp + 15*WORDSIZE) == length_in_bits;

    // Parameters to sha256_block_data_order
    // r0 is already set to ctx
    MOV(r1, sp);    // input_ptr
    MOV(r2, 1);     // num_blocks

    // Compute one last compression
    ghost var last_block := seq(0x80000000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, length_in_bits);

    assert ValidAddrMemStateOpaque(mem); 
    ghost var trace_out;
    trace_out := sha256_block_data_order(trace_in, last_block);
    assert ValidAddrMemStateOpaque(mem); 

    assert SeqSlice(trace_out.M, 0, SeqLength(trace_in.M)) == trace_in.M;
    assert SeqLength(trace_out.M) == 1 + SeqLength(trace_in.M);

    assert trace_out.M[SeqLength(trace_in.M) + 0] == SeqSlice(last_block, 0*SHA_BLOCKSIZE, (0+1)*SHA_BLOCKSIZE);
    assert trace_out.M[SeqLength(trace_in.M)] == SeqSlice(last_block, 0, SHA_BLOCKSIZE)
                                              == last_block;

    ghost var last_block_bytes := SHA_padding_words2bytes(last_block, length_in_bits);
    ghost var M_in_bytes := WordSeqToBytes(ConcatenateSeqs(trace_in.M));
    ghost var M_out_bytes := WordSeqToBytes(ConcatenateSeqs(trace_out.M));
    lemma_Trace_stitching(trace_in.M, trace_out.M, last_block, last_block_bytes);
    assert M_out_bytes == M_in_bytes + last_block_bytes;
    lemma_ConcatenateSeqs_M_length(trace_in.M);
    lemma_WordSeqToBytes_adds(ConcatenateSeqs(trace_in.M), last_block_bytes);
    lemma_SHA256FinalHelper1Wrapper(trace_in, trace_out, last_block_bytes);

    ghost var hash := 
        seq(AddrMemContents(mem, old(r0) + 0*WORDSIZE),
            AddrMemContents(mem, old(r0) + 1*WORDSIZE),
            AddrMemContents(mem, old(r0) + 2*WORDSIZE),
            AddrMemContents(mem, old(r0) + 3*WORDSIZE),
            AddrMemContents(mem, old(r0) + 4*WORDSIZE),
            AddrMemContents(mem, old(r0) + 5*WORDSIZE),
            AddrMemContents(mem, old(r0) + 6*WORDSIZE),
            AddrMemContents(mem, old(r0) + 7*WORDSIZE));
    assert hash == last(trace_out.H);
    
    // Restore the stack pointer
    ADD(sp, sp, 64);
    lemma_SHA256IsAFunction(WordSeqToBytes(ConcatenateSeqs(trace_in.M)), hash);
}


#verbatim

lemma lemma_mul_associates_very_specific(x:int)
  ensures x * 16 * 32 == x * (16 * 32);
{
}

const STACKSIZE_SHA_ONE_SHOT:int := 3 + STACKSIZE_SHA_FINALIZE;    // Need 3 more words to preserve registers
#endverbatim


procedure {:refined}{:bridge} sha256_one_shot() 
requires/ensures
    ValidAddrMemStateOpaque(mem);
requires {:refined false}
    !interrupts_enabled(this);
    mode_of_state(this) == Monitor;
requires
    // Stack is accessible
    sp >= STACKSIZE_SHA_ONE_SHOT * WORDSIZE;
    ValidMemRange(sp - STACKSIZE_SHA_ONE_SHOT * WORDSIZE, sp);

    // K table is valid
    SaneShaGlobal(globals);
    lr == AddressOfGlobal(K_SHA256s());

    let ctx := r0 in
    let input_ptr := r1 in
    let num_blocks := r2 in // Number of 64-byte blocks to process

     // ctx points to a reasonable memory location
        ValidMemRange(ctx, ctx + SHA_CTXSIZE * WORDSIZE)

     // In-memory input is reasonable
     && isUInt32(input_ptr + num_blocks * SHA_BLOCKSIZE * WORDSIZE)
     && ValidMemRange(input_ptr, input_ptr + num_blocks * SHA_BLOCKSIZE * WORDSIZE)

     // We aren't hashing too many bits
     && isUInt32(num_blocks * (SHA_BLOCKSIZE * WORDSIZE * 8))

     // Anti-aliasing
     && (ctx + SHA_CTXSIZE*WORDSIZE < input_ptr || ctx > input_ptr + num_blocks*SHA_BLOCKSIZE*WORDSIZE)    // input_ptr != ctx
     && (ctx + SHA_CTXSIZE*WORDSIZE < sp - STACKSIZE_SHA_ONE_SHOT * WORDSIZE || ctx >= sp)                            // ctx != sp
     && (input_ptr + num_blocks*SHA_BLOCKSIZE*WORDSIZE < sp - STACKSIZE_SHA_ONE_SHOT * WORDSIZE || input_ptr >= sp);  // input_ptr != sp
reads
    globals;
modifies
    mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
ensures
    // Framing
    ValidAddrMemStateOpaque(old(mem)); 
    ValidAddrMemStateOpaque(mem); 

    // Memory framing:  We only touch the stack and 8 words pointed to by ctx_ptr
    AddrMemPreservingExcept2(old(mem), mem, 
                             sp - STACKSIZE_SHA_ONE_SHOT * WORDSIZE, sp, 
                             old(r0), old(r0) + SHA_CTXSIZE * WORDSIZE);

    // Calling convention
    r4 == old(r4);
    r5 == old(r5);
    r6 == old(r6);
    r7 == old(r7);
    r8 == old(r8);
    r9 == old(r9);
    r10== old(r10);
    r11== old(r11);
    sp == old(sp);  
    lr == old(lr);
    
    // Bonus
    r0 == old(r0);
    r1 == old(r1);
    r2 == old(r2);

    // SHA results
    let hash := seq(AddrMemContents(mem, r0 + 0*WORDSIZE),
                    AddrMemContents(mem, r0 + 1*WORDSIZE),
                    AddrMemContents(mem, r0 + 2*WORDSIZE),
                    AddrMemContents(mem, r0 + 3*WORDSIZE),
                    AddrMemContents(mem, r0 + 4*WORDSIZE),
                    AddrMemContents(mem, r0 + 5*WORDSIZE),
                    AddrMemContents(mem, r0 + 6*WORDSIZE),
                    AddrMemContents(mem, r0 + 7*WORDSIZE)) in
    hash == SHA256(WordSeqToBytes(AddrMemContentsSeq(mem, old(r1), SHA_BLOCKSIZE * old(r2))));
{
  ghost var ctx := r0; 
  ghost var input_ptr := r1;
  ghost var num_blocks := r2;

  SUB(sp, sp, 12);      // Make room to save r0, r1, and r2
  
  STR(r0, sp, const(0*WORDSIZE)); 
  STR(r1, sp, const(1*WORDSIZE)); 
  STR(r2, sp, const(2*WORDSIZE)); 

  MOV(r3, r1);  // Save r1, which gets clobbered by init
  ghost var trace;
  trace := sha256_init();
  assert SeqLength(trace.M) == 0;
  MOV(r1, r3);  // Restore r1  (could restore from memory, but this seems faster to execute and verify)

  ghost var input_mem := mem;
  ghost var input := AddrMemContentsSeq(mem, old(r1), SHA_BLOCKSIZE*old(r2));
  trace := sha256_block_data_order(trace, input);

  // Annoying forall that shouldn't be necessary
  forall i :| 0 <= i < SeqLength(trace.M) :: trace.M[i] == SeqSlice(input, i*16, (i+1)*16)
  {
    assert trace.M[i] == trace.M[0 + i];
    assert SeqSlice(input, i*16, (i+1)*16) == SeqSlice(input, i*SHA_BLOCKSIZE, (i+1)*SHA_BLOCKSIZE);
  }
  lemma_InputHelper(trace.M, input); // Proves: ConcatenateSeqs(trace.M) == input;

  // Prove that input still accurate in memory
  assert input == AddrMemContentsSeq(mem, old(r1), SHA_BLOCKSIZE * old(r2)) by { 
    lemma_AddrMemContentsSeq_framing2(input_mem, mem, input_ptr, SHA_BLOCKSIZE*num_blocks, sp - STACKSIZE_SHA_UPDATE*WORDSIZE, sp,
                                     old(r0), old(r0) + SHA_CTXSIZE * WORDSIZE); 
  }

  // Reload the ctx pointer and num_blocks
  LDR(r0, sp, const(0*WORDSIZE));
  LDR(r2, sp, const(2*WORDSIZE));

  // Convert num_blocks into bits
  MOV(r3, const(SHA_BLOCKSIZE * WORDSIZE * 8));
  assert r3 == 16 * 32;
  assert r2 == SeqLength(trace.M);
  MUL(r2, r2, r3);

  assert r2 == SeqLength(trace.M) * (16 * 32);
  assert r2 == SeqLength(trace.M) * 16 * 32 by { lemma_mul_associates_very_specific(SeqLength(trace.M)); }
  sha256_finalize(trace);
   
  // Prove that input still accurate in memory
  assert input == AddrMemContentsSeq(mem, old(r1), SHA_BLOCKSIZE * old(r2)) by { 
    lemma_AddrMemContentsSeq_framing2(input_mem, mem, input_ptr, SHA_BLOCKSIZE*num_blocks, sp - STACKSIZE_SHA_FINALIZE * WORDSIZE, sp,
                                     old(r0), old(r0) + SHA_CTXSIZE * WORDSIZE); 
  }
  
  // Restore registers, since we have them handy
  LDR(r0, sp, const(0*WORDSIZE));
  LDR(r1, sp, const(1*WORDSIZE));
  LDR(r2, sp, const(2*WORDSIZE));
  
  // Restore the stack pointer
  ADD(sp, sp, 12);

  ghost var hash := seq(AddrMemContents(mem, r0 + 0*WORDSIZE),
                    AddrMemContents(mem, r0 + 1*WORDSIZE),
                    AddrMemContents(mem, r0 + 2*WORDSIZE),
                    AddrMemContents(mem, r0 + 3*WORDSIZE),
                    AddrMemContents(mem, r0 + 4*WORDSIZE),
                    AddrMemContents(mem, r0 + 5*WORDSIZE),
                    AddrMemContents(mem, r0 + 6*WORDSIZE),
                    AddrMemContents(mem, r0 + 7*WORDSIZE));
  assert IsSHA256(WordSeqToBytes(input), hash);
}

procedure {:refined}{:bridge} sha256_incremental(
    ghost trace_in:SHA256Trace,
    ghost input:seq(word)
    )
requires/ensures
    ValidAddrMemStateOpaque(mem);
requires {:refined false}
    !interrupts_enabled(this);
requires
    IsCompleteSHA256Trace(trace_in);
    SHA256TraceIsCorrect(trace_in);

    // Stack is accessible
    sp >= STACKSIZE_SHA_UPDATE*WORDSIZE;
    ValidMemRange(sp-STACKSIZE_SHA_UPDATE*WORDSIZE, sp);

    // K table is valid
    SaneShaGlobal(globals);
    lr == AddressOfGlobal(K_SHA256s());
    //ValidGlobalAddr(K_SHA256s(), lr);

    let ctx := r0;
    let input_ptr := r1;
    let num_blocks := r2; // Number of 64-byte blocks to process

     // Old H values are laid out in memory pointed at by ctx
    ValidMemRange(ctx, ctx + SHA_CTXSIZE * WORDSIZE);
    last(trace_in.H)[0] == AddrMemContents(mem, ctx + 0*WORDSIZE);
    last(trace_in.H)[1] == AddrMemContents(mem, ctx + 1*WORDSIZE);
    last(trace_in.H)[2] == AddrMemContents(mem, ctx + 2*WORDSIZE);
    last(trace_in.H)[3] == AddrMemContents(mem, ctx + 3*WORDSIZE);
    last(trace_in.H)[4] == AddrMemContents(mem, ctx + 4*WORDSIZE);
    last(trace_in.H)[5] == AddrMemContents(mem, ctx + 5*WORDSIZE);
    last(trace_in.H)[6] == AddrMemContents(mem, ctx + 6*WORDSIZE);
    last(trace_in.H)[7] == AddrMemContents(mem, ctx + 7*WORDSIZE);

     // Ghost input matches in-memory input
    SeqLength(input) == num_blocks * SHA_BLOCKSIZE;
    isUInt32(input_ptr + num_blocks * SHA_BLOCKSIZE * WORDSIZE);
    ValidMemRange(input_ptr, input_ptr + num_blocks * SHA_BLOCKSIZE * WORDSIZE);
    (forall j :: 0 <= j < num_blocks*SHA_BLOCKSIZE ==> AddrMemContents(mem, input_ptr + j*WORDSIZE) == input[j]);

     // Anti-aliasing
    (ctx + SHA_CTXSIZE*WORDSIZE < input_ptr || ctx > input_ptr + num_blocks*SHA_BLOCKSIZE*WORDSIZE);   // input_ptr != ctx
    (ctx + SHA_CTXSIZE*WORDSIZE < sp - STACKSIZE_SHA_UPDATE*WORDSIZE || ctx >= sp);                             // ctx != sp
    (input_ptr + num_blocks*SHA_BLOCKSIZE*WORDSIZE < sp - STACKSIZE_SHA_UPDATE*WORDSIZE || input_ptr >= sp);   // input_ptr != sp

reads
    globals;
modifies
    mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
ensures
    // Calling convention
    r4 == old(r4);
    r5 == old(r5);
    r6 == old(r6);
    r7 == old(r7);
    r8 == old(r8);
    r9 == old(r9);
    r10== old(r10);
    r11== old(r11);
    sp == old(sp);  
    lr == old(lr);

    // Memory framing:  We only touch the stack and 8 bytes pointed to by ctx_ptr
    AddrMemPreservingExcept2(old(mem), mem, sp - STACKSIZE_SHA_UPDATE*WORDSIZE, sp, old(r0),
                            old(r0) + SHA_CTXSIZE * WORDSIZE);

    // SHA results
    exists trace_out:SHA256Trace ::
    (
        IsCompleteSHA256Trace(trace_out)
     && SHA256TraceIsCorrect(trace_out)
     && SeqLength(trace_out.M) == SeqLength(trace_in.M) + old(r2)
     && trace_in.M == SeqSlice(trace_out.M, 0, SeqLength(trace_in.M))  // trace_in.M is a prefix of trace_out.M
     && (forall i :: 0 <= i < old(r2) 
          ==> trace_out.M[SeqLength(trace_in.M) + i] == SeqSlice(input, i*SHA_BLOCKSIZE, (i+1)*SHA_BLOCKSIZE))
     && last(trace_out.H)[0] == AddrMemContents(mem, old(r0) + 0*WORDSIZE)
     && last(trace_out.H)[1] == AddrMemContents(mem, old(r0) + 1*WORDSIZE)
     && last(trace_out.H)[2] == AddrMemContents(mem, old(r0) + 2*WORDSIZE)
     && last(trace_out.H)[3] == AddrMemContents(mem, old(r0) + 3*WORDSIZE)
     && last(trace_out.H)[4] == AddrMemContents(mem, old(r0) + 4*WORDSIZE)
     && last(trace_out.H)[5] == AddrMemContents(mem, old(r0) + 5*WORDSIZE)
     && last(trace_out.H)[6] == AddrMemContents(mem, old(r0) + 6*WORDSIZE)
     && last(trace_out.H)[7] == AddrMemContents(mem, old(r0) + 7*WORDSIZE)
    );
{
    (ghost var trace_out) := sha256_block_data_order(trace_in, input);
}
