///////////////////////////////////////////////////
//
//  Based on sha256-armv4.pl form OpenSSL 1.0.2j
//
///////////////////////////////////////////////////


#verbatim

function method Sigma0(i:int) : word
    requires 0 <= i < 3;
{
    [2, 13, 22][i]
}

function method Sigma1(i:int) : word
    requires 0 <= i < 3;
{
    [6, 11, 25][i]
}

function method sigma0(i:int) : word
    requires 0 <= i < 3;
{
    [7, 18, 3][i]
}

function method sigma1(i:int) : word
    requires 0 <= i < 3;
{
    [17, 19, 10][i]
}

type SHA_step = i | 0 <= i < 64
type perm_index = i | 0 <= i < 8

function method GetReg(r:int) : ARMReg
    requires 0 <= r <= 12;
{
         if r ==  0 then R0
    else if r ==  1 then R1
    else if r ==  2 then R2
    else if r ==  3 then R3
    else if r ==  4 then R4
    else if r ==  5 then R5
    else if r ==  6 then R6
    else if r ==  7 then R7
    else if r ==  8 then R8
    else if r ==  9 then R9
    else if r == 10 then R10
    else if r == 11 then R11
    else R12 
}

// Make it as easy as possible for Z3 to see that the registers below are unique
function ApplyPerm(i:int, perm:perm_index) : int
{
    if i + perm >= 8 then i + perm - 8 else i + perm
}

predicate {:opaque} Even(i:int) { i % 2 == 0 }

function CheapMod16(j:int) : int
{
    if j < 16 then j 
    else if j < 32 then j - 16 
    else if j < 48 then j - 32 
    else j - 48 
}

#endverbatim

procedure {:refined} Body_00_15(
    {:inline} i:SHA_step,
    {:inline} perm:perm_index,
    {:inline} input_slot:word,
    ghost trace_in:SHA256Trace,
    ghost input:seq(word),
    inout{:operand} t0:word,
    inout{:operand} t1:word,
    inout{:operand} t2:word,
    inout{:operand} t3:word,
    inout{:operand} t4:word,
    //inout{:operand} inp:word,
    inout{:operand} a:word,
         {:operand} b:word,
         {:operand} c:word,
    inout{:operand} d:word,
         {:operand} e:word,
         {:operand} f:word,
         {:operand} g:word,
    inout{:operand} h:word)
requires/ensures
    //WordAligned(sp);
    ValidAddr(mem, sp + input_slot);
reads 
    sp; globals;
modifies 
    mem; lr;
requires {:refined false}
    @t0 == OReg(R0);
    @t1 == OReg(R2);
    @t2 == OReg(GetReg(if Even(i) then 12 else 3));
    @t3 == OReg(GetReg(if Even(i) then  3 else 12));
    @t4 == OReg(R1);
    //@inp == OReg(R1);
    @a  == OReg(GetReg(4+ApplyPerm(0, perm)));
    @b  == OReg(GetReg(4+ApplyPerm(1, perm)));
    @c  == OReg(GetReg(4+ApplyPerm(2, perm)));
    @d  == OReg(GetReg(4+ApplyPerm(3, perm)));
    @e  == OReg(GetReg(4+ApplyPerm(4, perm)));
    @f  == OReg(GetReg(4+ApplyPerm(5, perm)));
    @g  == OReg(GetReg(4+ApplyPerm(6, perm)));
    @h  == OReg(GetReg(4+ApplyPerm(7, perm)));
requires/ensures
    // Stack is accessible
    forall j {ValidAddr(mem, sp+j*4)} { mem?[sp+j*4] } :: 0 <= j < 18 ==> ValidAddr(mem, sp + j*4);

requires
    // K table adjusted properly
    ValidGlobalsAddr(globals, K_SHA256s(), lr);
    lr == AddressOfGlobal(K_SHA256s()) + 4*i;
    forall j :: 0 <= j < 64 ==> globals[K_SHA256s()][i] == K_SHA256(i);

    // TODO: Remove this when we have if/else
    requires i < 15;
    
    SeqLength(input) == 16;

    i < 15 ==> ValidAddr(mem, t4) && mem[t4] == input[i+1];
    input_slot == (i%16)*4;

    // t4 doesn't alias the stack
    t4 < sp || t4 > sp + 18*4;

    // SHA semantics
    SeqLength(trace_in.H) > 0;
    IsSHA256TraceReadyForStep(trace_in, i);
    if i == 0 then last(last(trace_in.atoh)) == atoh_c(a, b, c, d, e, f, g, h)
    else last(last(trace_in.atoh)) == atoh_c(BitwiseAdd32(a, t2), b, c, d, e, f, g, h);

    t1 == (if (i < 16) then input[i] else last(trace_in.W)[i]);
    forall j :: 0 <= j < 16 ==> last(trace_in.W)[j] == bswap32(input[j]);
    i < 16 ==> (forall j :: 0 <= j < i ==> last(trace_in.W)[j] == mem[sp + j*4]);
    16 <= i < 64 ==> (forall j :: i - 16 <= j < i ==> last(trace_in.W)[j] == mem[sp + CheapMod16(j)*4]);

    // TODO: Remove when we have if/else and can skip the add of t2 when i == 0
    requires i == 0 ==> t2 == 0;

    // SHA tactics
    t3 == BitwiseXor(b, c);
//    if i == 0 then t2 == 0 
//    else i < 16 ==> 
//        let atoh_prev := last(trace_in.atoh)[i - 1] in
//            t2 == Maj(atoh_prev.a, atoh_prev.b, atoh_prev.c));
    i >= 16 ==> RotateRight(t0, Sigma1(0)) == BSIG1(e);

ensures
    t2 == BitwiseXor(a, b);
    t3 == Maj(a, b, c);
    a == old(BitwiseAdd32(a, t2));
    lr == BitwiseAdd32(old(lr), 4);
    let T1 := BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(old(h), BSIG1(e)),
                                                     Ch(e,f,g)),
                                        K_SHA256(i)),
                           bswap32(old(t1))) in
        d == BitwiseAdd32(old(d), T1)
     && h == BitwiseAdd32(T1, BSIG0(a));
//     i < 16 ==> forall j :: 0 <= j <= i ==> last(z.W)[j] == inp[j];
    exists trace_out:SHA256Trace ::
        IsSHA256TraceReadyForStep(trace_out, i+1)
     && trace_out.M == trace_in.M
     && trace_out.H == trace_in.H
     && trace_out.W == trace_in.W
     && t1 == (if i + 1 < 16 then input[i + 1] else if i + 1 < 64 then last(trace_out.W)[i + 1] else t1)
     && (i + 1 < 16 ==> (forall j :: 0 <= j < i+1 ==> last(trace_out.W)[j] == mem[sp + j*4]))
     && (16 <= i + 1 < 64 ==> (forall j :: i+1 - 16 <= j < i+1 ==> last(trace_out.W)[j] == mem[sp + CheapMod16(j)*4]))
     && (let old_a := (if i == 0 then old(a) else old(BitwiseAdd32(a, t2))) in
         last(last(trace_out.atoh)) == atoh_c(BitwiseAdd32(h, t3), old_a, old(b), old(c), d, old(e), old(f), old(g)));
{
    //if i < 16
    //  if i == 15
    //    STR(inp, sp,17*4);
    //  end if

    rEORShift(t0, e, e, RORShift(Sigma1(1) - Sigma1(0)));
    // TODO: When i = 0, t2 = 0, so this is a no op.  We can skip it.  We can also remove the XOR that clears t2
    rADDWrap(a, a, t2);  // h += Maj(a,b,c) from the past?
    rEORShift(t0, t0, e, RORShift(Sigma1(2) - Sigma1(0)));   // Sigma1(e)
    rREV(t1, t1);

    // end if--------

    rLDRglobal(t2, K_SHA256s().sym, lr, 0);
    rADDWrap(lr, lr, 4);    // TODO: OpenSSL does this in one instruction with a load-and-increment.  
    rADDWrap(h, h, t1);      //  h+=X[i]  BP: X[i] = input[i]?
    assert h == BitwiseAdd32(old(h), bswap32(old(t1)));
    rSTR(t1, sp, input_slot);  // @ BP: Save a copy of input[i] for use in subsequent W calculations
    rEOR(t1, f, g);
    ghost var old_h := h;
    //assert t0 == BitwiseXor(BitwiseXor(e, RotateRight(e, 5)), RotateRight(e, 19));
    rADDWrapShift(h, h, t0, RORShift(Sigma1(0))); // h += Sigma1(e)

    // Prove that we computed Sigma1(e) correctly:
    forall :: h == BitwiseAdd32(old_h, BSIG1(e))
    {
        reveal BSIG1;
        lemma_RotateRightCommutesXor(e, 6, 11, 25);
    }

    rAND(t1, t1, e);
    rADDWrap(h, h, OConst(K_SHA256(i)));      // h += K256(i)
    rEOR(t1, t1, g);     // Ch(e,f,g)
    
    assert t1 == Ch(e, f, g) by { lemma_Ch(e, f, g, t1); }

    rEORShift(t0, a, a, RORShift(Sigma0(1) - Sigma0(0)));
    rADDWrap(h, h, t1);  // h += Ch(e,f,g)

    assert h == BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(old(h), bswap32(old(t1))), BSIG1(e)), K_SHA256(i)), Ch(e, f, g));
    lemma_BitwiseAdd32Associates5(old(h), bswap32(old(t1)), BSIG1(e), K_SHA256(i), Ch(e, f, g), h);

//    #if $i==31
//        and  $t2,$t2,#0xff
//        cmp  $t2,#0xf2      @ done?
//    #endif

    // if $i<15
         rLDR(t1, t4, 0);    // Prefetch
         rADDWrap(t4, t4, 4);   // Advance to the next input  // TODO: OpenSSL does this in one instruction with a load-and-increment
         rEOR(t2, a, b);            //  a^b, b^c in next round
    // else
    //   rLDR(t1, sp, ((i+2)%16)*4);     // @ from future BODY_16_xx 
    //   rEOR(t2, a, b);            //  a^b, b^c in next round
    //   rLDR(t4, sp, ((i+15)%16)*4);   // @ from future BODY_16_xx
    // endif
    rEORShift(t0,t0,a, RORShift(Sigma0(2)-Sigma0(0))); // Sigma0(a)
    rAND(t3,t3,t2);      // (b^c)&=(a^b)
    rADDWrap(d,d,h);     // d+=h
    rEOR(t3,t3,b);       // Maj(a,b,c)
    assert t3 == Maj(a,b,c) by { lemma_Maj(a, b, c, t3); }
    old_h := h;
    rADDWrapShift(h,h,t0, RORShift(Sigma0(0)));   // h+=Sigma0(a)

    // Prove we computed Sigma0(a) correctly:
    forall :: h == (old_h + BSIG0(a)) % 0x1_0000_0000
    {
        reveal BSIG0;
        lemma_RotateRightCommutesXor(a, 2, 13, 22);
    }

    // Prove that stack is still valid
    forall j :| 0 <= j < 18 
        :: ValidAddr(mem, sp + j * 4)
    {
        assert ValidAddr(old(mem), sp + j * 4);
    }

    ghost var T1 := BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(old(h), BSIG1(e)),
                                                           Ch(e,f,g)),
                                              K_SHA256(i)),
                                 bswap32(old(t1)));
    //assert h == BitwiseAdd32(T1, BSIG0(a));
    assert BitwiseAdd32(h, t3) == BitwiseAdd32(T1, BitwiseAdd32(BSIG0(a), t3)) by
           { lemma_BitwiseAdd32Associates3'(T1, BSIG0(a), t3); }

    // Construct a trace_out
    ghost var old_a := if i == 0 then old(a) else old(BitwiseAdd32(a, t2));
    ghost var old_atoh := old(atoh_c(old_a, b, c, d, e, f, g, h));
    //assert last(last(trace_in.atoh)) == old_atoh;                                   
    ghost var new_atoh := atoh_c(BitwiseAdd32(h, t3), old_a, old(b), old(c), d, old(e), old(f), old(g));

//    assert new_atoh.h == old_atoh.g;
//    assert new_atoh.g == old_atoh.f;
//    assert new_atoh.f == old_atoh.e;
//    //assert new_atoh.e == old_atoh.g;
//    assert new_atoh.d == old_atoh.c;
//    assert new_atoh.c == old_atoh.b;
//    assert new_atoh.b == old_atoh.a;
//    assert new_atoh.a == BitwiseAdd32(T1, BitwiseAdd32(BSIG0(a), t3));

    assert BitwiseAdd32(old(a), 0) == old(a);   // OBSERVE
    assert old_atoh.a == a;     // OBSERVE
//    assert old_atoh.b == b;
//    assert old_atoh.c == c;
//    assert t3 == Maj(old_atoh.a, old_atoh.b, old_atoh.c);
     

//    assert SeqLength(last(trace_in.atoh)) == i+1;
    ghost var new_atoh_list := last(trace_in.atoh) + seq(new_atoh);
//    assert SeqLength(new_atoh_list) == i+2;
    //ghost var trace_out:SHA256Trace := trace_in.(atoh := trace_in.atoh[SeqLength(trace_in.atoh)-1 := new_atoh_list]);
    ghost var trace_out:SHA256Trace := trace_in.(atoh := SeqDrop(trace_in.atoh, SeqLength(trace_in.H)-1) + seq(trace_in.atoh[SeqLength(trace_in.H)-1] + seq(new_atoh)));

    // OBSERVE: Triggers gallore!
    assert TBlk(SeqLength(trace_in.H)-1) && TBlk(SeqLength(trace_in.H)) && TStep(i) && TStep(i + 1);
    ghost var superfluous_state_in  := SHA256_state_c(last(trace_in.H), last(trace_in.W), old_atoh);
    ghost var superfluous_state_out := SHA256_state_c(last(trace_out.H), last(trace_out.W), new_atoh);
    lemma_SHA256TransitionOKAfterSettingAtoH(trace_in, superfluous_state_in, trace_out, superfluous_state_out, i);

    assert IsSHA256TraceReadyForStep(trace_out, i+1);
//    assert trace_out.M == trace_in.M;
//    assert trace_out.H == trace_in.H;
//    assert trace_out.W == trace_in.W;
//    assert t1 == (if i + 1 < 16 then input[i + 1] else if i + 1 < 64 then last(trace_out.W)[i + 1] else t1);
//    assert (i + 1 < 16 ==> (forall j :: 0 <= j < i+1 ==> last(trace_out.W)[j] == mem[sp + j*4]));
//    assert (16 <= i + 1 < 64 ==> (forall j :: i+1 - 16 <= j < i+1 ==> last(trace_out.W)[j] == mem[sp + CheapMod16(j)*4]));
//    assert last(last(trace_out.atoh)) == atoh_c(BitwiseAdd32(h, t3), a, b, c, d, e, f, g);
}

/*
procedure {:refined} Body_16_XX( 
    {:inline} i:SHA_step,
    {:inline} perm:perm_index,
    {:inline} input_slot:word,
    {:inline} input_slot_9:word,
    ghost z:SHA256Trace,
    inout{:operand} t0:word,
    inout{:operand} t1:word,
    inout{:operand} t2:word,
    inout{:operand} t3:word,
    inout{:operand} t4:word,
    //inout{:operand} inp:word,
    inout{:operand} a:word,
         {:operand} b:word,
         {:operand} c:word,
    inout{:operand} d:word,
         {:operand} e:word,
         {:operand} f:word,
         {:operand} g:word,
    inout{:operand} h:word)

requires/ensures
    //ValidAddr(mem, sp + input_slot);
reads 
    sp; globals;
modifies 
    mem; lr;
requires {:refined false}
    @t0 == OReg(R0);
    @t1 == OReg(R2);
    @t2 == OReg(GetReg(if Even(i) then 12 else 3));
    @t3 == OReg(GetReg(if Even(i) then  3 else 12));
    @t4 == OReg(R1);
    //@inp == OReg(R1);
    @a  == OReg(GetReg(4+ApplyPerm(0, perm)));
    @b  == OReg(GetReg(4+ApplyPerm(1, perm)));
    @c  == OReg(GetReg(4+ApplyPerm(2, perm)));
    @d  == OReg(GetReg(4+ApplyPerm(3, perm)));
    @e  == OReg(GetReg(4+ApplyPerm(4, perm)));
    @f  == OReg(GetReg(4+ApplyPerm(5, perm)));
    @g  == OReg(GetReg(4+ApplyPerm(6, perm)));
    @h  == OReg(GetReg(4+ApplyPerm(7, perm)));

requires
    i >= 16;
    input_slot == (i%16)*4;
    input_slot_9 == ((i+9)%16)*4;
    ValidAddr(mem, sp + input_slot);
    ValidAddr(mem, sp + input_slot_9); 

    // K table adjusted properly
    ValidGlobalsAddr(globals, K_SHA256s(), lr);
    lr == AddressOfGlobal(K_SHA256s()) + 4*i;
    forall j :: 0 <= j < 64 ==> globals[K_SHA256s()][i] == K_SHA256(i);

    t3 == BitwiseXor(b, c);

    // SHA semantics
    SeqLength(z.H) > 0;
    IsSHA256TraceReadyForStep(z, i);
    last(last(z.atoh)) == atoh_c(a, b, c, d, e, f, g, h);
{
    //@ ldr  $t1,[sp,#`($i+1)%16`*4]    @ $i
    //@ ldr  $t4,[sp,#`($i+14)%16`*4]
    rMOVShift(t0, t1, RORShift(sigma0(0)));
    rADDWrap(a, a, t2);  // h+=Maj(a,b,c) from the past
    rMOVShift(t2, t4, RORShift(sigma1(0)));
    rEORShift(t0,t0,t1,RORShift(sigma0(1)));
    rEORShift(t2,t2,t4,RORShift(sigma1(1)));
    rEORShift(t0,t0,t1,LSRShift(sigma0(2)));     // sigma0(X[i+1])
    assert t0 == SSIG0(t1) by { reveal SSIG0; }

    rLDR(t1, sp, input_slot);
    rEORShift(t2,t2,t4, LSRShift(sigma1(2)));     // sigma1(X[i+14])
    assert t2 == SSIG1(t4) by { reveal SSIG1; }
    rLDR(t4, sp, input_slot_9);

    rADDWrap(t2,t2,t0);
    rEORShift(t0,e,e,RORShift(Sigma1(1)-Sigma1(0)));    // from BODY_00_15
    rADDWrap(t1,t1,t2);
    rEORShift(t0,t0,e,RORShift(Sigma1(2)-Sigma1(0)));  // Sigma1(e)  BP: Almost

    // Prove that we computed Sigma1(e) correctly:
    forall :: RotateRight(t0, Sigma1(0)) == BSIG1(e)
    {
        reveal BSIG1;
        lemma_RotateRightCommutesXor(e, 6, 11, 25);
    }

    rADDWrap(t1,t1,t4);      // X[i]

    Body_00_15(i, perm, input_slot, z, t0, t1, t2, t3, t4, a, b, c, d, e, f, g, h);
}
*/
