///////////////////////////////////////////////////
//
//  Based on sha256-armv4.pl form OpenSSL 1.0.2j
//
///////////////////////////////////////////////////


#verbatim

function method Sigma0(i:int) : word
    requires 0 <= i < 3;
{
    [2, 13, 22][i]
}

function method Sigma1(i:int) : word
    requires 0 <= i < 3;
{
    [6, 11, 25][i]
}

function method sigma0(i:int) : word
    requires 0 <= i < 3;
{
    [7, 18, 3][i]
}

function method sigma1(i:int) : word
    requires 0 <= i < 3;
{
    [17, 19, 10][i]
}

type SHA_step = i | 0 <= i < 64
type perm_index = i | 0 <= i < 8

function method GetReg(r:int) : ARMReg
    requires 0 <= r <= 12;
{
         if r ==  0 then R0
    else if r ==  1 then R1
    else if r ==  2 then R2
    else if r ==  3 then R3
    else if r ==  4 then R4
    else if r ==  5 then R5
    else if r ==  6 then R6
    else if r ==  7 then R7
    else if r ==  8 then R8
    else if r ==  9 then R9
    else if r == 10 then R10
    else if r == 11 then R11
    else R12 
}

// Make it as easy as possible for Z3 to see that the registers below are unique
function ApplyPerm(i:int, perm:perm_index) : int
{
    if i + perm >= 8 then i + perm - 8 else i + perm
}

predicate Even(i:int) { i % 2 == 0 }

function method CheapMod16(j:int) : int
{
    if j < 16 then j 
    else if j < 32 then j - 16 
    else if j < 48 then j - 32 
    else if j < 64 then j - 48 
    else j - 64
}

#endverbatim

procedure {:refined} Body_00_15(
    {:inline} i:SHA_step,
    {:inline} perm:perm_index,
    {:inline} input_slot:word,
    {:inline} i_plus_2:word,
    {:inline} i_plus_15:word,
    ghost trace_in:SHA256Trace,
    ghost input:seq(word),
    inout{:operand} t0:word,
    inout{:operand} t1:word,
    inout{:operand} t2:word,
    inout{:operand} t3:word,
    inout{:operand} t4:word,
    //inout{:operand} inp:word,
    inout{:operand} a:word,
         {:operand} b:word,
         {:operand} c:word,
    inout{:operand} d:word,
         {:operand} e:word,
         {:operand} f:word,
         {:operand} g:word,
    inout{:operand} h:word)
requires/ensures
    //WordAligned(sp);
    ValidAddr(mem, sp + input_slot);
reads 
    sp; globals;
modifies 
    mem; lr;
requires {:refined false}
    @t0 == OReg(R0);
    @t1 == OReg(R2);
    @t2 == OReg(GetReg(if Even(i) then 12 else 3));
    @t3 == OReg(GetReg(if Even(i) then  3 else 12));
    @t4 == OReg(R1);
    //@inp == OReg(R1);
    @a  == OReg(GetReg(4+ApplyPerm(0, perm)));
    @b  == OReg(GetReg(4+ApplyPerm(1, perm)));
    @c  == OReg(GetReg(4+ApplyPerm(2, perm)));
    @d  == OReg(GetReg(4+ApplyPerm(3, perm)));
    @e  == OReg(GetReg(4+ApplyPerm(4, perm)));
    @f  == OReg(GetReg(4+ApplyPerm(5, perm)));
    @g  == OReg(GetReg(4+ApplyPerm(6, perm)));
    @h  == OReg(GetReg(4+ApplyPerm(7, perm)));
requires/ensures
    // Stack is accessible
    forall j {ValidAddr(mem, sp+j*4)} { mem?[sp+j*4] } :: 0 <= j < 18 ==> ValidAddr(mem, sp + j*4);

requires
    // K table adjusted properly
    ValidGlobalsAddr(globals, K_SHA256s().sym, lr);
    lr == AddressOfGlobal(K_SHA256s()) + 4*i;
    forall j :: 0 <= j < 64 ==> globals[K_SHA256s()][i] == K_SHA256(i);

    // TODO: Remove this when we have if/else
    requires i >= 16;
    
    SeqLength(input) == 16;

    i < 15 ==> ValidAddr(mem, t4) && mem[t4] == input[i+1];
    input_slot == CheapMod16(i)*4;

    i >= 15 ==> i_plus_2  == CheapMod16(i+ 2)*4 && ValidAddr(mem, sp+i_plus_2);
    i >= 15 ==> i_plus_15 == CheapMod16(i+15)*4 && ValidAddr(mem, sp+i_plus_15);

    // t4 doesn't alias the stack
    i < 16 ==> t4 < sp || t4 >= sp + 18*4;

    // SHA semantics
    SeqLength(trace_in.H) > 0;
    IsSHA256TraceReadyForStep(trace_in, i);
    if i == 0 || i >= 16 then last(last(trace_in.atoh)) == atoh_c(a, b, c, d, e, f, g, h)
    else last(last(trace_in.atoh)) == atoh_c(BitwiseAdd32(a, t2), b, c, d, e, f, g, h);

    // t1 holds the current value of W
    t1 == (if (i < 16) then input[i] else last(trace_in.W)[i]);

    // The first 16 values in W are the byte-swapped version of the input words
    forall j :: 0 <= j < 16 ==> last(trace_in.W)[j] == bswap32(input[j]);

    // All previous Ws are in memory where we expect them
    i < 16 ==> (forall j :: 0 <= j < i ==> last(trace_in.W)[j] == mem[sp + j*4]);
    16 <= i < 64 ==> (forall j :: i - 16 <= j < i ==> last(trace_in.W)[j] == mem[sp + CheapMod16(j)*4]);

    // TODO: Remove when we have if/else and can skip the add of t2 when i == 0
    requires i == 0 ==> t2 == 0;

    // SHA tactics
    t3 == BitwiseXor(b, c);
    i >= 16 ==> RotateRight(t0, Sigma1(0)) == BSIG1(e);

ensures
    t2 == BitwiseXor(a, b);
    t3 == Maj(a, b, c);
    i < 16 ==> a == old(BitwiseAdd32(a, t2));
    lr == BitwiseAdd32(old(lr), 4);

    // Updated input ptr
    if i < 15 then t4 == BitwiseAdd32(old(t4), 4)   // Advanced input ptr
    else if i == 15 then mem[sp+17*4] == old(t4)    // We stored the advanced input ptr on the stack
    else mem[sp+17*4] == old(mem[sp+17*4]);         // We preserved the input ptr on the stack

// No longer need this in the ensures, since it's implied by the clauses below
//    let T1 := BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(old(h), BSIG1(e)),
//                                                     Ch(e,f,g)),
//                                        K_SHA256(i)),
//                           bswap32(old(t1))) in
//        d == BitwiseAdd32(old(d), T1)
//     && h == BitwiseAdd32(T1, BSIG0(a));

    exists trace_out:SHA256Trace ::
        IsSHA256TraceReadyForStep(trace_out, i+1)
     && trace_out.M == trace_in.M
     && trace_out.H == trace_in.H
     && trace_out.W == trace_in.W
     // t1 holds the next value of W
     && t1 == (if i + 1 < 16 then input[i + 1] else if i + 1 < 64 then mem[sp + i_plus_2] else t1) //last(trace_out.W)[i + 1] else t1)
     // Initial Ws are laid out in memory
     && (i + 1 < 16 ==> (forall j :: 0 <= j < i+1 ==> last(trace_out.W)[j] == mem[sp + j*4]))
     // Remaining Ws are laid out in memory
     && (16 <= i + 1 < 64 ==> (forall j :: i+1 - 16 <= j < i+1 ==> last(trace_out.W)[j] == mem[sp + CheapMod16(j)*4]))
     // The atohs almost match the outgoing variables
     && (let old_a := (if i == 0 || i >= 16 then old(a) else old(BitwiseAdd32(a, t2))) in
         last(last(trace_out.atoh)) == atoh_c(BitwiseAdd32(h, t3), old_a, old(b), old(c), d, old(e), old(f), old(g)));
{
//    //if i < 16
//    //  if i == 15
////          assert 68 == 17*4;    // OBSERVE
////          rSTR(t4, sp, 68 /*== 17*4*/);     // Save a copy of the incremented input pointer, so we can free up t4
//    //  end if
//
//    rEORShift(t0, e, e, RORShift(Sigma1(1) - Sigma1(0)));
//    // TODO: When i = 0, t2 = 0, so this is a no op.  We can skip it.  We can also remove the XOR that clears t2
//    rADDWrap(a, a, t2);  // h += Maj(a,b,c) from the past?
//    rEORShift(t0, t0, e, RORShift(Sigma1(2) - Sigma1(0)));   // Sigma1(e)
//    rREV(t1, t1);
//
//    //end if--------

    rLDRglobal(t2, K_SHA256s().sym, lr, 0);
    rADDWrap(lr, lr, 4);    // TODO: OpenSSL does this in one instruction with a load-and-increment.  
    rADDWrap(h, h, t1);      //  h+=X[i]  BP: X[i] = input[i]?
    //assert h == BitwiseAdd32(old(h), bswap32(old(t1)));
    rSTR(t1, sp, input_slot);  // @ BP: Save a copy of input[i] for use in subsequent W calculations
    rEOR(t1, f, g);
    ghost var old_h := h;
    //assert t0 == BitwiseXor(BitwiseXor(e, RotateRight(e, 5)), RotateRight(e, 19));
    rADDWrapShift(h, h, t0, RORShift(Sigma1(0))); // h += Sigma1(e)

    // Prove that we computed Sigma1(e) correctly:
    forall :: h == BitwiseAdd32(old_h, BSIG1(e))
    {
        reveal BSIG1;
        lemma_RotateRightCommutesXor(e, 6, 11, 25);
    }

    rAND(t1, t1, e);
    rADDWrap(h, h, OConst(K_SHA256(i)));      // h += K256(i)
    rEOR(t1, t1, g);     // Ch(e,f,g)
    
    assert t1 == Ch(e, f, g) by { lemma_Ch(e, f, g, t1); }

    rEORShift(t0, a, a, RORShift(Sigma0(1) - Sigma0(0)));
    rADDWrap(h, h, t1);  // h += Ch(e,f,g)

    ghost var old_t1 := if i < 16 then bswap32(old(t1)) else old(t1);
    assert h == BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(old(h), old_t1), BSIG1(e)), K_SHA256(i)), Ch(e, f, g));
    lemma_BitwiseAdd32Associates5(old(h), old_t1, BSIG1(e), K_SHA256(i), Ch(e, f, g), h);

//    #if $i==31
//        and  $t2,$t2,#0xff
//        cmp  $t2,#0xf2      @ done?
//    #endif

    // if $i<15
//         rLDR(t1, t4, 0);    // Prefetch
//         rADDWrap(t4, t4, 4);   // Advance to the next input  // TODO: OpenSSL does this in one instruction with a load-and-increment
//         rEOR(t2, a, b);            //  a^b, b^c in next round
    // else
       rLDR(t1, sp, i_plus_2);     // @ from future BODY_16_xx 
       rEOR(t2, a, b);             //  a^b, b^c in next round
       rLDR(t4, sp, i_plus_15);    // @ from future BODY_16_xx
    // endif
    rEORShift(t0,t0,a, RORShift(Sigma0(2)-Sigma0(0))); // Sigma0(a)
    rAND(t3,t3,t2);      // (b^c)&=(a^b)
    rADDWrap(d,d,h);     // d+=h
    rEOR(t3,t3,b);       // Maj(a,b,c)
    assert t3 == Maj(a,b,c) by { lemma_Maj(a, b, c, t3); }
    old_h := h;
    rADDWrapShift(h,h,t0, RORShift(Sigma0(0)));   // h+=Sigma0(a)

    // Prove we computed Sigma0(a) correctly:
    forall :: h == (old_h + BSIG0(a)) % 0x1_0000_0000
    {
        reveal BSIG0;
        lemma_RotateRightCommutesXor(a, 2, 13, 22);
    }

    // Prove that stack is still valid
    forall j :| 0 <= j < 18 
        :: ValidAddr(mem, sp + j * 4)
    {
        assert ValidAddr(old(mem), sp + j * 4);
    }

    ghost var T1 := BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(old(h), BSIG1(e)),
                                                           Ch(e,f,g)),
                                              K_SHA256(i)),
                                 old_t1);
    //assert h == BitwiseAdd32(T1, BSIG0(a));
    assert BitwiseAdd32(h, t3) == BitwiseAdd32(T1, BitwiseAdd32(BSIG0(a), t3)) by
           { lemma_BitwiseAdd32Associates3'(T1, BSIG0(a), t3); }

    // Construct a trace_out
    ghost var old_a := if i == 0 || i >= 16 then old(a) else old(BitwiseAdd32(a, t2));
    ghost var old_atoh := old(atoh_c(old_a, b, c, d, e, f, g, h));
    //assert last(last(trace_in.atoh)) == old_atoh;                                   
    ghost var new_atoh := atoh_c(BitwiseAdd32(h, t3), old_a, old(b), old(c), d, old(e), old(f), old(g));
    assert i == 0 ==> BitwiseAdd32(old(a), 0) == old(a);   // OBSERVE
    assert old_atoh.a == a;     // OBSERVE
     

    ghost var new_atoh_list := last(trace_in.atoh) + seq(new_atoh);
    ghost var trace_out:SHA256Trace := trace_in.(atoh := SeqDrop(trace_in.atoh, SeqLength(trace_in.H)-1) + seq(trace_in.atoh[SeqLength(trace_in.H)-1] + seq(new_atoh)));

    // OBSERVE: Triggers gallore!
    assert TBlk(SeqLength(trace_in.H)-1) && TBlk(SeqLength(trace_in.H)) && TStep(i) && TStep(i + 1);
    ghost var superfluous_state_in  := SHA256_state_c(last(trace_in.H), last(trace_in.W), old_atoh);
    ghost var superfluous_state_out := SHA256_state_c(last(trace_out.H), last(trace_out.W), new_atoh);
    lemma_SHA256TransitionOKAfterSettingAtoH(trace_in, superfluous_state_in, trace_out, superfluous_state_out, i);

    assert IsSHA256TraceReadyForStep(trace_out, i+1);
     assert trace_out.M == trace_in.M;
     assert trace_out.H == trace_in.H;
     assert trace_out.W == trace_in.W;
     // t1 holds the next value of W
     assert t1 == (if i + 1 < 16 then input[i + 1] else if i + 1 < 64 then mem[sp + i_plus_2] else t1);
             //last(trace_out.W)[i + 1] else t1);
     // Initial Ws are laid out in memory
     assert (i + 1 < 16 ==> (forall j :: 0 <= j < i+1 ==> last(trace_out.W)[j] == mem[sp + j*4]));
     // Remaining Ws are laid out in memory
     assert input_slot == CheapMod16(i)*4;
     assert (16 <= i + 1 < 64 ==> (forall j :: i+1 - 16 <= j < i+1 ==> last(trace_out.W)[j] == mem[sp + CheapMod16(j)*4]));
     // The atohs almost match the outgoing variables
     assert (let old_a := (if i == 0 || i >= 16 then old(a) else old(BitwiseAdd32(a, t2))) in
         last(last(trace_out.atoh)) == atoh_c(BitwiseAdd32(h, t3), old_a, old(b), old(c), d, old(e), old(f), old(g)));
}

procedure {:refined} Body_16_XX( 
    {:inline} i:SHA_step,
    {:inline} perm:perm_index,
    {:inline} input_slot:word,
    {:inline} input_slot_9:word,
    ghost trace_in:SHA256Trace,
    ghost input:seq(word),
    inout{:operand} t0:word,
    inout{:operand} t1:word,
    inout{:operand} t2:word,
    inout{:operand} t3:word,
    inout{:operand} t4:word,
    //inout{:operand} inp:word,
    inout{:operand} a:word,
         {:operand} b:word,
         {:operand} c:word,
    inout{:operand} d:word,
         {:operand} e:word,
         {:operand} f:word,
         {:operand} g:word,
    inout{:operand} h:word)

requires/ensures
    // Stack is accessible
    forall j {ValidAddr(mem, sp+j*4)} { mem?[sp+j*4] } :: 0 <= j < 18 ==> ValidAddr(mem, sp + j*4);
reads 
    sp; globals;
modifies 
    mem; lr;
requires {:refined false}
    @t0 == OReg(R0);
    @t1 == OReg(R2);
    @t2 == OReg(GetReg(if Even(i) then 12 else 3));
    @t3 == OReg(GetReg(if Even(i) then  3 else 12));
    @t4 == OReg(R1);
    //@inp == OReg(R1);
    @a  == OReg(GetReg(4+ApplyPerm(0, perm)));
    @b  == OReg(GetReg(4+ApplyPerm(1, perm)));
    @c  == OReg(GetReg(4+ApplyPerm(2, perm)));
    @d  == OReg(GetReg(4+ApplyPerm(3, perm)));
    @e  == OReg(GetReg(4+ApplyPerm(4, perm)));
    @f  == OReg(GetReg(4+ApplyPerm(5, perm)));
    @g  == OReg(GetReg(4+ApplyPerm(6, perm)));
    @h  == OReg(GetReg(4+ApplyPerm(7, perm)));

requires
    i >= 16;
    input_slot == CheapMod16(i)*4;
    input_slot_9 == CheapMod16(i+9)*4;
    ValidAddr(mem, sp + input_slot);
    ValidAddr(mem, sp + input_slot_9); 

    // K table adjusted properly
    ValidGlobalsAddr(globals, K_SHA256s().sym, lr);
    lr == AddressOfGlobal(K_SHA256s()) + 4*i;
    forall j :: 0 <= j < 64 ==> globals[K_SHA256s()][i] == K_SHA256(i);

    SeqLength(input) == 16;

    ValidAddr(mem, sp + CheapMod16(i +  2)*4);
    ValidAddr(mem, sp + CheapMod16(i + 15)*4);

    t3 == BitwiseXor(b, c);

    // SHA semantics
    SeqLength(trace_in.H) > 0;
    IsSHA256TraceReadyForStep(trace_in, i);
    last(last(trace_in.atoh)) == atoh_c(BitwiseAdd32(a, t2), b, c, d, e, f, g, h);

    // TODO: Need something about t1 here
    //t1 == (if (i < 16) then input[i] else last(trace_in.W)[i]);

    // The first 16 values in W are the byte-swapped version of the input words
    forall j :: 0 <= j < 16 ==> last(trace_in.W)[j] == bswap32(input[j]);

    // All previous Ws are in memory where we expect them
    i < 16 ==> (forall j :: 0 <= j < i ==> last(trace_in.W)[j] == mem[sp + j*4]);
    16 <= i < 64 ==> (forall j :: i - 16 <= j < i ==> last(trace_in.W)[j] == mem[sp + CheapMod16(j)*4]);
{
    //@ ldr  $t1,[sp,#`($i+1)%16`*4]    @ $i
    //@ ldr  $t4,[sp,#`($i+14)%16`*4]
    rMOVShift(t0, t1, RORShift(sigma0(0)));
    rADDWrap(a, a, t2);  // h+=Maj(a,b,c) from the past
    rMOVShift(t2, t4, RORShift(sigma1(0)));
    rEORShift(t0,t0,t1,RORShift(sigma0(1)));
    rEORShift(t2,t2,t4,RORShift(sigma1(1)));
    rEORShift(t0,t0,t1,LSRShift(sigma0(2)));     // sigma0(X[i+1])
    assert t0 == SSIG0(t1) by { reveal SSIG0; }

    rLDR(t1, sp, input_slot);
    rEORShift(t2,t2,t4, LSRShift(sigma1(2)));     // sigma1(X[i+14])
    assert t2 == SSIG1(t4) by { reveal SSIG1; }
    rLDR(t4, sp, input_slot_9);

    rADDWrap(t2,t2,t0);
    rEORShift(t0,e,e,RORShift(Sigma1(1)-Sigma1(0)));    // from BODY_00_15
    rADDWrap(t1,t1,t2);
    rEORShift(t0,t0,e,RORShift(Sigma1(2)-Sigma1(0)));  // Sigma1(e)  BP: Almost

    // Prove that we computed Sigma1(e) correctly:
    forall :: RotateRight(t0, Sigma1(0)) == BSIG1(e)
    {
        reveal BSIG1;
        lemma_RotateRightCommutesXor(e, 6, 11, 25);
    }

    rADDWrap(t1,t1,t4);      // X[i]

    // From the spec (and PartialSHA256TraceHasCorrectWs):  (TODO: Probably need to trigger z.W[blk] and TStep(i))
    ghost var W := last(trace_in.W);
    assert W[i] == BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(SSIG1(W[i-2]), W[i-7]), SSIG0(W[i-15])), W[i-16]);

    assert W[i- 2] == mem[sp + CheapMod16(i + 14)*4];
    assert W[i- 7] == mem[sp + CheapMod16(i +  9)*4];
    assert W[i-15] == mem[sp + CheapMod16(i +  1)*4];
    assert W[i-16] == mem[sp + CheapMod16(i +  0)*4] == mem[sp + input_ptr];

 // TODO: Call a lemma about BitwiseAdd32 associates
    assert t1 == BitwiseAdd32(BitwiseAdd32(input_slot=X[i]==W[i-16], BitwiseAdd32(SSIG1(t4=X[i+14]=X[i-2]), SSIG0(t1=X[i+1]=W[i-15]))), t4=input_slot_9 = W[i-7])



    
    assert t1 == last(trace_in.W)[i];       // TODO: Make this true

    Body_00_15(i, perm, input_slot, CheapMod16(i + 2)*4, CheapMod16(i + 15)*4, trace_in, input,
               t0, t1, t2, t3, t4, 
               a, b, c, d, e, f, g, h);
}

procedure {:refined} sha256_block_data_order(
    ghost trace_in:SHA256Trace,
    ghost input:seq(word)
    )
requires/ensures
    // Stack is accessible
    forall j {ValidAddr(mem, sp+j*4)} { mem?[sp+j*4] } :: 0 <= j < 18 ==> ValidAddr(mem, sp + j*4);
    
requires
    IsSHA256TraceReadyForStep(trace_in, 0);
    
//    // K table adjusted properly
//    ValidGlobalsAddr(globals, K_SHA256s().sym, lr);
//    lr == AddressOfGlobal(K_SHA256s()) + 4*i;
    ValidGlobals(globals);
    ValidGlobal(K_SHA256s());
    SeqLength(globals[K_SHA256s()]) == 64;
    forall j :: 0 <= j < 64 ==> globals[K_SHA256s()][j] == K_SHA256(j);

    let ctx := r0 in
    let input_ptr := r1 in
    let num_blocks := r2 in // Number of 64-byte blocks to process

     // Old H values are laid out in memory pointed at by ctx
        (forall j {ValidAddr(mem, ctx+j*4)} { mem?[ctx+j*4] } :: 0 <= j < 8 ==> ValidAddr(mem, ctx + j*4))
     && last(trace_in.H)[0] == mem[ctx + 0*4] == last(last(trace_in.atoh)).a
     && last(trace_in.H)[1] == mem[ctx + 1*4] == last(last(trace_in.atoh)).b
     && last(trace_in.H)[2] == mem[ctx + 2*4] == last(last(trace_in.atoh)).c
     && last(trace_in.H)[3] == mem[ctx + 3*4] == last(last(trace_in.atoh)).d
     && last(trace_in.H)[4] == mem[ctx + 4*4] == last(last(trace_in.atoh)).e
     && last(trace_in.H)[5] == mem[ctx + 5*4] == last(last(trace_in.atoh)).f
     && last(trace_in.H)[6] == mem[ctx + 6*4] == last(last(trace_in.atoh)).g
     && last(trace_in.H)[7] == mem[ctx + 7*4] == last(last(trace_in.atoh)).h
    //ConvertAtoHToSeq(last(trace_in.atoh)[0]) == last(trace_in.H);

     // TODO: Remove this once we have a while loop over num_blocks
     && num_blocks > 0

     // Ghost input matches in-memory input
     && SeqLength(input) == num_blocks*16
     && input_ptr + num_blocks*16 < 0x1_0000_0000
     && (forall j {ValidAddr(mem, input_ptr+j*4)} { mem?[input_ptr+j*4] } :: 
            0 <= j < num_blocks*16 ==> ValidAddr(mem, input_ptr + j*4)
                                   && mem[input_ptr + j*4] == input[j]
         )
     && (forall j :: 0 <= j < 16 ==> last(trace_in.W)[j] == bswap32(input[j]))

     // Anti-aliasing
     && (ctx + 7*4 < input_ptr || ctx > input_ptr + num_blocks*16)     // input_ptr != ctx
     && (ctx + 7*4 < sp || ctx >= sp + 18*4)                           // ctx != sp
     && (input_ptr + num_blocks*16 < sp || input_ptr >= sp + 18*4);              // input_ptr != sp

reads
    sp; globals;
modifies
    mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr;
ensures
//    exists trace_out:SHA256Trace ::
//        IsSHA256TraceReadyForStep(trace_out, 64)
//     && trace_out.M == trace_in.M
//     && trace_out.H == trace_in.H
//     && trace_out.W == trace_in.W;
{
    // TODO: Need to save the value in R2 to the stack

    rLDR( r4, r0, 0);       // a
    rLDR( r5, r0, 4);       // b
    rLDR( r6, r0, 8);       // c
    rLDR( r7, r0, 12);      // d
    rLDR( r8, r0, 16);      // e
    rLDR( r9, r0, 20);      // f
    rLDR(r10, r0, 24);      // g
    rLDR(r11, r0, 28);      // h

    rLDRglobaladdr(lr, K_SHA256s().sym);

    // Set up the initial conditions for BODY_00_15
    rLDR(r2, r1, 0);        // t1 <- input[0]
    assert r2 == input[0];
    rADDWrap(r1, r1, 4);        // TODO: OpenSSL does this with a single LDR instruction
    rEOR(r3, r5, r6);       // t3 <- B xor C  "@magic"
    rEOR(r12, r12, r12);    // TODO: Remove this unnecessary clear once we have if/else in Body_00_15
    assert r12 == 0 by { lemma_XorSelfIsZero(); }
    
    Body_00_15(0, 0, 0, 2, 15, trace_in, SeqDrop(input, 16), 
               r0, r2, r12, r3, r1, 
               r4, r5, r6, r7, r8, r9, r10, r11);




}
