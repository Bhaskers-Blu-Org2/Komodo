///////////////////////////////////////////////////
//
//  Based on sha256-armv4.pl form OpenSSL 1.0.2j
//
///////////////////////////////////////////////////


include {:verbatim} "sha256.i.dfy"
include {:verbatim} "sha256-refined-helpers.i.dfy"
include {:verbatim} "sha256-refined-invariants.i.dfy"

include "../ARMdecls.sdfy"

#verbatim
function method Sigma0(i:int) : word
    requires 0 <= i < 3;
{
    [2, 13, 22][i]
}

function method Sigma1(i:int) : word
    requires 0 <= i < 3;
{
    [6, 11, 25][i]
}

function method sigma0(i:int) : word
    requires 0 <= i < 3;
{
    [7, 18, 3][i]
}

function method sigma1(i:int) : word
    requires 0 <= i < 3;
{
    [17, 19, 10][i]
}

type SHA_step = i | 0 <= i < 64

function method GetReg(r:int) : ARMReg
    requires 0 <= r <= 12;
{
         if r ==  0 then R0
    else if r ==  1 then R1
    else if r ==  2 then R2
    else if r ==  3 then R3
    else if r ==  4 then R4
    else if r ==  5 then R5
    else if r ==  6 then R6
    else if r ==  7 then R7
    else if r ==  8 then R8
    else if r ==  9 then R9
    else if r == 10 then R10
    else if r == 11 then R11
    else R12 
}
#endverbatim

procedure {:refined} LDRPostInc(
    out operand dst:reg,
    inout operand src:reg)
reads
    mem;
requires {:refined false}
    !interrupts_enabled(this);
    @dst != @src;
requires
    ValidAddrMemStateOpaque(mem);
    ValidMem(src);
    isUInt32(src + WORDSIZE);
ensures
    dst == AddrMemContents(mem, old(src));
    src == old(src) + WORDSIZE;
{
    // TODO: OpenSSL does this in one instruction with a load-and-increment.
    LDR(dst, src, 0);    // Prefetch
    ADD(src, src, const(WORDSIZE));    // Advance to the next input
}

procedure {:refined} LDRglobalPostInc(
    out operand dst:reg,
    inout operand base:reg,
    ghost j:int)
reads
    globals;
requires {:refined false}
    !interrupts_enabled(this);
    @dst != @base;
requires
    SaneShaGlobal(globals);
    0 <= j < K_SHA256_WORDS;
    base == AddressOfGlobal(K_SHA256s()) + j * WORDSIZE;
ensures
    dst == K_SHA256(j);
    base == AddressOfGlobal(K_SHA256s()) + (j + 1) * WORDSIZE;
{
    reveal SaneShaGlobal;
    // TODO: OpenSSL does this in one instruction with a load-and-increment.
    LDRglobal(dst, K_SHA256s(), base, 0);
    ADD(base, base, const(WORDSIZE));
}

procedure {:refined} {:timeLimitMultiplier 2} Body_00_15(
    inline i:SHA_step,
    inline perm:perm_index,
    inline input_slot:word,
    inline i_plus_2:word,
    inline i_plus_15:word,
    ghost input_ptr:word,
    ghost trace_in:SHA256Trace,
    ghost input:seq(word),
    inout operand t0:reg,
    inout operand t1:reg,
    inout operand t2:reg,
    inout operand t3:reg,
    inout operand t4:reg,
    //inout operand inp:reg,
    inout operand a:reg,
          operand b:reg,
          operand c:reg,
    inout operand d:reg,
          operand e:reg,
          operand f:reg,
          operand g:reg,
    inout operand h:reg
    ) returns (
    ghost trace_out:SHA256Trace
    )
reads
    sp; globals;
modifies
    mem; lr;
requires {:refined false}
    !interrupts_enabled(this);
    //mode_of_state(this) == Monitor;
    @t0 == OReg(R0);
    @t1 == OReg(R2);
    @t2 == OReg(GetReg(if Even(i) then 12 else 3));
    @t3 == OReg(GetReg(if Even(i) then  3 else 12));
    @t4 == OReg(R1);
    //@inp == OReg(R1);
    @a  == OReg(GetReg(4+ApplyPerm(0, perm)));
    @b  == OReg(GetReg(4+ApplyPerm(1, perm)));
    @c  == OReg(GetReg(4+ApplyPerm(2, perm)));
    @d  == OReg(GetReg(4+ApplyPerm(3, perm)));
    @e  == OReg(GetReg(4+ApplyPerm(4, perm)));
    @f  == OReg(GetReg(4+ApplyPerm(5, perm)));
    @g  == OReg(GetReg(4+ApplyPerm(6, perm)));
    @h  == OReg(GetReg(4+ApplyPerm(7, perm)));
requires/ensures
    ValidAddrMemStateOpaque(mem);
requires
    //ValidMem(sp + input_slot);
    // Stack is accessible
    ValidMemRange(sp, sp + SHA_STACKSIZE * WORDSIZE);

    // Ghost input matches in-memory input  
    SeqLength(input) == SHA_BLOCKSIZE;
    i < SHA_BLOCKSIZE ==>
        isUInt32(input_ptr + SHA_BLOCKSIZE * WORDSIZE)
     && (input_ptr + SHA_BLOCKSIZE * WORDSIZE < sp || sp + SHA_STACKSIZE * WORDSIZE <= input_ptr)    // input_ptr doesn't alias the stack
     && ValidMemRange(input_ptr, input_ptr + SHA_BLOCKSIZE * WORDSIZE)
     && InputMatchesMemory(input, input_ptr, SHA_BLOCKSIZE, mem);

    // K table adjusted properly
    SaneShaGlobal(globals);
    //ValidGlobalAddr(K_SHA256s(), lr);
    lr == AddressOfGlobal(K_SHA256s()) + i*WORDSIZE;

    i < SHA_BLOCKSIZE ==> t4 == input_ptr + (i+1)*WORDSIZE;

    input_slot == CheapMod16(i)*WORDSIZE;

    i >= 15 ==> i_plus_2  == CheapMod16(i+ 2)*WORDSIZE && ValidMem(sp+i_plus_2);
    i >= 15 ==> i_plus_15 == CheapMod16(i+15)*WORDSIZE && ValidMem(sp+i_plus_15);

    // SHA semantics
    SeqLength(trace_in.H) > 0;
    IsSHA256TraceReadyForStep(trace_in, i);
    if i == 0 || i >= 16 then last(last(trace_in.atoh)) == atoh_c(a, b, c, d, e, f, g, h)
    else last(last(trace_in.atoh)) == atoh_c(BitwiseAdd32(a, t2), b, c, d, e, f, g, h);

    // t1 holds the current value of W
    t1 == (if (i < SHA_BLOCKSIZE) then input[i] else last(trace_in.W)[i]);

    // The first 16 values in W are the byte-swapped version of the input words
    forall j :: 0 <= j < SHA_BLOCKSIZE ==> last(trace_in.W)[j] == bswap32(input[j]);

    // All previous Ws are in memory where we expect them
    WsMatchMemory(trace_in, i, sp, mem);

    // SHA tactics
    t3 == BitwiseXor(b, c);
    i >= SHA_BLOCKSIZE ==> RotateRight(t0, Sigma1(0)) == BSIG1(e);

ensures
    sp == old(sp);
    lr == old(lr) + WORDSIZE;

    // Memory framing: We only touch the stack
    AddrMemPreservingExcept(old(mem), mem, sp, sp + SHA_STACKSIZE * WORDSIZE);
    AddrMemContents(mem, sp + 16*WORDSIZE) == AddrMemContents(old(mem), sp + 16*WORDSIZE);
    AddrMemContents(mem, sp + 18*WORDSIZE) == AddrMemContents(old(mem), sp + 18*WORDSIZE);

    i < SHA_BLOCKSIZE ==> InputMatchesMemory(input, input_ptr, SHA_BLOCKSIZE, mem);
    t2 == BitwiseXor(a, b);
    a == (if 0 < i < 16 then old(BitwiseAdd32(a, t2)) else old(a));
    i >= 15 ==> t4 == AddrMemContents(mem, sp+i_plus_15);

    // Updated input ptr
    if i < 15 then t4 == input_ptr + (i+2)*WORDSIZE              // Advanced input ptr
    else 
        t4 == AddrMemContents(mem, sp + i_plus_15)
     && (if i == 15 then AddrMemContents(mem, sp+17*WORDSIZE) == input_ptr+16*WORDSIZE   // We stored the advanced input ptr on the stack
         else AddrMemContents(mem, sp+17*WORDSIZE) == old(AddrMemContents(mem,sp+17*WORDSIZE)));               // We preserved the input ptr on the stack

    IsSHA256TraceReadyForStep(trace_out, i+1);
    trace_out.M == trace_in.M;
    trace_out.H == trace_in.H;
    trace_out.W == trace_in.W;
    // t1 holds the next value of W
    t1 == (if i + 1 < SHA_BLOCKSIZE then input[i + 1] else if i + 1 <= 64 then AddrMemContents(mem, sp + i_plus_2) else t1); //last(trace_out.W)[i + 1] else t1)
    WsMatchMemory(trace_out, i+1, sp, mem);
    // The atohs almost match the outgoing variables
    last(last(trace_out.atoh)) == atoh_c(BitwiseAdd32(h, t3), a, b, c, d, e, f, g);
{
    assert WordAligned(sp);

    inline if (i < SHA_BLOCKSIZE) {
        inline if (i == SHA_BLOCKSIZE - 1) {
            // Save a copy of the incremented input pointer, so we can free up t4
            STR(t4, sp, const(17 * WORDSIZE));
        }

        EORShift(t0, e, e, RORShift(Sigma1(1) - Sigma1(0)));
        // Optimize the first case.  This is an optimization that OpenSSL misses! 
        inline if (i != 0) {
            ADDWrap(a, a, t2);  // h += Maj(a,b,c) from the past?
        }
        EORShift(t0, t0, e, RORShift(Sigma1(2) - Sigma1(0)));   // Sigma1(e)
        REV(t1, t1);
    }

    assert if (i == SHA_BLOCKSIZE - 1)
           then mem == AddrMemUpdate(old(mem), sp + 17*WORDSIZE,
                                     AddrMemContents(mem, sp + 17*WORDSIZE))
           else mem == old(mem);

    LDRglobalPostInc(t2, lr, i);
    //lemma_mod_in_bounds2(i, AddressOfGlobal(K_SHA256s()), old(lr), lr);
    ADDWrap(h, h, t1);      //  h+=X[i]  BP: X[i] = input[i]?
    assert ValidMem(sp + input_slot);
    STR(t1, sp, input_slot);  // @ BP: Save a copy of W[i] for use in subsequent W calculations

    // Prove that stack is still valid
    assert sp == old(sp);
    // Help prove that the input is still intact
    assert ValidMem(sp + 17*WORDSIZE);
    assert mem == AddrMemUpdate(AddrMemUpdate(old(mem), sp + 17*WORDSIZE,
                                              AddrMemContents(mem, sp + 17*WORDSIZE)),
                                sp + input_slot,
                                AddrMemContents(mem, sp + input_slot));
    ghost var finalmem := mem;

    EOR(t1, f, g);
    ghost var old_h := h;
    ADDWrapShift(h, h, t0, RORShift(Sigma1(0))); // h += Sigma1(e)

    // Prove that we computed Sigma1(e) correctly:
    assert h == BitwiseAdd32(old_h, BSIG1(e))
    by {
        reveal BSIG1;
        lemma_BSIGOptimization(e, 6, 11, 25);
    }

    AND(t1, t1, e);
    ADDWrap(h, h, t2);  // h += K256(i)
    EOR(t1, t1, g);     // Ch(e,f,g)
    
    assert t1 == Ch(e, f, g) by { lemma_Ch(e, f, g, t1); }

    EORShift(t0, a, a, RORShift(Sigma0(1) - Sigma0(0)));
    ADDWrap(h, h, t1);  // h += Ch(e,f,g)

    ghost var old_t1 := if i < SHA_BLOCKSIZE then bswap32(old(t1)) else old(t1);
    assert h == BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(old(h), old_t1), BSIG1(e)), K_SHA256(i)), Ch(e, f, g));
    lemma_BitwiseAdd32Associates5(old(h), old_t1, BSIG1(e), K_SHA256(i), Ch(e, f, g), h);

//    #if $i==31
//        and  $t2,$t2,#0xff
//        cmp  $t2,#0xf2      @ done?
//    #endif

    inline if (i < SHA_BLOCKSIZE-1) {
        assert ValidMem(t4) by { // OBSERVE
            assert t4 == old(t4) == input_ptr + (i+1)*WORDSIZE;
            assert ValidMemRange(input_ptr, input_ptr + SHA_BLOCKSIZE * WORDSIZE);
            assert i < SHA_BLOCKSIZE;
        }
        LDRPostInc(t1, t4);    // Prefetch & advance to the next input
        //lemma_mod_in_bounds(i, input_ptr, old(t4), t4);
//         assert old(t4) + 4 == input_ptr + (i+1)*4 + 4 == input_ptr + (i+2)*4;
//         assert isUInt32(input_ptr + (i+2)*4);
        //assert t4 == old(t4) + 4;
        EOR(t2, a, b);            //  a^b, b^c in next round
    } else {
        //assert ValidMem(sp+i_plus_2);  // OBSERVE
        //assert ValidMem(sp+i_plus_15); // OBSERVE
        LDR(t1, sp, i_plus_2);     // @ from future BODY_16_xx 
        EOR(t2, a, b);             //  a^b, b^c in next round
        LDR(t4, sp, i_plus_15);    // @ from future BODY_16_xx
    }
    assert t2 == BitwiseXor(a, b);
    EORShift(t0,t0,a, RORShift(Sigma0(2)-Sigma0(0))); // Sigma0(a)
    AND(t3,t3,t2);      // (b^c)&=(a^b)
    ADDWrap(d,d,h);     // d+=h
    ghost var t3' := t3;
    EOR(t3,t3,b);       // Maj(a,b,c)
    assert t3 == Maj(a,b,c) by {
        assert t2 == BitwiseXor(a, b);
        assert old(t3) == BitwiseXor(b, c);
        assert t3' == BitwiseAnd(BitwiseXor(b, c), BitwiseXor(a, b));
        assert t3 == BitwiseXor(t3', b);
        lemma_Maj(a, b, c, t3);
    }
    old_h := h;
    ADDWrapShift(h,h,t0, RORShift(Sigma0(0)));   // h+=Sigma0(a)

    // Prove we computed Sigma0(a) correctly:
    assert h == TruncateWord(old_h + BSIG0(a))
    by {
        reveal BSIG0;
        lemma_BSIGOptimization(a, 2, 13, 22);
    }

    ghost var T1 := BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(old(h), BSIG1(e)),
                                                           Ch(e,f,g)),
                                              K_SHA256(i)),
                                 old_t1);
    assert BitwiseAdd32(h, t3) == BitwiseAdd32(T1, BitwiseAdd32(BSIG0(a), t3)) by
           { lemma_BitwiseAdd32Associates3'(T1, BSIG0(a), t3); }

    // Construct a trace_out
    ghost var old_a := if i == 0 || i >= SHA_BLOCKSIZE then old(a) else old(BitwiseAdd32(a, t2));
    ghost var old_atoh := old(atoh_c(old_a, b, c, d, e, f, g, h));
    ghost var new_atoh := atoh_c(BitwiseAdd32(h, t3), old_a, old(b), old(c), d, old(e), old(f), old(g));
    lemma_BitwiseAdd32_properties(old(a));
    assert i == 0 ==> BitwiseAdd32(old(a), 0) == old(a);   // OBSERVE
    assert old_atoh.a == a;     // OBSERVE

    ghost var new_atoh_list := last(trace_in.atoh) + seq(new_atoh);
    trace_out := trace_in.(atoh := SeqDrop(trace_in.atoh, SeqLength(trace_in.H)-1) + seq(trace_in.atoh[SeqLength(trace_in.H)-1] + seq(new_atoh)));

    // OBSERVE: Triggers galore!
    assert TBlk(SeqLength(trace_in.H)-1) && TBlk(SeqLength(trace_in.H)) && TStep(i) && TStep(i + 1);
    ghost var superfluous_state_in  := SHA256_state_c(last(trace_in.H), last(trace_in.W), old_atoh);
    ghost var superfluous_state_out := SHA256_state_c(last(trace_out.H), last(trace_out.W), new_atoh);
    lemma_SHA256TransitionOKAfterSettingAtoH(trace_in, superfluous_state_in, trace_out, superfluous_state_out, i);

    assert IsSHA256TraceReadyForStep(trace_out, i+1);

    // Prove that stack is still valid
    assert sp == old(sp);
    assert mem == finalmem;
    //lemma_ValidAddrsPreservation(old(mem), mem, sp, 19, sp + 68, sp + input_slot);

    // Help prove that the input is still intact
    //assert mem == AddrMemUpdate(AddrMemUpdate(old(mem), sp + 17*WORDSIZE,
    //                                          AddrMemContents(mem, sp + 17*WORDSIZE)),
    //                            sp + input_slot,
    //                            AddrMemContents(mem, sp + input_slot));
        // by { reveal ValidAddrMemStateOpaque; // XXX: dafny opaque bug #63 }
    ghost if (i < SHA_BLOCKSIZE) {
        lemma_InputPreservation(old(mem), mem, input, input_ptr, SHA_BLOCKSIZE, sp + 17*WORDSIZE, sp + input_slot);

        // Prove input is still valid src
        //lemma_ValidSrcAddrsPreservation(old(mem), mem, input_ptr, SHA_BLOCKSIZE, input_taint, sp + 68, sp + input_slot);
     }
   
    // Prove we updated the Ws correctly
    lemma_WsIncrement(old(mem), mem, trace_in, trace_out, sp, i, sp + 17*WORDSIZE, sp + input_slot);
    assert {:split_here}{:refined} true;
    assert ValidMem(sp + 16*WORDSIZE); // OBSERVE
    assert ValidMem(sp + 18*WORDSIZE); // OBSERVE
    assert AddrMemContents(mem, sp + 18*WORDSIZE) == AddrMemContents(old(mem), sp + 18*WORDSIZE);
}

#verbatim

predicate Body_00_15LoopStateInvariantBreakdown(
    orig_mem:memmap,
    mem:memmap,
    input_ptr:word,
    orig_trace:SHA256Trace,
    current_trace:SHA256Trace,
    i:int,
    sp:word,
    globals:globalsmap,
    lr:word,
    t1:word,
    t2:word,
    t3:word,
    t4:word,
    input:seq<word>,
    a:word, b:word, c:word, d:word, e:word, f:word, g:word, h:word
    )
{
    0 <= i <= SHA_BLOCKSIZE
 && ValidMemRange(sp, sp + SHA_STACKSIZE * WORDSIZE)
 && ValidMem(sp + CheapMod16(i)*WORDSIZE)
 && ValidMem(sp + CheapMod16(i+9)*WORDSIZE)
 && ValidAddrMemStateOpaque(orig_mem)
 && ValidAddrMemStateOpaque(mem)

    // K table adjusted properly
 && SaneShaGlobal(globals)
// && ValidGlobalAddr(K_SHA256s(), lr)
 && lr == AddressOfGlobal(K_SHA256s()) + i*WORDSIZE

    // Ghost input matches in-memory input
 && SeqLength(input) == SHA_BLOCKSIZE
 && (i < SHA_BLOCKSIZE ==>
        isUInt32(input_ptr + 16*WORDSIZE)
     && (input_ptr + 16*WORDSIZE < sp || sp + 19*WORDSIZE <= input_ptr)    // input_ptr doesn't alias the stack
     && ValidMemRange(input_ptr, input_ptr + SHA_BLOCKSIZE * WORDSIZE)
     && InputMatchesMemory(input, input_ptr, SHA_BLOCKSIZE, mem)
    )

 && ValidMem(sp + CheapMod16(i +  2)*WORDSIZE)
 && ValidMem(sp + CheapMod16(i + 15)*WORDSIZE)

 && t3 == BitwiseXor(b, c)

    // Memory framing: We only touch the stack
 && AddrMemPreservingExcept(orig_mem, mem, sp, sp + SHA_STACKSIZE * WORDSIZE)
 && AddrMemContents(mem, sp + 16*WORDSIZE) == AddrMemContents(orig_mem, sp + 16*WORDSIZE)
 && AddrMemContents(mem, sp + 18*WORDSIZE) == AddrMemContents(orig_mem, sp + 18*WORDSIZE)

    // SHA semantics
 && SeqLength(current_trace.H) > 0
 && IsSHA256TraceReadyForStep(current_trace, i)
 && current_trace.M == orig_trace.M
 && current_trace.H == orig_trace.H
 && current_trace.W == orig_trace.W
 && (last(last(current_trace.atoh)) == 
        if i == 0 then 
            atoh_c(a, b, c, d, e, f, g, h)
        else 
            atoh_c(BitwiseAdd32(a, t2), b, c, d, e, f, g, h))

    // t1 holds the current value of W
 && t1 == (if (i < 16) then input[i] else if i + 1 <= 64 then AddrMemContents(mem, sp + CheapMod16(i+1)*WORDSIZE) else last(current_trace.W)[i])

    // The first 16 values in W are the byte-swapped version of the input words
 && (forall j :: 0 <= j < 16 ==> last(current_trace.W)[j] == bswap32(input[j]))

    // All previous Ws are in memory where we expect them
 && (16 <= i < 64 ==> (forall j :: i - 16 <= j < i ==> last(current_trace.W)[j] == AddrMemContents(mem, sp + CheapMod16(j)*WORDSIZE)))
 && (i < SHA_BLOCKSIZE ==> (forall j :: 0 <= j < i ==> last(current_trace.W)[j] == AddrMemContents(mem, sp + j*WORDSIZE)))
 && (i < (SHA_BLOCKSIZE-1) ==> ValidMem(t4) && AddrMemContents(mem, t4) == input[i+1])

     // Updated input ptr
 && (if i < SHA_BLOCKSIZE then t4 == input_ptr + (i+1)*WORDSIZE         // Correctly advanced input ptr
     else AddrMemContents(mem, sp+17*WORDSIZE) == input_ptr + 16*WORDSIZE)             // We preserved the advanced input ptr on the stack

 && (i >= SHA_BLOCKSIZE ==> t4 == AddrMemContents(mem, sp + CheapMod16(i+14)*WORDSIZE))
}

#endverbatim

procedure {:refined} {:recursive} {:timeLimitMultiplier 2} Body_00_15UnrolledRecursive(
    inline n:int,
    inline i:int,
    inline perm:perm_index,
    ghost input_ptr:word,
    ghost orig_trace:SHA256Trace,
    ghost trace_in:SHA256Trace,
    ghost input:seq(word),
    inout operand t0:word,
    inout operand t1:word,
    inout operand t2:word,
    inout operand t3:word,
    inout operand t4:word,
    inout operand a:word,
    inout operand b:word,
    inout operand c:word,
    inout operand d:word,
    inout operand e:word,
    inout operand f:word,
    inout operand g:word,
    inout operand h:word
    ) returns (
    ghost trace_out:SHA256Trace
    )
  requires
    0 <= n <= SHA_BLOCKSIZE;
    n == SHA_BLOCKSIZE - i;
    perm == OpaqueMod(i, 8);
requires {:refined false}
    !interrupts_enabled(this);
    @t0 == OReg(R0);
    @t1 == OReg(R2);
    @t2 == OReg(GetReg(if Even(i) then 12 else 3));
    @t3 == OReg(GetReg(if Even(i) then  3 else 12));
    @t4 == OReg(R1);
    //@inp == OReg(R1);
    @a  == OReg(GetReg(4+ApplyPerm(0, perm)));
    @b  == OReg(GetReg(4+ApplyPerm(1, perm)));
    @c  == OReg(GetReg(4+ApplyPerm(2, perm)));
    @d  == OReg(GetReg(4+ApplyPerm(3, perm)));
    @e  == OReg(GetReg(4+ApplyPerm(4, perm)));
    @f  == OReg(GetReg(4+ApplyPerm(5, perm)));
    @g  == OReg(GetReg(4+ApplyPerm(6, perm)));
    @h  == OReg(GetReg(4+ApplyPerm(7, perm)));
  requires
    Body_00_15LoopStateInvariantBreakdown(mem, mem, input_ptr, orig_trace, trace_in, i, sp, globals, lr,
                                          t1, t2, t3, t4, input,
                                          a, b, c, d, e, f, g, h);
  reads
    sp; globals;
  modifies
    mem; lr;
  ensures
    let arr := seq8(a, b, c, d, e, f, g, h) in
        Body_00_15LoopStateInvariantBreakdown(old(mem), mem, input_ptr, orig_trace, trace_out, 16, sp, globals, lr,
                                              t1, if Even(n) then t2 else t3, if Even(n) then t3 else t2, t4, input,
                                              SelectPerm(arr, 0, perm), SelectPerm(arr, 1, perm), SelectPerm(arr, 2, perm),
                                              SelectPerm(arr, 3, perm), SelectPerm(arr, 4, perm), SelectPerm(arr, 5, perm),
                                              SelectPerm(arr, 6, perm), SelectPerm(arr, 7, perm));
{
    inline if (0 < n <= SHA_BLOCKSIZE && 0 <= i < SHA_BLOCKSIZE) {
        assert OpaqueMod(i + 1, 8) == (if perm == 7 then 0 else perm + 1) by { reveal OpaqueMod; }
        ghost var trace_mid:SHA256Trace;
        trace_mid := Body_00_15(i, perm,
                                CheapMod16(i)*WORDSIZE, CheapMod16(i+2)*WORDSIZE, CheapMod16(i+15)*WORDSIZE,
                                input_ptr, trace_in, input,
                                t0, t1, t2, t3, t4,
                                a, b, c, d, e, f, g, h);
        trace_out := Body_00_15UnrolledRecursive(n-1, i+1, if perm == 7 then 0 else perm + 1,
                                                 input_ptr, orig_trace, trace_mid, input,
                                                 t0, t1, t3, t2, t4,
                                                 h, a, b, c, d, e, f, g);
    }
    else {
        assert OpaqueMod(i, 8) == 0 by { reveal OpaqueMod; }
        trace_out := trace_in;
    }
}

procedure {:refined} Body_00_15LoopUnrolled(
    ghost input_ptr:word,
    ghost trace_in:SHA256Trace,
    ghost input:seq(word)
    ) returns (
    ghost trace_out:SHA256Trace
    )
    requires Body_00_15LoopStateInvariantBreakdown(mem, mem, input_ptr, trace_in, trace_in, 0, sp, globals, lr,
                                                   r2, r12, r3, r1, input,
                                                   r4, r5, r6, r7, r8, r9, r10, r11);
    requires {:refined false} !interrupts_enabled(this);
    reads  sp; globals;
    modifies mem; lr; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12;
    ensures  Body_00_15LoopStateInvariantBreakdown(old(mem), mem, input_ptr, trace_in, trace_out, 16, sp, globals, lr,
                                                   r2, r12, r3, r1, input,
                                                   r4, r5, r6, r7, r8, r9, r10, r11);
{
    assert OpaqueMod(0, 8) == 0 by { reveal OpaqueMod; }
    trace_out := Body_00_15UnrolledRecursive(16, 0, 0, input_ptr, trace_in, trace_in, input,
                                             r0, r2, r12, r3, r1,
                                             r4, r5, r6, r7, r8, r9, r10, r11);
}



procedure {:refined} {:timeLimitMultiplier 3} Body_16_XX( 
    inline i:SHA_step,
    inline perm:perm_index,
    inline input_slot:word,
    inline input_slot_9:word,
    ghost trace_in:SHA256Trace,
    ghost input:seq(word),
    inout operand t0:word,
    inout operand t1:word,
    inout operand t2:word,
    inout operand t3:word,
    inout operand t4:word,
    inout operand a:word,
          operand b:word,
          operand c:word,
    inout operand d:word,
          operand e:word,
          operand f:word,
          operand g:word,
    inout operand h:word)

requires/ensures
    // Stack is accessible
    ValidMemRange(sp, sp + 19 * WORDSIZE);
reads 
    sp; globals;
modifies 
    mem; lr;
requires {:refined false}
    !interrupts_enabled(this);
    @t0 == OReg(R0);
    @t1 == OReg(R2);
    @t2 == OReg(GetReg(if Even(i) then 12 else 3));
    @t3 == OReg(GetReg(if Even(i) then  3 else 12));
    @t4 == OReg(R1);
    @a  == OReg(GetReg(4+ApplyPerm(0, perm)));
    @b  == OReg(GetReg(4+ApplyPerm(1, perm)));
    @c  == OReg(GetReg(4+ApplyPerm(2, perm)));
    @d  == OReg(GetReg(4+ApplyPerm(3, perm)));
    @e  == OReg(GetReg(4+ApplyPerm(4, perm)));
    @f  == OReg(GetReg(4+ApplyPerm(5, perm)));
    @g  == OReg(GetReg(4+ApplyPerm(6, perm)));
    @h  == OReg(GetReg(4+ApplyPerm(7, perm)));

requires
    i >= SHA_BLOCKSIZE;
    input_slot == CheapMod16(i)*WORDSIZE;
    input_slot_9 == CheapMod16(i+9)*WORDSIZE;
    ValidMem(sp + input_slot);
    ValidMem(sp + input_slot_9); 
    ValidAddrMemStateOpaque(mem);

    // K table adjusted properly
    SaneShaGlobal(globals);
    lr == AddressOfGlobal(K_SHA256s()) + i*WORDSIZE;
    //ValidGlobalAddr(K_SHA256s(), lr);

    SeqLength(input) == SHA_BLOCKSIZE;

    ValidMem(sp + CheapMod16(i +  2)*WORDSIZE);
    ValidMem(sp + CheapMod16(i + 15)*WORDSIZE);

    t3 == BitwiseXor(b, c);

    // SHA semantics
    SeqLength(trace_in.H) > 0;
    IsSHA256TraceReadyForStep(trace_in, i);
    last(last(trace_in.atoh)) == atoh_c(BitwiseAdd32(a, t2), b, c, d, e, f, g, h);

    // The first 16 values in W are the byte-swapped version of the input words
    forall j :: 0 <= j < 16 ==> last(trace_in.W)[j] == bswap32(input[j]);

    // All previous Ws are in memory where we expect them
    16 <= i < 64 ==> (forall j :: i - 16 <= j < i ==> last(trace_in.W)[j] == AddrMemContents(mem, sp + CheapMod16(j)*WORDSIZE));

    // t1 and t4 should already hold previous W values
    t1 == AddrMemContents(mem, sp + CheapMod16(i+1)*WORDSIZE);
    t4 == AddrMemContents(mem, sp + CheapMod16(i+14)*WORDSIZE);
ensures 
    ValidAddrMemStateOpaque(mem);
    t2 == BitwiseXor(a, b);
    lr == old(lr) + 4;
    t4 == AddrMemContents(mem, sp+CheapMod16(i + 15)*WORDSIZE);

    AddrMemContents(mem, sp+17*WORDSIZE) == AddrMemContents(old(mem), sp+17*WORDSIZE);         // We preserved the input ptr on the stack

    // Memory framing: We only touch the stack
    AddrMemPreservingExcept(old(mem), mem, sp, sp + SHA_STACKSIZE * WORDSIZE);
    AddrMemContents(mem, sp + 16*WORDSIZE) == AddrMemContents(old(mem), sp + 16*WORDSIZE);
    AddrMemContents(mem, sp + 18*WORDSIZE) == AddrMemContents(old(mem), sp + 18*WORDSIZE);

    exists trace_out:SHA256Trace ::
        IsSHA256TraceReadyForStep(trace_out, i+1)
     && trace_out.M == trace_in.M
     && trace_out.H == trace_in.H
     && trace_out.W == trace_in.W
     // t1 holds the next value of W
     && t1 == (if i + 1 <= 64 then AddrMemContents(mem, sp + CheapMod16(i + 2)*WORDSIZE) else t1) 

     // Remaining Ws are laid out in memory
     && (i + 1 < 64 ==> (forall j :: i+1 - 16 <= j < i+1 ==> ValidMem(sp + CheapMod16(j)*WORDSIZE) && last(trace_out.W)[j] == AddrMemContents(mem, sp + CheapMod16(j)*WORDSIZE)))

     // The atohs almost match the outgoing variables
     //&& (let old_a := (if i == 0 || i >= 16 then old(a) else old(BitwiseAdd32(a, t2))) in
     && last(last(trace_out.atoh)) == atoh_c(BitwiseAdd32(h, t3), a, b, c, d, e, f, g);
{
    MOVShift(t0, t1, RORShift(sigma0(0)));
    ADDWrap(a, a, t2);  // h+=Maj(a,b,c) from the past
    MOVShift(t2, t4, RORShift(sigma1(0)));
    EORShift(t0,t0,t1,RORShift(sigma0(1)));
    EORShift(t2,t2,t4,RORShift(sigma1(1)));
    EORShift(t0,t0,t1,LSRShift(sigma0(2)));     // sigma0(X[i+1])
    assert t0 == SSIG0(t1) by { reveal SSIG0; }

    LDR(t1, sp, input_slot);
    EORShift(t2,t2,t4, LSRShift(sigma1(2)));     // sigma1(X[i+14])
    assert t2 == SSIG1(t4) by { reveal SSIG1; }
    LDR(t4, sp, input_slot_9);

    ADDWrap(t2,t2,t0);
    EORShift(t0,e,e,RORShift(Sigma1(1)-Sigma1(0)));    // from BODY_00_15
    ADDWrap(t1,t1,t2);
    EORShift(t0,t0,e,RORShift(Sigma1(2)-Sigma1(0)));  // Sigma1(e)  BP: Almost

    // Prove that we computed Sigma1(e) correctly:
    forall :: RotateRight(t0, Sigma1(0)) == BSIG1(e)
    {
        reveal BSIG1;
        lemma_BSIGOptimization(e, 6, 11, 25);
    }

    ADDWrap(t1,t1,t4);      // X[i]

    // From the spec (and PartialSHA256TraceHasCorrectWs):
    ghost var W := last(trace_in.W);
    assert TStep(i);
    assert W[i] == BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(SSIG1(W[i-2]), W[i-7]), SSIG0(W[i-15])), W[i-16]);
    assert t1 == W[i] by {
        lemma_BitwiseAdd32Associates4(SSIG1(W[i-2]), W[i-7], SSIG0(W[i-15]), W[i-16], t1);
    }

    ghost var mid_a := a;
    ghost var mid_t2 := t2;
    ghost var dummy_input_ptr:word;  // Body_00_15 only cares about the value for i < 16
    ghost var trace_out:SHA256Trace;
    trace_out := Body_00_15(i, perm, input_slot, CheapMod16(i + 2)*WORDSIZE, CheapMod16(i + 15)*WORDSIZE, 
                            dummy_input_ptr, trace_in, input,
                            t0, t1, t2, t3, t4, 
                            a, b, c, d, e, f, g, h);
    assert a == mid_a;
    assert {:split_here}{:refined} true;
}

#verbatim

predicate {:opaque} Body_16_XXLoopStateInvariantBreakdown(
    orig_mem:memmap,
    mem:memmap,
    orig_trace:SHA256Trace,
    current_trace:SHA256Trace,
    i:int,
    sp:word,
    globals:globalsmap,
    lr:word,
    t1:word,
    t2:word,
    t3:word,
    t4:word,
    input:seq<word>,
    a:word, b:word, c:word, d:word, e:word, f:word, g:word, h:word
    )
{
    16 <= i <= 64
 && ValidMemRange(sp, sp + SHA_STACKSIZE * WORDSIZE)
 && ValidMem(sp + CheapMod16(i)*WORDSIZE)
 && ValidMem(sp + CheapMod16(i+9)*WORDSIZE)
 && ValidAddrMemStateOpaque(mem)
 && ValidAddrMemStateOpaque(orig_mem)

    // K table adjusted properly
 && SaneShaGlobal(globals)
 && lr == AddressOfGlobal(K_SHA256s()) + i*WORDSIZE

 && SeqLength(input) == SHA_BLOCKSIZE

 && ValidMem(sp + CheapMod16(i +  2)*WORDSIZE)
 && ValidMem(sp + CheapMod16(i + 15)*WORDSIZE)

 && t3 == BitwiseXor(b, c)

    // Memory framing: We only touch the stack
 && AddrMemPreservingExcept(orig_mem, mem, sp, sp + 16*WORDSIZE)

    // SHA semantics
 && SeqLength(current_trace.H) > 0
 && IsSHA256TraceReadyForStep(current_trace, i)
 && current_trace.M == orig_trace.M
 && current_trace.H == orig_trace.H
 && current_trace.W == orig_trace.W
 && last(last(current_trace.atoh)) == atoh_c(BitwiseAdd32(a, t2), b, c, d, e, f, g, h)

    // The first 16 values in W are the byte-swapped version of the input words
 && (forall j :: 0 <= j < 16 ==> last(current_trace.W)[j] == bswap32(input[j]))

    // All previous Ws are in memory where we expect them
 && (16 <= i < 64 ==> (forall j :: i - 16 <= j < i ==> last(current_trace.W)[j] == AddrMemContents(mem, sp + CheapMod16(j)*WORDSIZE)))

    // t1 and t4 should already hold previous W values
 && (i < 64 ==> t1 == AddrMemContents(mem, sp + CheapMod16(i+1)*WORDSIZE))
 && t4 == AddrMemContents(mem, sp + CheapMod16(i+14)*WORDSIZE)
}

#endverbatim

procedure {:refined} Body_16_XXWrap(
    inline i:SHA_step,
    inline perm:perm_index,
    inline input_slot:word,
    inline input_slot_9:word,
    ghost orig_mem:memmap,
    ghost orig_trace:SHA256Trace,
    ghost trace_in:SHA256Trace,
    ghost input:seq(word),
    inout operand t0:word,
    inout operand t1:word,
    inout operand t2:word,
    inout operand t3:word,
    inout operand t4:word,
    //inout operand inp:word,
    inout operand a:word,
          operand b:word,
          operand c:word,
    inout operand d:word,
          operand e:word,
          operand f:word,
          operand g:word,
    inout operand h:word)
    returns (ghost trace_out:SHA256Trace)
    reads
        sp; globals;
    modifies
        mem; lr;
    requires {:refined false}
        !interrupts_enabled(this);
        @t0 == OReg(R0);
        @t1 == OReg(R2);
        @t2 == OReg(GetReg(if Even(i) then 12 else 3));
        @t3 == OReg(GetReg(if Even(i) then  3 else 12));
        @t4 == OReg(R1);
        //@inp == OReg(R1);
        @a  == OReg(GetReg(4+ApplyPerm(0, perm)));
        @b  == OReg(GetReg(4+ApplyPerm(1, perm)));
        @c  == OReg(GetReg(4+ApplyPerm(2, perm)));
        @d  == OReg(GetReg(4+ApplyPerm(3, perm)));
        @e  == OReg(GetReg(4+ApplyPerm(4, perm)));
        @f  == OReg(GetReg(4+ApplyPerm(5, perm)));
        @g  == OReg(GetReg(4+ApplyPerm(6, perm)));
        @h  == OReg(GetReg(4+ApplyPerm(7, perm)));
    requires
        input_slot == CheapMod16(i)*WORDSIZE;
        input_slot_9 == CheapMod16(i+9)*WORDSIZE;
    requires Body_16_XXLoopStateInvariantBreakdown(orig_mem, mem, orig_trace, trace_in, i, sp, globals, lr,
                                                   t1, t2, t3, t4, input,
                                                   a, b, c, d, e, f, g, h);
    ensures  Body_16_XXLoopStateInvariantBreakdown(orig_mem, mem, orig_trace, trace_out, i + 1, sp, globals, lr,
                                                   t1, t3, t2, t4, input,
                                                   h, a, b, c, d, e, f, g);
{
    reveal Body_16_XXLoopStateInvariantBreakdown;

    Body_16_XX(i, perm, input_slot, input_slot_9, trace_in, input,
        t0, t1, t2, t3, t4, a, b, c, d, e, f, g, h);

    exists trace_out_tmp:SHA256Trace ::
            IsSHA256TraceReadyForStep(trace_out_tmp, i+1)
         && trace_out_tmp.M == trace_in.M
         && trace_out_tmp.H == trace_in.H
         && trace_out_tmp.W == trace_in.W
         && t1 == (if i + 1 <= 64 then AddrMemContents(mem, sp + CheapMod16(i + 2)*WORDSIZE) else t1)
         && (i + 1 < 64 ==> (forall j :: i+1 - 16 <= j < i+1 ==> last(trace_out_tmp.W)[j] == AddrMemContents(mem, sp + CheapMod16(j)*WORDSIZE)))
         && last(last(trace_out_tmp.atoh)) == atoh_c(BitwiseAdd32(h, t3), a, b, c, d, e, f, g);

    trace_out := trace_out_tmp;
    assert Body_16_XXLoopStateInvariantBreakdown(old(mem), mem, trace_in, trace_out, i + 1, sp, globals, lr,
                                                       t1, t3, t2, t4, input,
                                                       h, a, b, c, d, e, f, g);
}

procedure {:refined}{:recursive}{:timeLimitMultiplier 2} Body_16_XXUnroller(
    inline n:nat,
    inline i:int,
    inline perm:perm_index,
    inline input_slot:word,
    inline input_slot_9:word,
    ghost orig_mem:memmap,
    ghost orig_trace:SHA256Trace,
    ghost trace_in:SHA256Trace,
    ghost input:seq(word),
    inout operand t0:word,
    inout operand t1:word,
    inout operand t2:word,
    inout operand t3:word,
    inout operand t4:word,
    inout operand a:word,
    inout operand b:word,
    inout operand c:word,
    inout operand d:word,
    inout operand e:word,
    inout operand f:word,
    inout operand g:word,
    inout operand h:word)
    returns (ghost trace_out:SHA256Trace)
    reads
        sp; globals;
    modifies
        mem; lr;
    requires {:refined false}
        !interrupts_enabled(this);
        @t0 == OReg(R0);
        @t1 == OReg(R2);
        @t2 == OReg(GetReg(if Even(i) then 12 else 3));
        @t3 == OReg(GetReg(if Even(i) then  3 else 12));
        @t4 == OReg(R1);
        @a  == OReg(GetReg(4+ApplyPerm(0, perm)));
        @b  == OReg(GetReg(4+ApplyPerm(1, perm)));
        @c  == OReg(GetReg(4+ApplyPerm(2, perm)));
        @d  == OReg(GetReg(4+ApplyPerm(3, perm)));
        @e  == OReg(GetReg(4+ApplyPerm(4, perm)));
        @f  == OReg(GetReg(4+ApplyPerm(5, perm)));
        @g  == OReg(GetReg(4+ApplyPerm(6, perm)));
        @h  == OReg(GetReg(4+ApplyPerm(7, perm)));
        0 <= i <= 64;
        n == 64 - i;
    requires
        0 <= i <= 64;
        n == 64 - i;
        perm == OpaqueMod(i, 8);
        input_slot == CheapMod16(i)*WORDSIZE;
        input_slot_9 == CheapMod16(i+9)*WORDSIZE;
        Body_16_XXLoopStateInvariantBreakdown(orig_mem, mem, orig_trace, trace_in, i, sp, globals, lr,
            t1, t2, t3, t4, input, a, b, c, d, e, f, g, h);
    ensures
        let arr := seq8(a, b, c, d, e, f, g, h) in
            Body_16_XXLoopStateInvariantBreakdown(orig_mem, mem, orig_trace, trace_out, 64, sp, globals, lr,
                t1, if Even(i) then t2 else t3, if Even(i) then t3 else t2, t4, input,
                SelectPerm(arr, 0, perm), SelectPerm(arr, 1, perm), SelectPerm(arr, 2, perm), SelectPerm(arr, 3, perm),
                SelectPerm(arr, 4, perm), SelectPerm(arr, 5, perm), SelectPerm(arr, 6, perm), SelectPerm(arr, 7, perm));
{
    inline if (n > 0 && 0 <= i < 64) {
        assert OpaqueMod(i + 1, 8) == (if perm == 7 then 0 else perm + 1) by { reveal OpaqueMod; }
        trace_out := Body_16_XXWrap(i, perm, input_slot, input_slot_9, orig_mem, orig_trace, trace_in, input,
            t0, t1, t2, t3, t4, a, b, c, d, e, f, g, h);
        trace_out := Body_16_XXUnroller(n - 1, i + 1, if perm == 7 then 0 else perm + 1, CheapMod16(i + 1) * 4, CheapMod16(i + 10) * 4,
            orig_mem, orig_trace, trace_out, input,
            t0, t1, t3, t2, t4, h, a, b, c, d, e, f, g);
    } else {
        assert OpaqueMod(i, 8) == 0 by { reveal OpaqueMod; }
        trace_out := trace_in;
    }
}

procedure {:refined} Body_16_XXLoopUnrolled(
    ghost trace_in:SHA256Trace,
    ghost input:seq(word)
    )
    requires Body_16_XXLoopStateInvariantBreakdown(mem, mem, trace_in, trace_in, 16, sp, globals, lr,
                                                   r2, r12, r3, r1, input,
                                                   r4, r5, r6, r7, r8, r9, r10, r11);
    requires {:refined false} !interrupts_enabled(this);
    reads  sp; globals;
    modifies mem; lr; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12;
    ensures  exists trace_out ::
             Body_16_XXLoopStateInvariantBreakdown(old(mem), mem, trace_in, trace_out, 64, sp, globals, lr,
                                                   r2, r12, r3, r1, input,
                                                   r4, r5, r6, r7, r8, r9, r10, r11);
{
    assert OpaqueMod(16, 8) == 0 by { reveal OpaqueMod; }
    ghost var trace_out;
    ghost var orig_mem := mem;
    trace_out := Body_16_XXUnroller(48, 16, 0, CheapMod16(16) * 4, CheapMod16(16 + 9) * 4,
        orig_mem, trace_in, trace_in, input,
        r0, r2, r12, r3, r1, r4, r5, r6, r7, r8, r9, r10, r11);
}

procedure {:refined} {:timeLimitMultiplier 2} update_Hs(
    ghost base_ptr:word,
    inout operand t0:word,
    inout operand t1:word,
    inout operand t2:word,
    inout operand t3:word,
    inout operand a:word,
    inout operand b:word,
    inout operand c:word,
    inout operand d:word,
    inout operand e:word,
    inout operand f:word,
    inout operand g:word,
    inout operand h:word
    )
requires/ensures
    ValidAddrMemStateOpaque(mem);
requires
    // Stack is accessible
    ValidMemRange(sp, sp + SHA_STACKSIZE * WORDSIZE);

    base_ptr == AddrMemContents(mem, sp + 16*WORDSIZE);

    // Base_ptr doesn't alias the stack
    base_ptr + SHA_CTXSIZE*WORDSIZE < sp || base_ptr > sp + SHA_STACKSIZE*WORDSIZE;

    ValidMemRange(base_ptr, base_ptr + SHA_CTXSIZE * WORDSIZE);
requires {:refined false}   // Using this style so I can give explicit names to all the registers.  Less confusing this way.
    !interrupts_enabled(this);
    @t0 == OReg(R0);
    @t1 == OReg(R2);
    @t2 == OReg(R12);
    @t3 == OReg(R3);
    @a  == OReg(R4);
    @b  == OReg(R5);
    @c  == OReg(R6);
    @d  == OReg(R7);
    @e  == OReg(R8);
    @f  == OReg(R9);
    @g  == OReg(R10);
    @h  == OReg(R11);
reads
    sp;
modifies 
    mem; 
ensures
    // Memory framing: We only touch 8 bytes pointed to by the base_ptr
    AddrMemPreservingExcept(old(mem), mem, base_ptr, base_ptr + 8*WORDSIZE);
    AddrMemContents(mem, base_ptr +  0*WORDSIZE) == a == BitwiseAdd32(AddrMemContents(old(mem), base_ptr +  0*WORDSIZE), old(a));
    AddrMemContents(mem, base_ptr +  1*WORDSIZE) == b == BitwiseAdd32(AddrMemContents(old(mem), base_ptr +  1*WORDSIZE), old(b));
    AddrMemContents(mem, base_ptr +  2*WORDSIZE) == c == BitwiseAdd32(AddrMemContents(old(mem), base_ptr +  2*WORDSIZE), old(c));
    AddrMemContents(mem, base_ptr +  3*WORDSIZE) == d == BitwiseAdd32(AddrMemContents(old(mem), base_ptr +  3*WORDSIZE), old(d));
    AddrMemContents(mem, base_ptr +  4*WORDSIZE) == e == BitwiseAdd32(AddrMemContents(old(mem), base_ptr +  4*WORDSIZE), old(e));
    AddrMemContents(mem, base_ptr +  5*WORDSIZE) == f == BitwiseAdd32(AddrMemContents(old(mem), base_ptr +  5*WORDSIZE), old(f));
    AddrMemContents(mem, base_ptr +  6*WORDSIZE) == g == BitwiseAdd32(AddrMemContents(old(mem), base_ptr +  6*WORDSIZE), old(g));
    AddrMemContents(mem, base_ptr +  7*WORDSIZE) == h == BitwiseAdd32(AddrMemContents(old(mem), base_ptr +  7*WORDSIZE), old(h));
{
    // Load the ctx pointer that holds the Hs
    LDR(t3, sp, 64);
    assert t3 == base_ptr;
    LDR(t0, t3, 0);
    LDR(t1, t3, 4);
    LDR(t2, t3, 8);
    ADDWrap(a, a, t0);
    LDR(t0, t3, 12);
    ADDWrap(b, b, t1);
    LDR(t1, t3, 16);
    ADDWrap(c, c, t2);
    LDR(t2,t3,20);
    ADDWrap(d,d,t0);
    LDR(t0,t3,24);
    ADDWrap(e,e,t1);
    LDR(t1,t3,28);
    ADDWrap(f,f,t2);
    ADDWrap(g,g,t0);
    ADDWrap(h,h,t1);

    // TODO: OpenSSL does this in a single call to: stmia $t3,{$A,$B,$C,$D,$E,$F,$G,$H}
    STR(a, t3,  0); 
    //assert ValidMem(t3 + 4);      // OBSERVE
    STR(b, t3,  4); 
    //assert ValidMem(t3 + 8);      // OBSERVE
    STR(c, t3,  8); 
    //assert ValidMem(t3 + 12);     // OBSERVE
    STR(d, t3, 12); 
    //assert ValidMem(t3 + 16);     // OBSERVE
    STR(e, t3, 16); 
    //assert ValidMem(t3 + 20);     // OBSERVE
    STR(f, t3, 20); 
    //assert ValidMem(t3 + 24);     // OBSERVE
    STR(g, t3, 24); 
    //assert ValidMem(t3 + 28);     // OBSERVE
    STR(h, t3, 28); 

    assert {:split_here}{:refined} true;
}

procedure {:refined} {:timeLimitMultiplier 3} sha256_one_block(
    ghost base_ptr:word,
    ghost trace_in:SHA256Trace,
    ghost input:seq(word)
    )
requires/ensures
    ValidAddrMemStateOpaque(mem);

requires {:refined false}
    !interrupts_enabled(this);
requires
    // Stack is accessible
    ValidMemRange(sp, sp + SHA_STACKSIZE * WORDSIZE);

    base_ptr == AddrMemContents(mem, sp + 16*WORDSIZE);

    // Base_ptr doesn't alias the stack
    base_ptr + SHA_CTXSIZE*WORDSIZE < sp || base_ptr > sp + SHA_STACKSIZE*WORDSIZE;

    // Stack slot 16 holds a pointer to a valid region of memory with 8 words of data in it
    ValidMemRange(base_ptr, base_ptr + SHA_CTXSIZE * WORDSIZE);

    // SHA semantics
    IsCompleteSHA256Trace(trace_in);
    SHA256TraceIsCorrect(trace_in);
    
    // K table adjusted properly
    SaneShaGlobal(globals);
    lr == AddressOfGlobal(K_SHA256s());
    //ValidGlobalAddr(K_SHA256s(), lr);

    let t0 := r0 in
    let t1 := r2 in
    let t2 := r12 in
    let t3 := r3 in
    let t4 := r1 in
    let a := r4 in
    let b := r5 in
    let c := r6 in
    let d := r7 in
    let e := r8 in
    let f := r9 in
    let g := r10 in
    let h := r11 in

    let ctx := r0 in
    let input_ptr := r1 in
    let num_blocks := r2 in // Number of 64-byte blocks to process
        last(trace_in.H)[0] == AddrMemContents(mem, base_ptr + 0*WORDSIZE) == a
     && last(trace_in.H)[1] == AddrMemContents(mem, base_ptr + 1*WORDSIZE) == b
     && last(trace_in.H)[2] == AddrMemContents(mem, base_ptr + 2*WORDSIZE) == c
     && last(trace_in.H)[3] == AddrMemContents(mem, base_ptr + 3*WORDSIZE) == d
     && last(trace_in.H)[4] == AddrMemContents(mem, base_ptr + 4*WORDSIZE) == e
     && last(trace_in.H)[5] == AddrMemContents(mem, base_ptr + 5*WORDSIZE) == f
     && last(trace_in.H)[6] == AddrMemContents(mem, base_ptr + 6*WORDSIZE) == g
     && last(trace_in.H)[7] == AddrMemContents(mem, base_ptr + 7*WORDSIZE) == h

     // Ghost input matches in-memory input
     && SeqLength(input) == SHA_BLOCKSIZE
     && isUInt32(input_ptr + SHA_BLOCKSIZE*WORDSIZE)
     && (input_ptr + SHA_BLOCKSIZE*WORDSIZE < sp || sp + SHA_STACKSIZE*WORDSIZE <= input_ptr)    // input_ptr doesn't alias the stack
     && ValidMemRange(input_ptr, input_ptr + SHA_BLOCKSIZE * WORDSIZE)
     && (forall j :: 0 <= j < SHA_BLOCKSIZE ==> AddrMemContents(mem, input_ptr + j*WORDSIZE) == input[j])
     ;
reads
    sp; globals;
modifies
    mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr;
ensures
    // Memory framing: We only touch the stack and 8 bytes pointed to by the base_ptr
    AddrMemPreservingExcept2(old(mem), mem, sp, sp + SHA_STACKSIZE * WORDSIZE, base_ptr,
                            base_ptr + SHA_CTXSIZE * WORDSIZE);

    lr == AddressOfGlobal(K_SHA256s()) + 256;

    AddrMemContents(mem, sp + 16*WORDSIZE) == AddrMemContents(old(mem), sp + 16*WORDSIZE);
    AddrMemContents(mem, sp + 17*WORDSIZE) == old(r1) + 64;
    AddrMemContents(mem, sp + 18*WORDSIZE) == AddrMemContents(old(mem), sp + 18*WORDSIZE);

    exists trace_out:SHA256Trace ::
           IsCompleteSHA256Trace(trace_out)
        && SHA256TraceIsCorrect(trace_out)
        && trace_out.M == trace_in.M + seq(bswap32_seq(input))
        && ValidAddrMemStateOpaque(mem)
        && AddrMemContents(mem, base_ptr + 0*WORDSIZE) ==  r4 == last(trace_out.H)[0]
        && AddrMemContents(mem, base_ptr + 1*WORDSIZE) ==  r5 == last(trace_out.H)[1]
        && AddrMemContents(mem, base_ptr + 2*WORDSIZE) ==  r6 == last(trace_out.H)[2]
        && AddrMemContents(mem, base_ptr + 3*WORDSIZE) ==  r7 == last(trace_out.H)[3]
        && AddrMemContents(mem, base_ptr + 4*WORDSIZE) ==  r8 == last(trace_out.H)[4]
        && AddrMemContents(mem, base_ptr + 5*WORDSIZE) ==  r9 == last(trace_out.H)[5]
        && AddrMemContents(mem, base_ptr + 6*WORDSIZE) == r10 == last(trace_out.H)[6]
        && AddrMemContents(mem, base_ptr + 7*WORDSIZE) == r11 == last(trace_out.H)[7];
{
    // Prepare the incoming trace by incorporating the input we're about to digest
    ghost var bswapped_input := bswap32_seq(input);
    ghost var new_Ws := ComputeWs(bswapped_input);
    ghost var init_atoh := atoh_c(r4, r5, r6, r7, r8, r9, r10, r11);
    ghost var new_trace_in := lemma_SHA256DigestOneBlockHelper1(trace_in, new_Ws, init_atoh, bswapped_input);

    forall j :| 0 <= j < 16 :: last(new_trace_in.W)[j] == bswap32(input[j])
        { assert TStep(j); }
    assert IsSHA256TraceReadyForStep(new_trace_in, 0);

    // Set up the initial conditions for BODY_00_15
    assert ValidMem(r1 + 0*WORDSIZE);    // OBSERVE that r1 aka t1 is a ValidAddr
    LDR(r2, r1, 0);        // t1 <- input[0]
    assert r2 == input[0];
    ADD(r1, r1, const(WORDSIZE));        // TODO: OpenSSL does this with a single LDR instruction
    EOR(r3, r5, r6);       // t3 <- B xor C  "@magic"
    //EOR(r12, r12, r12);    // Note: OpenSSL includes this unnecessarily, since for i=0, we clobber r12
    //assert r12 == 0 by { lemma_XorSelfIsZero(); }

    assert r1 /*aka t4*/ == old(r1) + 1 * 4;    // OBSERVE that t4 is a ValidAddr
    ghost var input_ptr := old(r1);      // Avoid Spartan mis-capture

    assert Body_00_15LoopStateInvariantBreakdown(mem, mem, input_ptr, new_trace_in, new_trace_in, 0, sp, globals, lr, 
                                                 r2, r12, r3, r1, input,
                                                 r4, r5, r6, r7, r8, r9, r10, r11);

    ghost var trace_00_15:SHA256Trace;
    trace_00_15 := Body_00_15LoopUnrolled(input_ptr, new_trace_in, input);

    ghost var mid_mem := mem;
    reveal Body_16_XXLoopStateInvariantBreakdown;
    Body_16_XXLoopUnrolled(trace_00_15, input);
    
    exists trace_16_XX :: 
             Body_16_XXLoopStateInvariantBreakdown(mid_mem, mem, trace_00_15, trace_16_XX, 64, sp, globals, lr,
                                                   r2, r12, r3, r1, input,
                                                   r4, r5, r6, r7, r8, r9, r10, r11);
    ADDWrap(r4, r4, r12);      // Add final Maj into a

    assert forall addr :: base_ptr <= addr < base_ptr + 8 * 4 && (addr - base_ptr) % 4 == 0 
        ==> ValidMem(addr);
    update_Hs(base_ptr, r0, r2, r12, r3, r4, r5, r6, r7, r8, r9, r10, r11);

    ghost var old_H := seq( AddrMemContents(old(mem), base_ptr +  0),
                            AddrMemContents(old(mem), base_ptr +  4),
                            AddrMemContents(old(mem), base_ptr +  8),
                            AddrMemContents(old(mem), base_ptr + 12),
                            AddrMemContents(old(mem), base_ptr + 16),
                            AddrMemContents(old(mem), base_ptr + 20),
                            AddrMemContents(old(mem), base_ptr + 24),
                            AddrMemContents(old(mem), base_ptr + 28));
    ghost var new_H := seq( AddrMemContents(mem, base_ptr +  0),
                            AddrMemContents(mem, base_ptr +  4),
                            AddrMemContents(mem, base_ptr +  8),
                            AddrMemContents(mem, base_ptr + 12),
                            AddrMemContents(mem, base_ptr + 16),
                            AddrMemContents(mem, base_ptr + 20),
                            AddrMemContents(mem, base_ptr + 24),
                            AddrMemContents(mem, base_ptr + 28));
    ghost var trace_out := lemma_SHA256DigestOneBlockHelper2(trace_16_XX, old_H, new_H);
}

procedure {:refined} sha256_loop_body(
    ghost old_trace:SHA256Trace,
    ghost ctx_ptr:word,
    ghost input_ptr:word,
    ghost input:seq(word),
    ghost num_blocks:nat,
    ghost old_M_length:nat,
    ghost old_mem:memmap,
    ghost block:nat
    )
requires block < num_blocks;
requires {:refined false}
    !interrupts_enabled(this);
requires exists trace_in ::
         BlockInvariant(trace_in, old_trace, input, globals, old_M_length, old_mem, mem, sp, lr, r1, r12,
                        r4, r5, r6, r7, r8, r9, r10, r11,
                        input_ptr, ctx_ptr, num_blocks, block);
reads
    sp; globals;
modifies
    mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr;
ensures exists trace_out ::
        BlockInvariant(trace_out, old_trace, input, globals, old_M_length, old_mem, mem, sp, lr, r1, r12,
                        r4, r5, r6, r7, r8, r9, r10, r11,
                        input_ptr, ctx_ptr, num_blocks, block+1);
{
    ghost var block_input := SeqSlice(input, block*16, (block+1)*16);

    ghost var current_input_ptr := r1;  // == input_ptr + block*16*WORDSIZE
    forall j :| 0 <= j < 16 :: ValidMem(current_input_ptr + j*WORDSIZE)
                            && AddrMemContents(mem, current_input_ptr + j*WORDSIZE) == block_input[j]
    {
        assert current_input_ptr + j*WORDSIZE == input_ptr + (block*16+j)*WORDSIZE;
        assert ValidMem(current_input_ptr + j*WORDSIZE);
    }
    ghost var prev_mem := mem;
    exists trace_in ::
         BlockInvariant(trace_in, old_trace, input, globals, old_M_length, mem, mem, sp, lr, r1, r12,
                        r4, r5, r6, r7, r8, r9, r10, r11,
                        input_ptr, ctx_ptr, num_blocks, block);
    sha256_one_block(ctx_ptr, trace_in, block_input);
    exists trace_out:SHA256Trace ::
           IsCompleteSHA256Trace(trace_out)
        && SHA256TraceIsCorrect(trace_out)
        //&& trace_out.M == SeqSlice(old_trace.M, 0, SeqLength(old_trace.M))  // old_trace.M is a prefix of trace_out.M
        && trace_out.M == trace_in.M + seq(bswap32_seq(block_input))
        && AddrMemContents(mem, ctx_ptr + 0*WORDSIZE) ==  r4 == last(trace_out.H)[0]
        && AddrMemContents(mem, ctx_ptr + 1*WORDSIZE) ==  r5 == last(trace_out.H)[1]
        && AddrMemContents(mem, ctx_ptr + 2*WORDSIZE) ==  r6 == last(trace_out.H)[2]
        && AddrMemContents(mem, ctx_ptr + 3*WORDSIZE) ==  r7 == last(trace_out.H)[3]
        && AddrMemContents(mem, ctx_ptr + 4*WORDSIZE) ==  r8 == last(trace_out.H)[4]
        && AddrMemContents(mem, ctx_ptr + 5*WORDSIZE) ==  r9 == last(trace_out.H)[5]
        && AddrMemContents(mem, ctx_ptr + 6*WORDSIZE) == r10 == last(trace_out.H)[6]
        && AddrMemContents(mem, ctx_ptr + 7*WORDSIZE) == r11 == last(trace_out.H)[7];

    LDR(r1, sp, const(17*WORDSIZE));  // Reload input_ptr
    LDR(r12, sp, const(18*WORDSIZE)); // Reload end_ptr
    SUB(lr, lr, 256); // Reset lr

    forall addr :| input_ptr <= addr < input_ptr + (num_blocks*16)*WORDSIZE && (addr - input_ptr) % 4 == 0
                :: ValidMem(addr)
    {
        assert ValidMem(addr);
    }
    assert ValidMemRange(input_ptr, input_ptr + num_blocks*16 * WORDSIZE);

    forall j :| 0 <= j < num_blocks * 16 :: AddrMemContents(mem, input_ptr + j*WORDSIZE) == input[j]
    {
        assert ValidMem(input_ptr + j*WORDSIZE);
    }

    assert trace_out.M == trace_in.M + seq(bswap32_seq(block_input));
    assert old_trace.M == SeqSlice(trace_in.M, 0, SeqLength(old_trace.M)); 
    assert old_trace.M == SeqSlice(trace_out.M, 0, SeqLength(old_trace.M)); 

    assert BlockInvariant(trace_out, old_trace, input, globals, old_M_length, old_mem, mem, sp, lr, r1, r12,
                          r4, r5, r6, r7, r8, r9, r10, r11,
                          input_ptr, ctx_ptr, num_blocks, block+1);
}


procedure {:refined} sha256_loop(
    ghost old_trace:SHA256Trace,
    ghost ctx_ptr:word,
    ghost input_ptr:word,
    ghost input:seq(word),
    ghost num_blocks:nat,
    ghost old_M_length:nat,
    ghost old_mem:memmap
    )
requires {:refined false}
    !interrupts_enabled(this);
requires exists trace_in ::
         BlockInvariant(trace_in, old_trace, input, globals, old_M_length, old_mem, mem, sp, lr, r1, r12,
                        r4, r5, r6, r7, r8, r9, r10, r11,
                        input_ptr, ctx_ptr, num_blocks, 0);
reads
    sp; globals;
modifies
    mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr;
ensures exists trace_out ::
        BlockInvariant(trace_out, old_trace, input, globals, old_M_length, old_mem, mem, sp, lr, r1, r12,
                        r4, r5, r6, r7, r8, r9, r10, r11,
                        input_ptr, ctx_ptr, num_blocks, num_blocks);
{
    ghost var block:nat := 0;
    while (r1 < r12)
        invariant
            exists trace :: 
                BlockInvariant(trace, old_trace, input, globals, old_M_length, old_mem, mem, sp, lr, r1, r12,
                               r4, r5, r6, r7, r8, r9, r10, r11,
                               input_ptr, ctx_ptr, num_blocks, block);
         decreases r12 - r1;
    {
        sha256_loop_body(old_trace, ctx_ptr, input_ptr, input, num_blocks, old_M_length, old_mem, block);
        block := block + 1;
    }
}

// Core implementation that does the real work
procedure {:refined} {:timeLimitMultiplier 2} sha256_block_data_order_inner(
    ghost trace_in:SHA256Trace,
    ghost input:seq(word)
    ) returns (
    ghost trace_out:SHA256Trace
    )

requires/ensures
    ValidAddrMemStateOpaque(mem);
requires {:refined false}
    !interrupts_enabled(this);
requires
    // Stack is accessible
    ValidMemRange(sp, sp + SHA_STACKSIZE * WORDSIZE);

    IsCompleteSHA256Trace(trace_in);
    SHA256TraceIsCorrect(trace_in);

    // K table is valid
    SaneShaGlobal(globals);
    lr == AddressOfGlobal(K_SHA256s());
    //ValidGlobalAddr(K_SHA256s(), lr);

    let ctx := r0 in
    let input_ptr := r1 in
    let num_blocks := r2 in // Number of 64-byte blocks to process

     // Old H values are laid out in memory pointed at by ctx
        ValidMemRange(ctx, ctx + SHA_CTXSIZE * WORDSIZE)
     && last(trace_in.H)[0] == AddrMemContents(mem, ctx + 0*WORDSIZE)
     && last(trace_in.H)[1] == AddrMemContents(mem, ctx + 1*WORDSIZE)
     && last(trace_in.H)[2] == AddrMemContents(mem, ctx + 2*WORDSIZE)
     && last(trace_in.H)[3] == AddrMemContents(mem, ctx + 3*WORDSIZE)
     && last(trace_in.H)[4] == AddrMemContents(mem, ctx + 4*WORDSIZE)
     && last(trace_in.H)[5] == AddrMemContents(mem, ctx + 5*WORDSIZE)
     && last(trace_in.H)[6] == AddrMemContents(mem, ctx + 6*WORDSIZE)
     && last(trace_in.H)[7] == AddrMemContents(mem, ctx + 7*WORDSIZE)

     // Ghost input matches in-memory input
     && SeqLength(input) == num_blocks * SHA_BLOCKSIZE
     && isUInt32(input_ptr + num_blocks * SHA_BLOCKSIZE * WORDSIZE)
     && ValidMemRange(input_ptr, input_ptr + num_blocks * SHA_BLOCKSIZE * WORDSIZE)
     && (forall j :: 0 <= j < num_blocks * SHA_BLOCKSIZE ==> AddrMemContents(mem, input_ptr + j*WORDSIZE) == input[j]
         )

     // Anti-aliasing
     && (ctx + SHA_CTXSIZE*WORDSIZE < input_ptr || ctx > input_ptr + num_blocks*SHA_BLOCKSIZE*WORDSIZE)    // input_ptr != ctx
     && (ctx + SHA_CTXSIZE*WORDSIZE < sp || ctx > sp + SHA_STACKSIZE*WORDSIZE)                             // ctx != sp
     && (input_ptr + num_blocks*SHA_BLOCKSIZE*WORDSIZE < sp || input_ptr >= sp + SHA_STACKSIZE*WORDSIZE);  // input_ptr != sp

reads
    sp; globals;
modifies
    mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr;
ensures
    // Memory framing:  We only touch the stack and 8 bytes pointed to by ctx_ptr
    AddrMemPreservingExcept2(old(mem), mem, sp, sp + SHA_STACKSIZE * WORDSIZE,
                             old(r0), old(r0) + SHA_CTXSIZE * WORDSIZE);

    IsCompleteSHA256Trace(trace_out);
    SHA256TraceIsCorrect(trace_out);
    SeqLength(trace_out.M) == SeqLength(trace_in.M) + old(r2);
    trace_in.M == SeqSlice(trace_out.M, 0, SeqLength(trace_in.M));  // trace_in.M is a prefix of trace_out.M
    (forall i :: 0 <= i < old(r2)
      ==> trace_out.M[SeqLength(trace_in.M) + i] == bswap32_seq(SeqSlice(input, i*16, (i+1)*16))) ;
    last(trace_out.H)[0] == AddrMemContents(mem, old(r0) + 0*WORDSIZE);
    last(trace_out.H)[1] == AddrMemContents(mem, old(r0) + 1*WORDSIZE);
    last(trace_out.H)[2] == AddrMemContents(mem, old(r0) + 2*WORDSIZE);
    last(trace_out.H)[3] == AddrMemContents(mem, old(r0) + 3*WORDSIZE);
    last(trace_out.H)[4] == AddrMemContents(mem, old(r0) + 4*WORDSIZE);
    last(trace_out.H)[5] == AddrMemContents(mem, old(r0) + 5*WORDSIZE);
    last(trace_out.H)[6] == AddrMemContents(mem, old(r0) + 6*WORDSIZE);
    last(trace_out.H)[7] == AddrMemContents(mem, old(r0) + 7*WORDSIZE);

{
    assert ValidGlobal(K_SHA256s()) by { reveal SaneShaGlobal; }
    LDRglobaladdr(lr, K_SHA256s());

    ghost var ctx_ptr := r0;
    ghost var input_ptr := r1;
    ghost var num_blocks := r2;

    ADDWrapShift(r2, r1, r2, LSLShift(6)); // r2 <- input_ptr + 64 * num_blocks
    assert r2 == r1 + 64 * num_blocks by {
        reveal TruncateWord;
        lemma_ShiftsAdd(num_blocks, 2, 4);
        lemma_LeftShift2(num_blocks);
        lemma_LeftShift4(num_blocks*4);
    }

    // Save some of the initial state away.  We'll need it later.
    STR(r0, sp, const(16*WORDSIZE));
    STR(r2, sp, const(18*WORDSIZE));
    // Move end_ptr into r12 to satisfy the BlockInvariant. 
    // Note: OpenSSL appears to avoid this by assuming num_blocks > 0
    MOV(r12, r2);  

    // Load a - h values into registers
    LDR(r4, r0, 0);
    LDR(r5, r0, const(WORDSIZE));
    LDR(r6, r0, const(2*WORDSIZE));
    LDR(r7, r0, const(3*WORDSIZE));
    LDR(r8, r0, const(4*WORDSIZE));
    LDR(r9, r0, const(5*WORDSIZE));
    LDR(r10, r0, const(6*WORDSIZE));
    LDR(r11, r0, const(7*WORDSIZE));

    // forall j :| 0 <= j < 19 :: ValidMem(sp + j*4)
    // {
    //     assert ValidMem(sp + j*4);
    // }


    forall addr :| input_ptr <= addr < input_ptr + num_blocks*SHA_BLOCKSIZE*WORDSIZE && (addr - input_ptr) % WORDSIZE == 0
        :: ValidMem(addr)
    {
        assert ValidMem(addr);
    }
    assert ValidMemRange(input_ptr, input_ptr + num_blocks * SHA_BLOCKSIZE * WORDSIZE);



    forall j :| 0 <= j < num_blocks * SHA_BLOCKSIZE :: AddrMemContents(mem, input_ptr + j*WORDSIZE) == input[j]
    {
        assert ValidMem(input_ptr + j*WORDSIZE);
    }

    // OBSERVE
    ghost var prev_mem := mem;  // Avoid Spartan mis-capture
    ghost var len_M := SeqLength(trace_in.M);   
    assert BlockInvariant(trace_in, trace_in, input, globals, len_M, prev_mem, mem, sp, lr, r1, r12,
                          r4, r5, r6, r7, r8, r9, r10, r11,
                          input_ptr, ctx_ptr, num_blocks, 0);
    sha256_loop(trace_in, ctx_ptr, input_ptr, input, num_blocks, len_M, prev_mem);
    exists trace_ret ::
        BlockInvariant(trace_ret, trace_in, input, globals, len_M, prev_mem, mem, sp, lr, r1, r12,
                        r4, r5, r6, r7, r8, r9, r10, r11,
                        input_ptr, ctx_ptr, num_blocks, num_blocks);
    //assert IsCompleteSHA256Trace(trace_ret);
    trace_out := trace_ret;
    assert {:split_here}{:refined} true;
}

/*
procedure {:refined} scrub_stack()
requires/ensures
    ValidAddrMemStateOpaque(mem);
requires {:refined false}
    !interrupts_enabled(this);
requires
    ValidMemRange(sp, sp + 29 * WORDSIZE);  // Stack is accessible
reads r0; sp;
modifies mem;
ensures
    forall addr :: ValidMem(addr) && (addr < sp || addr >= sp + 116)
                ==> AddrMemContents(old(mem), addr) == AddrMemContents(mem, addr);
{
    STR(r0, sp, 0);
    STR(r0, sp, 4);
    STR(r0, sp, 8);
    STR(r0, sp, 12);
    STR(r0, sp, 16);
    STR(r0, sp, 20);
    STR(r0, sp, 24);
    STR(r0, sp, 28);
    STR(r0, sp, 32);
    STR(r0, sp, 36);
    STR(r0, sp, 40);
    STR(r0, sp, 44);
    STR(r0, sp, 48);
    STR(r0, sp, 52);
    STR(r0, sp, 56);
    STR(r0, sp, 60);
    STR(r0, sp, 64);
    STR(r0, sp, 68);
    STR(r0, sp, 72);
    STR(r0, sp, 76);
    STR(r0, sp, 80);
    STR(r0, sp, 84);
    STR(r0, sp, 88);
    STR(r0, sp, 92);
    STR(r0, sp, 96);
    STR(r0, sp, 100);
    STR(r0, sp, 104);
    STR(r0, sp, 108);
    STR(r0, sp, 112);
}
*/

// Wrapper around the inner version that conforms to the calling convention
procedure {:refined} {:timeLimitMultiplier 3} sha256_block_data_order(
    ghost trace_in:SHA256Trace,
    ghost input:seq(word)
    ) returns (
    ghost trace_out:SHA256Trace
    )
requires/ensures
    ValidAddrMemStateOpaque(mem);
requires {:refined false}
    !interrupts_enabled(this);
requires
    IsCompleteSHA256Trace(trace_in);
    SHA256TraceIsCorrect(trace_in);

    // Stack is accessible
    sp >= 116;
    ValidMemRange(sp-116, sp);

    // K table is valid
    SaneShaGlobal(globals);
    lr == AddressOfGlobal(K_SHA256s());
    //ValidGlobalAddr(K_SHA256s(), lr);

    let ctx := r0 in
    let input_ptr := r1 in
    let num_blocks := r2 in // Number of 64-byte blocks to process

     // Old H values are laid out in memory pointed at by ctx
        ValidMemRange(ctx, ctx + SHA_CTXSIZE * WORDSIZE)
     && last(trace_in.H)[0] == AddrMemContents(mem, ctx + 0*WORDSIZE)
     && last(trace_in.H)[1] == AddrMemContents(mem, ctx + 1*WORDSIZE)
     && last(trace_in.H)[2] == AddrMemContents(mem, ctx + 2*WORDSIZE)
     && last(trace_in.H)[3] == AddrMemContents(mem, ctx + 3*WORDSIZE)
     && last(trace_in.H)[4] == AddrMemContents(mem, ctx + 4*WORDSIZE)
     && last(trace_in.H)[5] == AddrMemContents(mem, ctx + 5*WORDSIZE)
     && last(trace_in.H)[6] == AddrMemContents(mem, ctx + 6*WORDSIZE)
     && last(trace_in.H)[7] == AddrMemContents(mem, ctx + 7*WORDSIZE)

     // Ghost input matches in-memory input
     && SeqLength(input) == num_blocks * SHA_BLOCKSIZE
     && isUInt32(input_ptr + num_blocks * SHA_BLOCKSIZE * WORDSIZE)
     && ValidMemRange(input_ptr, input_ptr + num_blocks * SHA_BLOCKSIZE * WORDSIZE)
     && (forall j :: 0 <= j < num_blocks*SHA_BLOCKSIZE ==> AddrMemContents(mem, input_ptr + j*WORDSIZE) == input[j])

     // Anti-aliasing
     && (ctx + SHA_CTXSIZE*WORDSIZE < input_ptr || ctx > input_ptr + num_blocks*SHA_BLOCKSIZE*WORDSIZE)    // input_ptr != ctx
     && (ctx + SHA_CTXSIZE*WORDSIZE < sp - 116 || ctx >= sp)                              // ctx != sp
     && (input_ptr + num_blocks*SHA_BLOCKSIZE*WORDSIZE < sp - 116 || input_ptr >= sp);   // input_ptr != sp

reads
    globals;
modifies
    mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
ensures
    // Calling convention
    r4 == old(r4);
    r5 == old(r5);
    r6 == old(r6);
    r7 == old(r7);
    r8 == old(r8);
    r9 == old(r9);
    r10== old(r10);
    r11== old(r11);
    sp == old(sp);  
    lr == old(lr);

    // Memory framing:  We only touch the stack and 8 bytes pointed to by ctx_ptr
    AddrMemPreservingExcept2(old(mem), mem, sp - 116, sp, old(r0),
                            old(r0) + SHA_CTXSIZE * WORDSIZE);

    // SHA results
    IsCompleteSHA256Trace(trace_out);
    SHA256TraceIsCorrect(trace_out);
    SeqLength(trace_out.M) == SeqLength(trace_in.M) + old(r2);
    trace_in.M == SeqSlice(trace_out.M, 0, SeqLength(trace_in.M));  // trace_in.M is a prefix of trace_out.M
    (forall i :: 0 <= i < old(r2) 
      ==> trace_out.M[SeqLength(trace_in.M) + i] == bswap32_seq(SeqSlice(input, i*SHA_BLOCKSIZE, (i+1)*SHA_BLOCKSIZE)));
    last(trace_out.H)[0] == AddrMemContents(mem, old(r0) + 0*WORDSIZE);
    last(trace_out.H)[1] == AddrMemContents(mem, old(r0) + 1*WORDSIZE);
    last(trace_out.H)[2] == AddrMemContents(mem, old(r0) + 2*WORDSIZE);
    last(trace_out.H)[3] == AddrMemContents(mem, old(r0) + 3*WORDSIZE);
    last(trace_out.H)[4] == AddrMemContents(mem, old(r0) + 4*WORDSIZE);
    last(trace_out.H)[5] == AddrMemContents(mem, old(r0) + 5*WORDSIZE);
    last(trace_out.H)[6] == AddrMemContents(mem, old(r0) + 6*WORDSIZE);
    last(trace_out.H)[7] == AddrMemContents(mem, old(r0) + 7*WORDSIZE);
{
    // We need 10 slots to save/restore registers, and then the inner routine needs 19 slots for scratch space
    SUB(sp, sp, 116);

    // Save nonvolatile registers
    STR(lr,  sp, 112);
    STR(r4,  sp, 108);
    STR(r5,  sp, 104);
    STR(r6,  sp, 100);
    STR(r7,  sp, 96);
    STR(r8,  sp, 92);
    STR(r9,  sp, 88);
    STR(r10, sp, 84);
    STR(r11, sp, 80);
    STR(r12, sp, 76);

    ghost var old_mem := mem;
    assert forall j :: 0 <= j < r2*16 ==> AddrMemContents(mem, r1 + j*WORDSIZE)
            == AddrMemContents(old(mem), r1 + j*WORDSIZE) == input[j];
    trace_out := sha256_block_data_order_inner(trace_in, input);

    assert AddrMemPreservingExcept2(old_mem, mem, sp, sp + SHA_STACKSIZE * WORDSIZE,
                                    old(r0), old(r0) + SHA_CTXSIZE * WORDSIZE);

    // Restore the nonvolatile registers
    LDR(lr,  sp, 112);
    LDR(r4,  sp, 108);
    LDR(r5,  sp, 104);
    LDR(r6,  sp, 100);
    LDR(r7,  sp, 96);
    LDR(r8,  sp, 92);
    LDR(r9,  sp, 88);
    LDR(r10, sp, 84);
    LDR(r11, sp, 80);
    LDR(r12, sp, 76);

    // Restore the stack pointer
    ADD(sp, sp, 116);

    assert {:split_here} {:refined} true;
}
