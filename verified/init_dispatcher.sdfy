procedure kev_smc_init_dispatcher(
    {:register OReg(R1)} disp_page:int,
    {:register OReg(R2)} as_page:int,
    {:register OReg(R3)} entrypoint:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbClosedRefs(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        StackPreserving(old(this),this);
        tuple(pagedb, err)
            == old(smc_initDispatcher_premium(pagedb_in, disp_page, as_page, entrypoint));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    reveal_pageDbClosedRefs();
    reveal_smc_initDispatcher_premium();

    if (as_page >= sp_op_const(KEVLAR_SECURE_NPAGES())) {
        err := sp_op_const(KEV_ERR_INVALID_ADDRSPACE());
    } else {
        LDRglobaladdr(r12, PageDb());
        assert validPageNr(as_page);
        r0 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r4,as_page,r0);
        assert r4 == G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r0, PageDb(), r12, r4);

        forall :: r0 == pageDbEntryTypeVal(pagedb[as_page]) {
            reveal_pageDbEntryCorresponds();
        }

        if (r0 != sp_op_const(KEV_PAGE_ADDRSPACE())) {
            err := sp_op_const(KEV_ERR_INVALID_ADDRSPACE());
        } else {
            assert isAddrspace(pagedb, as_page);
            ghost var entry := PageDbEntryTyped(as_page,
                            Dispatcher(entrypoint, false, dispctxt(entrypoint)));
            pagedb := allocate_page(disp_page, as_page,
                                    sp_op_const(KEV_PAGE_DISPATCHER()),
                                    r12, r4, r5, err, pagedb, entry);

            if (err == sp_op_const(KEV_ERR_SUCCESS())) {
                assert pageDbCorrespondsExcluding(this.m, pagedb, disp_page);
                assert pageDbEntryCorresponds(pagedb[disp_page],
                                         extractPageDbEntry(this.m, disp_page));
                ghost var tmpstate := this;

                // update dispatcher page
                page_monvaddr_impl(r4, disp_page, r5);
                r5 := 0;
                STR(r5, r4, sp_op_const(DISPATCHER_ENTERED())); // entered = 0
                STR(r3, r4, sp_op_const(DISPATCHER_ENTRYPOINT())); // entrypoint

                forall :: pageDbCorrespondsOnly(this.m, pagedb, disp_page) {
                    reveal_pageDbDispatcherCorresponds();
                    reveal_pageContentsCorresponds();
                }
                AllButOnePagePreserving(disp_page, tmpstate, this);
                assert pageDbCorresponds(this.m, pagedb);
            } else {
                assert pagedb == pagedb_in;
                assert pageDbCorresponds(this.m, pagedb);
            }
        }
    }
}

#verbatim
function dispctxt(entrypoint:int) : DispatcherContext
{
    DispatcherContext(map[], entrypoint, encode_mode(User))
}
#endverbatim
