procedure kom_smc_init_dispatcher(
    inout {:register OReg(R1)} disp_page:int,
    {:register OReg(R2)} as_page:int,
    {:register OReg(R3)} entrypoint:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        SmcProcedureInvariant(old(this),this);
        tuple(pagedb, err)
            == old(smc_initDispatcher_premium(pagedb_in, disp_page, as_page, entrypoint));
        pageDbCorresponds(this.m, pagedb);
{
    ghost var specResult := smc_initDispatcher(pagedb_in, disp_page, as_page, entrypoint);
    pagedb := pagedb_in;
    reveal_smc_initDispatcher_premium();

    if (as_page >= sp_op_const(KOM_SECURE_NPAGES())) {
        err := sp_op_const(KOM_ERR_INVALID_ADDRSPACE());
    } else {
        LDRglobaladdr(r12, PageDb());
        assert validPageNr(as_page);
        r0 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r4,as_page,r0);
        assert r4 == G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r0, PageDb(), r12, r4);

        forall :: r0 == pageDbEntryTypeVal(pagedb[as_page]) {
            reveal_pageDbEntryCorresponds();
        }

        if (r0 != sp_op_const(KOM_PAGE_ADDRSPACE())) {
            err := sp_op_const(KOM_ERR_INVALID_ADDRSPACE());
        } else {
            assert isAddrspace(pagedb, as_page);
            ghost var entry := PageDbEntryTyped(as_page,
                            Dispatcher(entrypoint, false, initDispCtxt()));
            pagedb := allocate_page(disp_page, as_page,
                                    sp_op_const(KOM_PAGE_DISPATCHER()),
                                    r12, r4, r5, err, pagedb, entry);

            if (err == sp_op_const(KOM_ERR_SUCCESS())) {
                assert err == specErr(specResult);
                assert pagedb == specPageDb(allocatePage(pagedb_in, disp_page, as_page, Dispatcher(entrypoint, false, initDispCtxt())));
                assert pagedb == specPageDb(specResult);

                assert pageDbCorrespondsExcluding(this.m, pagedb, disp_page);
                assert pageDbEntryCorresponds(pagedb[disp_page],
                                         extractPageDbEntry(this.m, disp_page));
                ghost var tmpstate := this;

                // update dispatcher page
                page_monvaddr_impl(disp_page, disp_page, r5);
                r4 := disp_page;
                r5 := 0;
                r6 := sp_op_const(PAGESIZE());
                memset(r4,r5,r6);
                STR(entrypoint, disp_page, sp_op_const(DISPATCHER_ENTRYPOINT()));
                r5 := 0x10;
                STR(r5, disp_page, sp_op_const(DISP_CTXT_PSR()));

                ghost var pg := extractPage(this.m, old(disp_page));
                forall :: pageDbDispatcherCorresponds(old(disp_page), entry.entry, pg) {
                    reveal_pageDbDispatcherCorresponds();
                    assert disp_page == page_monvaddr(old(disp_page));
                    assert pg[disp_page + DISPATCHER_ENTRYPOINT()] == old(entrypoint);
                    assert pg[disp_page + DISP_CTXT_PSR()] == 0x10 == encode_mode(User);
                    assert forall a:addr :: addrInPage(a, old(disp_page))
                        && a != disp_page + DISPATCHER_ENTRYPOINT()
                        && a != disp_page + DISP_CTXT_PSR() ==> pg[a] == 0;
                }
                forall :: pageDbCorrespondsOnly(this.m, pagedb, old(disp_page)) {
                    reveal_pageContentsCorresponds();
                }
                AllButOnePagePreserving(old(disp_page), tmpstate, this);
                assert pageDbCorresponds(this.m, pagedb);
            } else {
                assert pagedb == pagedb_in;
                assert pageDbCorresponds(this.m, pagedb);
            }
        }
    }
}
