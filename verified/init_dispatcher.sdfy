include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"

include "ARMdecls.sdfy"
include "kom_utils.sdfy"
include "allocate_page.sdfy"
include "memset.sdfy"

procedure init_dispatcher_page(
    inout operand disp_page:reg,
    operand entrypoint:reg,
    out operand tmp:reg,
    out operand tmp2:reg)
    requires/ensures
        SaneState(this);
    requires
        @disp_page != @entrypoint && @disp_page != @tmp && @disp_page != @tmp2
            && @disp_page != OSP;
        @tmp != @entrypoint && @tmp != @tmp2 && @tmp != OSP;
        @tmp2 != @entrypoint && @tmp2 != OSP;
        validPageNr(disp_page);
    reads
        globals;
    modifies
        mem;
    ensures
        SmcProcedureInvariant(old(this), this);
        MemPreservingExcept(old(this), this, page_monvaddr(old(disp_page)),
                                 page_monvaddr(old(disp_page)) + PAGESIZE);
        pageDbDispatcherCorresponds(old(disp_page),
            Dispatcher(old(entrypoint), false, initDispCtxt()),
            extractPage(this.m, old(disp_page)));
{
    ghost var dispva := page_monvaddr(old(disp_page));
    page_monvaddr_impl(disp_page, disp_page, tmp);
    tmp := 0;
    tmp2 := const(PAGESIZE);
    memset(disp_page, tmp, tmp2);
    assert disp_page == dispva;

    assert entrypoint == old(entrypoint);
    STR(entrypoint, disp_page, const(DISPATCHER_ENTRYPOINT));

    tmp := 0x10;
    STR(tmp, disp_page, const(DISP_CTXT_PSR));

    ghost var pg := extractPage(this.m, old(disp_page));
    assert pg[dispva + DISPATCHER_ENTRYPOINT] == old(entrypoint);
    assert pg[dispva + DISP_CTXT_PSR] == 0x10 == encode_mode(User);

    assert MemPreservingExcept(old(this), this, dispva, dispva + PAGESIZE);

    assert pageDbDispatcherCorresponds(old(disp_page),
            Dispatcher(old(entrypoint), false, initDispCtxt()), pg)
    by {
        reveal pageDbDispatcherCorresponds;
        assert forall a:addr :: addrInPage(a, old(disp_page))
            && a != dispva + DISPATCHER_ENTRYPOINT
            && a != dispva + DISP_CTXT_PSR ==> pg[a] == 0;
    }
}

procedure {:frame false} kom_smc_init_dispatcher(
    inout operand disp_page:reg, // r1
    operand as_page:reg, // r2
    operand entrypoint:reg, // r3
    operand pagedb_base:addr,
    out operand err:reg,
    out operand tmp:reg,
    out operand tmp2:reg,
    ghost pagedb_in: PageDb) returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        ValidRegOperand(@disp_page) && ValidRegOperand(@as_page)
            && ValidRegOperand(@entrypoint) && ValidRegOperand(@pagedb_base)
            && ValidRegOperand(@err) && ValidRegOperand(@tmp) && ValidRegOperand(@tmp2);
        @disp_page != @as_page && @disp_page != @entrypoint && @disp_page != @err
            && @disp_page != @tmp && @disp_page != @tmp2 && @disp_page != @pagedb_base
            && @disp_page != OSP;
        @err != @as_page && @err != @entrypoint && @err != @tmp && @err != @tmp2
            && @err != @pagedb_base && @err != OSP;
        @tmp != @as_page && @tmp != @entrypoint && @tmp != @tmp2 && @tmp != @pagedb_base && @tmp != OSP;
        @tmp2 != @as_page && @tmp2 != @entrypoint && @tmp2 != @pagedb_base && @tmp2 != OSP;
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    modifies
        globals; mem;
    ensures
        SmcProcedureInvariant(old(this),this);
        tuple(pagedb, err)
            == old(smc_initDispatcher_premium(pagedb_in, disp_page, as_page, entrypoint));
        pageDbCorresponds(this.m, pagedb);
{
    ghost var specResult := smc_initDispatcher(pagedb_in, disp_page, as_page, entrypoint);
    pagedb := pagedb_in;
    reveal_smc_initDispatcher_premium();

    if (as_page >= const(KOM_SECURE_NPAGES)) {
        err := const(KOM_ERR_INVALID_ADDRSPACE);
    } else {
        assert validPageNr(as_page);
        load_page_type(as_page, pagedb_base, tmp, tmp, pagedb);

        if (tmp != const(KOM_PAGE_ADDRSPACE)) {
            err := const(KOM_ERR_INVALID_ADDRSPACE);
        } else {
            assert isAddrspace(pagedb, as_page);
            ghost var entry := PageDbEntryTyped(as_page,
                            Dispatcher(entrypoint, false, initDispCtxt()));
            pagedb := allocate_page(disp_page, as_page,
                                    const(KOM_PAGE_DISPATCHER),
                                    pagedb_base, tmp, tmp2, err, pagedb, entry);

            if (err == const(KOM_ERR_SUCCESS)) {
                assert err == specErr(specResult);
                assert pagedb
                    == specPageDb(allocatePage(pagedb_in, disp_page, as_page,
                                    Dispatcher(entrypoint, false, initDispCtxt())))
                    == specPageDb(specResult);

                assert pageDbCorrespondsExcluding(this.m, pagedb, disp_page);
                assert pageDbEntryCorresponds(pagedb[disp_page],
                                         extractPageDbEntry(this.m, disp_page));
                ghost var tmpstate := this;

                // update dispatcher page
                init_dispatcher_page(disp_page, entrypoint, tmp, tmp2);

                assert pageDbCorrespondsOnly(this.m, pagedb, old(disp_page))
                    by { reveal pageContentsCorresponds; }
                AllButOnePagePreserving(old(disp_page), tmpstate, this);
                assert pageDbCorresponds(this.m, pagedb);
            } else {
                assert pagedb == pagedb_in;
                assert pageDbCorresponds(this.m, pagedb);
            }
        }
    }
}
