include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"
include {:verbatim} "entry.i.dfy"

include "ARMdecls.sdfy"

procedure switch_to_monitor(inline oldmode:mode)
    modifies
        cpsr; lr; /* spsr_mon; */
    reads
        /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
    requires
        SaneConstants() && ValidState(this) && SaneStack(this) && SaneMem(this.m);
        priv_of_state(this) == PL1 && world_of_state(this) == Secure;
        mode_of_state(this) == oldmode;
        oldmode == Supervisor || oldmode == Abort || oldmode == Undefined;
        this.ok;
    ensures
        SaneState(this);
        //spsr_of_state(this) == spsr_of_state(old(this));
        lr == OperandContents(old(this), OLR);
{
    assert ValidPsrWord(cpsr) by { reveal_ValidSRegState(); }
    CPSID_IAF(const(encode_mode(Monitor)));
    lemma_update_psr(old(cpsr), encode_mode(Monitor), true, true);

    // inline if (oldmode == Supervisor) {
    //    MRS(lr, spsr_svc);
    // } else if (oldmode == Abort) {
    //    MRS(lr, spsr_abt);
    // } else if (oldmode == Undefined) {
    //    MRS(lr, spsr_und);
    // }
    // MSR(spsr_mon, lr);

    inline if (oldmode == Supervisor) {
       MRS(lr, lr_svc);
    } else if (oldmode == Abort) {
       MRS(lr, lr_abt);
    } else if (oldmode == Undefined) {
       MRS(lr, lr_und);
    }
}

procedure svc_exit(
    ghost pagedb_in: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    reads
        globals; r1;
    modifies
        mem; r0; r2;
    requires/ensures
        SaneState(this);
    requires
        this.conf.ex == ExSVC;
        //this.conf.scr.ns == Secure;
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        nonStoppedDispatcher(pagedb_in, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        tuple(r0, r1, pagedb) == exceptionHandled(old(this), pagedb_in, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validExceptionTransition(old(this), pagedb_in, this, pagedb, dispPg);
        MemPreservingExcept(old(this), this, page_monvaddr(dispPg),
                            page_monvaddr(dispPg) + PAGESIZE);
{
    LDRglobaladdr(r2, CurDispatcherOp());
    LDRglobal(r2, CurDispatcherOp(), r2, 0);
    assert r2 == page_monvaddr(dispPg);

    MOV(r0, 0);
    STR(r0, r2, const(DISPATCHER_ENTERED));

    ghost var dispEntry := pagedb_in[dispPg].entry.(entered := false);
    ghost var pg := extractPage(this.m, dispPg);
    ghost var oldpg := extractPage(old(this).m, dispPg);
    assert pageDbDispatcherCorresponds(dispPg, dispEntry, pg) by {
        reveal pageDbDispatcherCorresponds;
        assert pageDbDispatcherCorresponds(dispPg, pagedb_in[dispPg].entry, oldpg)
            by { reveal pageContentsCorresponds; }
        assert pg[page_monvaddr(dispPg) + DISPATCHER_ENTERED] == 0;
        assert forall a:addr :: addrInPage(a, dispPg)
            && a != page_monvaddr(dispPg) + DISPATCHER_ENTERED
            ==> pg[a] == oldpg[a];
    }

    pagedb := pagedb_in[dispPg := pagedb_in[dispPg].(entry := dispEntry)];
    assert pagedb == exPageDb(exceptionHandled(old(this), pagedb_in, dispPg));
    //exceptionHandledValidPageDb(user_state, ExSVC, old(this), pagedb_in, dispPg);
    assume validPageDb(pagedb); // TODO!!

    assert GlobalsInvariant(old(this), this);
    assert pageDbCorrespondsOnly(this.m, pagedb, dispPg)
        by { reveal pageContentsCorresponds; reveal pageDbEntryCorresponds; }
    AllButOnePagePreserving(dispPg, old(this), this);
    assert pageDbCorresponds(this.m, pagedb);

    reveal validExceptionTransition;
}

procedure svc_returning(
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    reads
        globals;
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
         spsr_mon;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
        isReturningSvc(this);
    ensures
        lr == old(lr);
        StackPreserving(old(this), this);
        NonStackMemPreserving(old(this), this);
        preEntryReturn(this, old(lr), svcHandled(old(this), pagedb, dispPg));
{
    assert svcHandled(this, pagedb, dispPg) == tuple(KOM_ERR_INVALID,0,0,0,0,0,0,0,0);

    MOV(r0, const(encode_mode(User)));
    MSR(spsr_mon, r0);

    MOV(r0, const(KOM_ERR_INVALID));
    MOV(r1, 0);
    MOV(r2, 0);
    MOV(r3, 0);
    MOV(r4, 0);
    MOV(r5, 0);
    MOV(r6, 0);
    MOV(r7, 0);
    MOV(r8, 0);
}

procedure {:frame false} svc_handler(
    ghost user_state: state,
    ghost stack_bytes: int,
    ghost pagedb0: PageDb,
    ghost pagedb1: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    reads
        globals; /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
    modifies
        mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; cpsr; lr; spsr_mon;
    requires
        SaneConstants() && ValidState(this)  && SaneStack(this) && SaneMem(this.m);
        this.ok;
        StackBytesRemaining(this, stack_bytes);
        this.conf.scr.ns == Secure;
        ValidState(user_state) && mode_of_state(user_state) == User;
        evalExceptionTaken(user_state, ExSVC, this);
        mode_of_state(this) != User;
        validPageDb(pagedb0) && validPageDb(pagedb1);
        nonStoppedDispatcher(pagedb0, dispPg);
        pagedb1 == updateUserPagesFromState(user_state, pagedb0, dispPg);
        pageDbCorresponds(this.m, pagedb1);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        KomExceptionHandlerInvariant(old(this), pagedb1, this, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    assert mode_of_state(this) == Supervisor
        by { lemma_evalExceptionTaken_Mode(user_state, ExSVC, this); }
    switch_to_monitor(Supervisor);

    if (r0 == const(KOM_SVC_EXIT)) {
        assert !isReturningSvc(old(this));
        pagedb := svc_exit(pagedb1, dispPg);
        ORR(sp, sp, 1); // report that we're done
    } else {
        assert isReturningSvc(old(this));
        pagedb := pagedb1;
        svc_returning(stack_bytes, pagedb, dispPg);
        assert preEntryReturn(this, OperandContents(old(this), OLR),
                              svcHandled(old(this), pagedb, dispPg));
    }

    assert validExceptionTransition(old(this), pagedb1, this, pagedb, dispPg)
        by { reveal validExceptionTransition; }
}

procedure {:frame false} abort_handler(
    ghost user_state: state,
    ghost ex: exception,
    ghost stack_bytes: int,
    ghost pagedb0: PageDb,
    ghost pagedb1: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    reads
        globals; /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
    modifies
        mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; cpsr; lr; spsr_mon;
    requires
        SaneConstants() && ValidState(this)  && SaneStack(this) && SaneMem(this.m);
        this.ok;
        StackBytesRemaining(this, stack_bytes);
        this.conf.scr.ns == Secure;
        ValidState(user_state) && mode_of_state(user_state) == User;
        ex == ExAbt || ex == ExUnd;
        evalExceptionTaken(user_state, ex, this);
        mode_of_state(this) != User;
        validPageDb(pagedb0) && validPageDb(pagedb1);
        nonStoppedDispatcher(pagedb0, dispPg);
        pagedb1 == updateUserPagesFromState(user_state, pagedb0, dispPg);
        pageDbCorresponds(this.m, pagedb1);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        KomExceptionHandlerInvariant(old(this), pagedb1, this, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    // switch to monitor mode
    //lemma_evalExceptionTaken_Mode(user_state, ex, this);
    assume mode_of_state(this) == Abort; // FIXME: don't know!
    switch_to_monitor(Abort);
    ghost var start := this;

    LDRglobaladdr(r2, CurDispatcherOp());
    LDRglobal(r2, CurDispatcherOp(), r2, 0);
    assert r2 == page_monvaddr(dispPg);

    r0 := const(KOM_ERR_FAULT);
    r1 := 0;

    STR(r1, r2, const(DISPATCHER_ENTERED));

    ghost var dispEntry := pagedb1[dispPg].entry.(entered := false);
    ghost var pg := extractPage(this.m, dispPg);
    ghost var oldpg := extractPage(old(this).m, dispPg);
    assert pageDbDispatcherCorresponds(dispPg, dispEntry, pg) by {
        reveal_pageDbDispatcherCorresponds();
        assert pageDbDispatcherCorresponds(dispPg, pagedb1[dispPg].entry, oldpg)
            by { reveal_pageContentsCorresponds(); }
        assert pg[page_monvaddr(dispPg) + DISPATCHER_ENTERED] == 0;
        assert forall a:addr :: addrInPage(a, dispPg)
            && a != page_monvaddr(dispPg) + DISPATCHER_ENTERED
            ==> pg[a] == oldpg[a];
    }

    pagedb := pagedb1[dispPg := pagedb1[dispPg].(entry := dispEntry)];
    assert pagedb == exPageDb(exceptionHandled(old(this), pagedb1, dispPg));
    exceptionHandledValidPageDb(user_state, ex, old(this), pagedb1, dispPg);

    assert GlobalsInvariant(old(this), this);
    assert pageDbCorrespondsOnly(this.m, pagedb, dispPg)
        by { reveal_pageContentsCorresponds(); reveal_pageDbEntryCorresponds(); }
    AllButOnePagePreserving(dispPg, start, this);
    assert pageDbCorresponds(this.m, pagedb);

    ORR(sp, sp, 1); // report that we're done

    assert validExceptionTransition(old(this), pagedb1, this, pagedb, dispPg)
        by { reveal_validExceptionTransition(); }
}
