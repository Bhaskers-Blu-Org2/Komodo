include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"
include {:verbatim} "entry.i.dfy"
include {:verbatim} "exceptions.i.dfy"

include "ARMdecls.sdfy"
include "kom_utils.sdfy"
include "sha/hmac.sdfy"

#verbatim
function cpsr_of_state(s:state): word
    requires ValidState(s)
    ensures ValidPsrWord(cpsr_of_state(s))
{ reveal_ValidSRegState(); s.sregs[cpsr] }

//const STACKSIZE_ATTEST:int := 8 + 24 + 1 + 2 * SHA_BLOCKSIZE + HMAC_KEYSIZE_WORDS + STACKSIZE_HMAC;
// workaround Dafny const-bug which results in stack overflow
const T1:int := HMAC_KEYSIZE_WORDS + STACKSIZE_HMAC;
const T2:int := 2 * SHA_BLOCKSIZE;
const T3:int := 33;
const T4:int := T1 + T2;
const STACKSIZE_ATTEST:int := T3 + T4;

#endverbatim

procedure {:frame false} {:instruction Ins(CPSID_IAF(mod))}
CPSID_IAF(operand mod:word)
    requires/ensures
        ValidState(this) && this.ok;
        SaneStack(this) && SaneMem(this.m);
    requires
        InterruptContinuationPrecondition(this);
        InterruptContinuationInvariantDef();
        @mod is OConst;
        ValidModeEncoding(mod);
        priv_of_state(this) == PL1;
        ValidModeChange'(this, decode_mode(mod));
    modifies
        cpsr;
    ensures
        !interrupts_enabled(this);
        mode_of_state(this) == decode_mode(mod);
        StackPreserving(old(this), this);
        NonStackMemPreserving(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PendingInterruptOp()));
        this.conf.ttbr0 == old(this).conf.ttbr0;
        this.conf.scr == old(this).conf.scr;
        CoreRegPreservingExcept(old(this), this, set(OSP, OLR)); // banked
        forall m :: m != mode_of_exception(old(this).conf, ExIRQ)
            && m != mode_of_exception(old(this).conf, ExFIQ)
            ==> old(this).regs[LR(m)] == this.regs[LR(m)]
              && old(this).regs[SP(m)] == this.regs[SP(m)];
{
    reveal va_eval;
    exists s' :: maybeHandleInterrupt(old(this), s') && evalIns'(CPSID_IAF(@mod), s', this);
    lemma_PrivInterruptInvariants(old(this), s');
    assert mode_of_state(s') == mode_of_state(old(this))
        && world_of_state(s') == world_of_state(old(this));
    assert ValidInstruction(s', CPSID_IAF(@mod)) && evalCPSID_IAF(s', mod, this);
    lemma_update_psr(cpsr_of_state(s'), mod, true, true);
}

procedure {:frame false} switch_to_monitor(inline oldmode:mode)
    modifies
        cpsr; lr; /* spsr_mon; */
    reads
        /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
        lr_usr; sp_usr;
    requires
        InterruptContinuationPrecondition(this);
        InterruptContinuationInvariantDef();
        SaneConstants() && ValidState(this) && SaneStack(this) && SaneMem(this.m);
        priv_of_state(this) == PL1 && world_of_state(this) == Secure;
        mode_of_state(this) == oldmode;
        oldmode == Supervisor || oldmode == Abort || oldmode == Undefined;
        this.ok;
    ensures
        SaneState(this);
        SaneStack(this);
        StackPreserving(old(this), this);
        NonStackMemPreserving(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PendingInterruptOp()));
        CoreRegPreservingExcept(old(this), this, set(OSP, OLR)); // banked
        lr_usr == old(lr_usr) && sp_usr == old(sp_usr);
        //spsr_of_state(this) == spsr_of_state(old(this));
        lr == OperandContents(old(this), OLR);
        this.conf.ttbr0 == old(this).conf.ttbr0;
        this.conf.scr == old(this).conf.scr;
{
    CPSID_IAF(const(encode_mode(Monitor)));

    // inline if (oldmode == Supervisor) {
    //    MRS(lr, spsr_svc);
    // } else if (oldmode == Abort) {
    //    MRS(lr, spsr_abt);
    // } else if (oldmode == Undefined) {
    //    MRS(lr, spsr_und);
    // }
    // MSR(spsr_mon, lr);

    inline if (oldmode == Supervisor) {
       MRS(lr, lr_svc);
    } else if (oldmode == Abort) {
       MRS(lr, lr_abt);
    } else if (oldmode == Undefined) {
       MRS(lr, lr_und);
    }
}

procedure fault_exit(
    inline ex: exception,
    ghost exstate: state,
    ghost pagedb_in: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    reads
        globals;
    modifies
        mem; r0; r1; r2;
    requires/ensures
        SaneState(this);
    requires
        ValidState(exstate);
        mode_of_state(exstate) != User && spsr_of_state(exstate).m == User;
        exstate.conf.ex == ex && set(ExSVC, ExAbt, ExUnd) ?[ex];
        r1 == OperandContents(exstate, OReg(R1));
        //this.conf.scr.ns == Secure;
        validPageDb(pagedb_in);
        SaneMem(exstate.m);
        pageDbCorresponds(exstate.m, pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        nonStoppedDispatcher(pagedb_in, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        tuple(r0, r1, pagedb) == exceptionHandled(exstate, pagedb_in, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validExceptionTransition(old(this), pagedb_in, this, pagedb, dispPg);
        MemPreservingExcept(old(this), this, page_monvaddr(dispPg),
                            page_monvaddr(dispPg) + PAGESIZE);
{
    LDRglobaladdr(r2, CurDispatcherOp());
    LDRglobal(r2, CurDispatcherOp(), r2, 0);
    assert r2 == page_monvaddr(dispPg);

    MOV(r0, 0);
    STR(r0, r2, const(DISPATCHER_ENTERED));
    inline if (ex == ExSVC) {
        assert r0 == KOM_ERR_SUCCESS;
    } else {
        MOV(r0, const(KOM_ERR_FAULT));
        MOV(r1, 0);
    }

    ghost var dispEntry := pagedb_in[dispPg].entry.(entered := false);
    ghost var pg := extractPage(this.m, dispPg);
    ghost var oldpg := extractPage(old(this).m, dispPg);
    assert pageDbDispatcherCorresponds(dispPg, dispEntry, pg) by {
        reveal pageDbDispatcherCorresponds;
        assert pageDbDispatcherCorresponds(dispPg, pagedb_in[dispPg].entry, oldpg)
            by { reveal pageContentsCorresponds; }
        assert pg[page_monvaddr(dispPg) + DISPATCHER_ENTERED] == 0;
        assert forall a:addr :: addrInPage(a, dispPg)
            && a != page_monvaddr(dispPg) + DISPATCHER_ENTERED
            ==> pg[a] == oldpg[a];
    }

    pagedb := pagedb_in[dispPg := pagedb_in[dispPg].(entry := dispEntry)];
    assert pagedb == exPageDb(exceptionHandled(exstate, pagedb_in, dispPg));
    lemma_exceptionHandled_validPageDb(exstate, pagedb_in, dispPg);

    assert GlobalsInvariant(old(this), this);
    assert pageDbCorrespondsOnly(this.m, pagedb, dispPg)
        by { reveal pageContentsCorresponds; reveal pageDbEntryCorresponds; }
    AllButOnePagePreserving(dispPg, old(this), this);
    assert pageDbCorresponds(this.m, pagedb);

    reveal validExceptionTransition;
}

procedure addrspace_va_for_page_va(
    operand page_va: reg,
    out operand as_va: reg,
    out operand tmp: reg,
    ghost pagenr:PageNr,
    ghost pagedb:PageDb)
    reads
        globals;
    requires/ensures
        SaneState(this);
    requires
        @as_va != @tmp; @as_va != OSP; @tmp != OSP;
        page_va == page_monvaddr(pagenr);
        validPageDb(pagedb) && pageDbCorresponds(this.m, pagedb);
        pagedb[pagenr] is PageDbEntryTyped;
    ensures
        as_va == page_monvaddr(pagedb[pagenr].addrspace);
{
    // compute page number
    SUB(as_va, page_va, const(KOM_DIRECTMAP_VBASE));
    LDRglobaladdr(tmp, SecurePhysBaseOp());
    LDRglobal(tmp, SecurePhysBaseOp(), tmp, 0);
    SUB(as_va, as_va, tmp);
    lemma_RightShift12(as_va);
    LSR(as_va, as_va, const(PAGEBITS));
    assert as_va == monvaddr_page(old(page_va)) == pagenr;

    // retrieve addrspace field from pagedb
    // TODO: avoid pointless double-shift
    lemma_LeftShift3(as_va);
    LSL(as_va, as_va, const(PAGEDB_ENTRY_SHIFT));
    ADD(as_va, as_va, const(PAGEDB_ENTRY_ADDRSPACE));
    assert as_va == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE;
    LDRglobaladdr(tmp, PageDb());
    LDRglobal(as_va, PageDb(), tmp, as_va);

    reveal pageDbEntryCorresponds;
    PageDbCorrespondsImpliesEntryCorresponds(this.m, pagedb, pagenr);
    extractPageDbToAbstractOne(this.m, pagenr, PAGEDB_ENTRY_ADDRSPACE);
}

procedure svc_returning_default(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; spsr_mon;
    requires/ensures
        SaneState(this);
    requires
        ValidState(exstate) && mode_of_state(exstate) != User;
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        r0 > 4;
    ensures
        let tuple := svcHandled(exstate, pagedb, dispPg) in
        let retRegs := firstOf2(tuple) in
        let pagedb' := secondOf2(tuple) in
        preEntryReturn(old(this), this, retRegs);
{
    // Fall back position
    assert firstOf2(svcHandled(exstate, pagedb, dispPg)) == tuple(KOM_ERR_INVALID,0,0,0,0,0,0,0,0);

    MOV(r0, const(encode_mode(User)));
    MSR(spsr_mon, r0);

    MOV(r0, const(KOM_ERR_INVALID));
    MOV(r1, 0);
    MOV(r2, 0);
    MOV(r3, 0);
    MOV(r4, 0);
    MOV(r5, 0);
    MOV(r6, 0);
    MOV(r7, 0);
    MOV(r8, 0);
}

procedure load_attestion_key() returns (ghost key:seq(word))
    reads
        globals; r4;
    modifies 
        mem; r2; r3; 
    requires/ensures
        SaneState(this);
        ValidMemRange(r4, r4 + SHA_CTXSIZE * WORDSIZE);
    ensures
        AddrMemPreservingExcept(old(mem), mem, r4, r4 + SHA_CTXSIZE * WORDSIZE);
        AddrMemContentsSeq(mem, r4, SHA_CTXSIZE) == key == AttestKey();
{
    assert ValidGlobal(AttestKeyOp()) by { reveal SaneShaGlobal; }
    LDRglobaladdr(r2, AttestKeyOp());

    LDRglobal(r3, AttestKeyOp(), r2, const(0 * WORDSIZE));
    STR(r3, r4, const(0 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(1 * WORDSIZE));
    STR(r3, r4, const(1 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(2 * WORDSIZE));
    STR(r3, r4, const(2 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(3 * WORDSIZE));
    STR(r3, r4, const(3 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(4 * WORDSIZE));
    STR(r3, r4, const(4 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(5 * WORDSIZE));
    STR(r3, r4, const(5 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(6 * WORDSIZE));
    STR(r3, r4, const(6 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(7 * WORDSIZE));
    STR(r3, r4, const(7 * WORDSIZE));
    //key := AttestKey();

    assert WordAligned(r4);
    WordAlignedAdd(r4, 1*WORDSIZE);
    WordAlignedAdd(r4, 2*WORDSIZE);
    WordAlignedAdd(r4, 3*WORDSIZE);
    WordAlignedAdd(r4, 4*WORDSIZE);
    WordAlignedAdd(r4, 5*WORDSIZE);
    WordAlignedAdd(r4, 6*WORDSIZE);
    WordAlignedAdd(r4, 7*WORDSIZE);

    key := 
        seq(AddrMemContents(mem, r4 + 0*WORDSIZE),
            AddrMemContents(mem, r4 + 1*WORDSIZE),
            AddrMemContents(mem, r4 + 2*WORDSIZE),
            AddrMemContents(mem, r4 + 3*WORDSIZE),
            AddrMemContents(mem, r4 + 4*WORDSIZE),
            AddrMemContents(mem, r4 + 5*WORDSIZE),
            AddrMemContents(mem, r4 + 6*WORDSIZE),
            AddrMemContents(mem, r4 + 7*WORDSIZE));
    lemma_package_hash_result(mem, r4, key);    // Ensures AddMemContentsSeq(mem, r4, SHA_CTXSIZE) == key
    assert key == GlobalFullContents(this.m, AttestKeyOp());
    assert GlobalFullContents(this.m, AttestKeyOp()) == AttestKey();
    assert {:split_here} true;
}

procedure arrange_user_regs_in_memory() returns (ghost user_words:seq(word))
    reads
        sp; r1; r2; r3; r4; r5; r6; r7; r8;
    modifies 
        mem; 
    requires/ensures
        SaneState(this);
        ValidMemRange(sp + SHA_CTXSIZE * WORDSIZE, sp + (SHA_CTXSIZE + 8) * WORDSIZE);
    ensures
        AddrMemPreservingExcept(old(mem), mem, sp + SHA_CTXSIZE * WORDSIZE, sp + (SHA_CTXSIZE + 8) * WORDSIZE);
        AddrMemContentsSeq(mem, sp + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE) == user_words;
        user_words == old(seq(r1, r2, r3, r4, r5, r6, r7, r8));
{
    user_words := seq(r1, r2, r3, r4, r5, r6, r7, r8);

    // Arrange the user words in memory after the gap for the MAC output
    STR(r1, sp, const((SHA_CTXSIZE + 0) * WORDSIZE));
    STR(r2, sp, const((SHA_CTXSIZE + 1) * WORDSIZE));
    STR(r3, sp, const((SHA_CTXSIZE + 2) * WORDSIZE));
    STR(r4, sp, const((SHA_CTXSIZE + 3) * WORDSIZE));
    STR(r5, sp, const((SHA_CTXSIZE + 4) * WORDSIZE));
    STR(r6, sp, const((SHA_CTXSIZE + 5) * WORDSIZE));
    STR(r7, sp, const((SHA_CTXSIZE + 6) * WORDSIZE));
    STR(r8, sp, const((SHA_CTXSIZE + 7) * WORDSIZE));

    assert WordAligned(sp);
    WordAlignedAdd(sp, (SHA_CTXSIZE + 0) * WORDSIZE);
    WordAlignedAdd(sp, (SHA_CTXSIZE + 1) * WORDSIZE);
    WordAlignedAdd(sp, (SHA_CTXSIZE + 2) * WORDSIZE);
    WordAlignedAdd(sp, (SHA_CTXSIZE + 3) * WORDSIZE);
    WordAlignedAdd(sp, (SHA_CTXSIZE + 4) * WORDSIZE);
    WordAlignedAdd(sp, (SHA_CTXSIZE + 5) * WORDSIZE);
    WordAlignedAdd(sp, (SHA_CTXSIZE + 6) * WORDSIZE);
    WordAlignedAdd(sp, (SHA_CTXSIZE + 7) * WORDSIZE);

    lemma_package_hash_result(mem, sp + SHA_CTXSIZE * WORDSIZE, user_words);    
}

procedure arrange_real_measurement_in_memory(
    ghost pagedb: PageDb,
    ghost dispPg: PageNr
    ) returns (ghost measurement:seq(word))
    reads
        globals; sp; r1; 
    modifies 
        mem; r2; r3; r4; r10; r11; r12;
    requires/ensures
        SaneState(this);
        ValidMemRange(r1, r1 + SHA_CTXSIZE * WORDSIZE);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        nonStoppedDispatcher(pagedb, dispPg);

//        r11 == page_monvaddr(pagedb[dispPg].addrspace);
//        sp <= r1 && r1 + SHA_CTXSIZE * WORDSIZE <= StackLimit();           
//        dst + size <= src || src + size <= dst;
        sp <= r1 && r1 + SHA_CTXSIZE * WORDSIZE <= StackBase();           
//        dst >= StackBase() || dst + size <= StackLimit();
        // no writing to insecure mem
        r1 >= KOM_DIRECTMAP_VBASE + MonitorPhysBase() || r1 + SHA_CTXSIZE * WORDSIZE <= KOM_DIRECTMAP_VBASE;

    ensures
        AddrMemPreservingExcept(old(mem), mem, r1, r1 + SHA_CTXSIZE * WORDSIZE);
        AddrMemContentsSeq(mem, r1, SHA_CTXSIZE) == measurement;
        validAddrspacePage(pagedb, pagedb[dispPg].addrspace);
        let addrsp_pg := pagedb[dispPg].addrspace in
        let addrsp := pagedb[addrsp_pg].entry in
            measurement == SHA256(WordSeqToBytes(addrsp.measurement));
{
    LDRglobaladdr(r10, CurDispatcherOp());
    LDRglobal(r10, CurDispatcherOp(), r10, 0);
    assert r10 == page_monvaddr(dispPg);
    // Use r10 to grab DISP_CTXT_USER_WORDS

    addrspace_va_for_page_va(r10, r11, r12, dispPg, pagedb);
    // Use r11 to grab ADDRSPACE_HASH 
 
    assert WordAligned(r11);
    ghost var offset := r11 + ADDRSPACE_HASH;
    WordAlignedAdd(r11, ADDRSPACE_HASH);
    assert WordAligned(offset);
    WordAlignedAdd(offset, 1*WORDSIZE);
    WordAlignedAdd(offset, 2*WORDSIZE);
    WordAlignedAdd(offset, 3*WORDSIZE);
    WordAlignedAdd(offset, 4*WORDSIZE);
    WordAlignedAdd(offset, 5*WORDSIZE);
    WordAlignedAdd(offset, 6*WORDSIZE);
    WordAlignedAdd(offset, 7*WORDSIZE);

    measurement := 
        seq(AddrMemContents(mem, offset + 0*WORDSIZE),
            AddrMemContents(mem, offset + 1*WORDSIZE),
            AddrMemContents(mem, offset + 2*WORDSIZE),
            AddrMemContents(mem, offset + 3*WORDSIZE),
            AddrMemContents(mem, offset + 4*WORDSIZE),
            AddrMemContents(mem, offset + 5*WORDSIZE),
            AddrMemContents(mem, offset + 6*WORDSIZE),
            AddrMemContents(mem, offset + 7*WORDSIZE));
    lemma_package_hash_result(mem, offset, measurement);    
    assert AddrMemContentsSeq(mem, offset, SHA_CTXSIZE) == measurement;

    // Arrange the enclave measurement 
    ADD(r2, r11, const(ADDRSPACE_HASH));  // Construct a pointer to enclave measurement hash 
    MOV(r3, const(SHA_CTXSIZE * WORDSIZE));         // Size arg to memcpy
    memcpy_bare(r1, r2, r3, r4);
    
    lemma_memset_result(old(this.m), this.m, offset, r1, SHA_CTXSIZE);
    assert AddrMemContentsSeq(mem, r1, SHA_CTXSIZE) == measurement;
    ghost var addrsp_pg := pagedb[dispPg].addrspace;
    assert validAddrspacePage(pagedb, addrsp_pg) by { reveal_validPageDb(); }
    ghost var addrsp := pagedb[addrsp_pg].entry;

    assert measurement == SHA256(WordSeqToBytes(addrsp.measurement)) by {
        assert addrsp.state is FinalState by {
            assume nonStoppedDispatcher(pagedb, dispPg) ==> addrsp.state is FinalState;  // TODO: ab: Remove me!
        }
        assert pageDbCorresponds(this.m, pagedb) by {
           lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb);
        }
        assert validPageNr(addrsp_pg);
        ghost var page := extractPage(this.m, addrsp_pg);
        assert pageContentsCorresponds(addrsp_pg, pagedb[addrsp_pg], page);
        reveal pageContentsCorresponds;
        assert pageDbAddrspaceCorresponds(addrsp_pg, addrsp, page);
        reveal pageDbAddrspaceCorresponds;


        ghost var base := page_monvaddr(addrsp_pg);
        assert base == r11;
        assert memContainsPage(page, addrsp_pg);
        assert page?[base]; 

//        calc {
//          base;
//          page_paddr(addrsp_pg) + KOM_DIRECTMAP_VBASE;
//        <
//          SecurePhysBase() + KOM_SECURE_RESERVE + KOM_DIRECTMAP_VBASE;
//        <=
//          KOM_PHYSMEM_LIMIT - KOM_SECURE_RESERVE + KOM_SECURE_RESERVE + KOM_DIRECTMAP_VBASE;
//          KOM_PHYSMEM_LIMIT + KOM_DIRECTMAP_VBASE;
//          0x4000_0000 + 0x8000_0000;
//          0xc000_0000;
//        }
        
        assert {:split_here} true;

        assert WordAligned(base + ADDRSPACE_HASH + 0 * WORDSIZE); 
        assert addrInPage(base + ADDRSPACE_HASH + 0*WORDSIZE, addrsp_pg);       // OBSERVE
        assert addrInPage(base + ADDRSPACE_HASH + 1*WORDSIZE, addrsp_pg);       // OBSERVE
        assert addrInPage(base + ADDRSPACE_HASH + 2*WORDSIZE, addrsp_pg);       // OBSERVE
        assert addrInPage(base + ADDRSPACE_HASH + 3*WORDSIZE, addrsp_pg);       // OBSERVE
        assert addrInPage(base + ADDRSPACE_HASH + 4*WORDSIZE, addrsp_pg);       // OBSERVE
        assert addrInPage(base + ADDRSPACE_HASH + 5*WORDSIZE, addrsp_pg);       // OBSERVE
        assert addrInPage(base + ADDRSPACE_HASH + 6*WORDSIZE, addrsp_pg);       // OBSERVE
        assert addrInPage(base + ADDRSPACE_HASH + 7*WORDSIZE, addrsp_pg);       // OBSERVE

        ghost var addr_space_hash := seq(page[base + ADDRSPACE_HASH + 0*WORDSIZE],
                                         page[base + ADDRSPACE_HASH + 1*WORDSIZE],
                                         page[base + ADDRSPACE_HASH + 2*WORDSIZE],
                                         page[base + ADDRSPACE_HASH + 3*WORDSIZE],
                                         page[base + ADDRSPACE_HASH + 4*WORDSIZE],
                                         page[base + ADDRSPACE_HASH + 5*WORDSIZE],
                                         page[base + ADDRSPACE_HASH + 6*WORDSIZE],
                                         page[base + ADDRSPACE_HASH + 7*WORDSIZE]);
        assert addr_space_hash == SHA256(WordSeqToBytes(addrsp.measurement));
        assert addr_space_hash == measurement;
    }
    assert {:split_here} true;
}

#verbatim

lemma lemma_SeqRepeat8()
    ensures SeqRepeat(8, 0) == [0, 0, 0, 0, 0, 0, 0, 0];
{
}

#endverbatim

procedure zero_pad_memory() 
    reads
        r1;
    modifies 
        mem; r2; 
    requires/ensures
        SaneState(this);
        ValidMemRange(r1, r1 + SHA_CTXSIZE * WORDSIZE);
    ensures
        AddrMemPreservingExcept(old(mem), mem, r1, r1 + SHA_CTXSIZE * WORDSIZE);
        AddrMemContentsSeq(mem, r1, SHA_CTXSIZE) == SeqRepeat(8, 0);
{
    MOV(r2, 0);
    STR(r2, r1, const(0 * WORDSIZE));
    STR(r2, r1, const(1 * WORDSIZE));
    STR(r2, r1, const(2 * WORDSIZE));
    STR(r2, r1, const(3 * WORDSIZE));
    STR(r2, r1, const(4 * WORDSIZE));
    STR(r2, r1, const(5 * WORDSIZE));
    STR(r2, r1, const(6 * WORDSIZE));
    STR(r2, r1, const(7 * WORDSIZE));
    
    ghost var zeroes := seq(0, 0, 0, 0, 0, 0, 0, 0);
    lemma_package_hash_result(mem, r1, zeroes);    
    lemma_SeqRepeat8();
}

procedure load_memory_into_regs(ghost contents:seq(word))
    reads
        mem; r0;
    modifies 
         r1; r2; r3; r4; r5; r6; r7; r8; 
    requires/ensures
        SaneState(this);
    requires
        ValidMemRange(r0, r0 + SHA_CTXSIZE * WORDSIZE);
        SeqLength(contents) == 8;
        AddrMemContentsSeq(mem, r0, SHA_CTXSIZE) == contents;
    ensures
        r1 == contents[0];
        r2 == contents[1];
        r3 == contents[2];
        r4 == contents[3];
        r5 == contents[4];
        r6 == contents[5];
        r7 == contents[6];
        r8 == contents[7];
{
    assert WordAligned(r0);
    WordAlignedAdd(r0, 1*WORDSIZE);
    WordAlignedAdd(r0, 2*WORDSIZE);
    WordAlignedAdd(r0, 3*WORDSIZE);
    WordAlignedAdd(r0, 4*WORDSIZE);
    WordAlignedAdd(r0, 5*WORDSIZE);
    WordAlignedAdd(r0, 6*WORDSIZE);
    WordAlignedAdd(r0, 7*WORDSIZE);

    LDR(r1, r0, const(0 * WORDSIZE));
    LDR(r2, r0, const(1 * WORDSIZE));
    LDR(r3, r0, const(2 * WORDSIZE));
    LDR(r4, r0, const(3 * WORDSIZE));
    LDR(r5, r0, const(4 * WORDSIZE));
    LDR(r6, r0, const(5 * WORDSIZE));
    LDR(r7, r0, const(6 * WORDSIZE));
    LDR(r8, r0, const(7 * WORDSIZE));
}

#verbatim

lemma lemma_arrange_attestation_input_helper(
        user_words_mem:memmap,
        measurement_mem:memmap,
        mem:memmap,
        base:nat,
        user_words:seq<word>,
        measurement:seq<word>)
    requires ValidMemRange(base, base + 3 * SHA_CTXSIZE * WORDSIZE);
    requires ValidAddrMemStateOpaque(user_words_mem)
          && ValidAddrMemStateOpaque(measurement_mem)
          && ValidAddrMemStateOpaque(mem);
//    requires ValidMemRange(base, base + SHA_CTXSIZE * WORDSIZE);
//    requires ValidMemRange(base + SHA_CTXSIZE * WORDSIZE, base + 2 * SHA_CTXSIZE * WORDSIZE);
//    requires ValidMemRange(base + 2 * SHA_CTXSIZE * WORDSIZE, base + 3 * SHA_CTXSIZE * WORDSIZE);

    requires user_words      == AddrMemContentsSeq(user_words_mem,  base,                              SHA_CTXSIZE);
    requires measurement     == AddrMemContentsSeq(measurement_mem, base + SHA_CTXSIZE * WORDSIZE,     SHA_CTXSIZE);
    requires SeqRepeat(8, 0) == AddrMemContentsSeq(mem,             base + 2 * SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);

    requires AddrMemPreservingExcept(user_words_mem, measurement_mem, 
                                     base +     SHA_CTXSIZE * WORDSIZE, 
                                     base + 2 * SHA_CTXSIZE * WORDSIZE)
    requires AddrMemPreservingExcept(measurement_mem, mem,
                                     base + 2 * SHA_CTXSIZE * WORDSIZE, 
                                     base + 3 * SHA_CTXSIZE * WORDSIZE)
    ensures AddrMemContentsSeq(mem, base, 3 * SHA_CTXSIZE) == user_words + measurement + SeqRepeat(8, 0);
{
    calc {
        true;
        ValidMemRange(base, base + 3 * SHA_CTXSIZE * WORDSIZE);
            { lemma_ValidMemRange_reduced(base, 3 * SHA_CTXSIZE, 2 * SHA_CTXSIZE); }
        ValidMemRange(base, base + SHA_CTXSIZE * WORDSIZE);
    }
    
    calc {
        true;
        ValidMemRange(base, base + 3 * SHA_CTXSIZE * WORDSIZE);
            { lemma_ValidMemRange_offset(base, 3 * SHA_CTXSIZE, SHA_CTXSIZE); }
        ValidMemRange(base + SHA_CTXSIZE * WORDSIZE, base + 2 * SHA_CTXSIZE * WORDSIZE);
    }
    
    calc {
        true;
        ValidMemRange(base, base + 3 * SHA_CTXSIZE * WORDSIZE);
            { lemma_ValidMemRange_offset(base, 3 * SHA_CTXSIZE, 2 * SHA_CTXSIZE); }
        ValidMemRange(base + 2 * SHA_CTXSIZE * WORDSIZE, base + 3 * SHA_CTXSIZE * WORDSIZE);
    }

    // Propagate memory contents to latest version of memory
    calc {
        user_words;
        AddrMemContentsSeq(user_words_mem, base, SHA_CTXSIZE);
            { lemma_AddrMemContentsSeq_framing1(user_words_mem, measurement_mem, 
                                     base, SHA_CTXSIZE, 
                                     base +     SHA_CTXSIZE * WORDSIZE, 
                                     base + 2 * SHA_CTXSIZE * WORDSIZE); }
        AddrMemContentsSeq(measurement_mem, base, SHA_CTXSIZE);
            { lemma_AddrMemContentsSeq_framing1(measurement_mem, mem,
                                     base, SHA_CTXSIZE, 
                                     base + 2 * SHA_CTXSIZE * WORDSIZE, 
                                     base + 3 * SHA_CTXSIZE * WORDSIZE); }
        AddrMemContentsSeq(mem, base, SHA_CTXSIZE);
    }

    calc {
        measurement;
        AddrMemContentsSeq(measurement_mem, base + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);
            { lemma_AddrMemContentsSeq_framing1(measurement_mem, mem, 
                                                base + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE,
                                                base + 2 * SHA_CTXSIZE * WORDSIZE, 
                                                base + 3 * SHA_CTXSIZE * WORDSIZE);
            }
        AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);
    }


    calc {
        AddrMemContentsSeq(mem, base, 3 * SHA_CTXSIZE);
            { lemma_AddrMemContentsSeq_adds(mem, base, 3 * SHA_CTXSIZE, SHA_CTXSIZE); }
        AddrMemContentsSeq(mem, base, SHA_CTXSIZE) 
      + AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE, 2 * SHA_CTXSIZE);
        user_words + AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE, 2 * SHA_CTXSIZE);
            { lemma_AddrMemContentsSeq_adds(mem, base + SHA_CTXSIZE * WORDSIZE, 2 * SHA_CTXSIZE, SHA_CTXSIZE); }
        user_words 
      + AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE) 
      + AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);

        user_words 
      + AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE) 
      + AddrMemContentsSeq(mem, base + 2 * SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);

        user_words 
      + measurement
      + AddrMemContentsSeq(mem, base + 2 * SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);

        user_words 
      + measurement
      + SeqRepeat(8, 0);
    }
}

        

#endverbatim

procedure{:timeLimitMultiplier 2} arrange_attestation_input(
    ghost pagedb: PageDb,
    ghost dispPg: PageNr
    ) returns (
    ghost user_words:seq(word),
    ghost measurement:seq(word)
    )
    reads
        globals; sp; r5; r6; r7; r8;
    modifies
        mem; r1; r2; r3; r4; r10; r11; r12;
    requires/ensures
        SaneState(this);
        ValidMemRange(sp + SHA_CTXSIZE * WORDSIZE, sp + (SHA_CTXSIZE + 3 * SHA_CTXSIZE) * WORDSIZE);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        nonStoppedDispatcher(pagedb, dispPg);

        //r11 == page_monvaddr(pagedb[dispPg].addrspace);
        StackLimit() <= sp && sp + (SHA_CTXSIZE + 3 * SHA_CTXSIZE) * WORDSIZE <= StackBase();           
    ensures
        AddrMemPreservingExcept(old(mem), mem, sp + SHA_CTXSIZE * WORDSIZE, sp + (SHA_CTXSIZE + 3 * SHA_CTXSIZE) * WORDSIZE);
        validAddrspacePage(pagedb, pagedb[dispPg].addrspace);
        user_words == old(seq(r1, r2, r3, r4, r5, r6, r7, r8));
        let addrsp_pg := pagedb[dispPg].addrspace in
        let addrsp := pagedb[addrsp_pg].entry in
            measurement == SHA256(WordSeqToBytes(addrsp.measurement));
        AddrMemContentsSeq(mem, sp + SHA_CTXSIZE * WORDSIZE, 3 * SHA_CTXSIZE) == 
            user_words + measurement + SeqRepeat(8, 0);
        r1 == sp + 3*SHA_CTXSIZE * WORDSIZE; 
{
    ghost var offset_sp := sp + SHA_CTXSIZE * WORDSIZE;

    // Arrange the user words in memory after the gap for the MAC output
    user_words := arrange_user_regs_in_memory();
    ghost var user_words_mem;
    user_words_mem := mem;
//    assert user_words == AddrMemContentsSeq(mem, offset_sp, SHA_CTXSIZE);
    lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb);

    // Arrange the enclave measurement 
    ADD(r1, sp, const((SHA_CTXSIZE + 8) * WORDSIZE)); // Construct a pointer for the next slot on the stack

//    LDRglobaladdr(r10, CurDispatcherOp());
//    LDRglobal(r10, CurDispatcherOp(), r10, 0);
//    assert r10 == page_monvaddr(dispPg);
//    // Use r10 to grab DISP_CTXT_USER_WORDS
//
//    addrspace_va_for_page_va(r10, r11, r12, dispPg, pagedb);
//    // Use r11 to grab ADDRSPACE_HASH 

    measurement := arrange_real_measurement_in_memory(pagedb, dispPg);
    ghost var measurement_mem;
    measurement_mem := mem;
//    // Re-establish user_words in mem
//    assert user_words == AddrMemContentsSeq(mem, offset_sp, SHA_CTXSIZE) by {
//        lemma_AddrMemContentsSeq_framing1(user_words_mem, mem, offset_sp, SHA_CTXSIZE, r1, r1 + SHA_CTXSIZE * WORDSIZE);
//    }

    // Fill in some zeroes
    ADD(r1, r1, const(SHA_CTXSIZE * WORDSIZE)); // Construct a pointer for the next slot on the stack
    zero_pad_memory();
    
//    // Re-establish user_words in mem
//    assert user_words == AddrMemContentsSeq(mem, offset_sp, SHA_CTXSIZE) by {
//        lemma_AddrMemContentsSeq_framing1(measurement_mem, mem, offset_sp, SHA_CTXSIZE, r1, r1 + SHA_CTXSIZE * WORDSIZE);
//    }

    calc {
        AddrMemContentsSeq(mem, offset_sp, 3 * SHA_CTXSIZE);
//            { lemma_AddrMemContentsSeq_adds(mem, offset_sp, 3 * SHA_CTXSIZE, SHA_CTXSIZE); }
//        AddrMemContentsSeq(mem, offset_sp, SHA_CTXSIZE) 
//      + AddrMemContentsSeq(mem, offset_sp + SHA_CTXSIZE * WORDSIZE, 2 * SHA_CTXSIZE);
//        user_words + AddrMemContentsSeq(mem, offset_sp + SHA_CTXSIZE * WORDSIZE, 2 * SHA_CTXSIZE);
//            { lemma_AddrMemContentsSeq_adds(mem, offset_sp + SHA_CTXSIZE * WORDSIZE, 2 * SHA_CTXSIZE, SHA_CTXSIZE); }
//        user_words 
//      + AddrMemContentsSeq(mem, offset_sp + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE) 
//      + AddrMemContentsSeq(mem, offset_sp + SHA_CTXSIZE * WORDSIZE + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);
//
//        user_words 
//      + AddrMemContentsSeq(mem, offset_sp + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE) 
//      + AddrMemContentsSeq(mem, offset_sp + 2 * SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);
//            { 
//                lemma_AddrMemContentsSeq_framing1(measurement_mem, mem, 
//                                                  offset_sp + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE,
//                                                  offset_sp + 2 * SHA_CTXSIZE * WORDSIZE, 
//                                                  offset_sp + 3 * SHA_CTXSIZE * WORDSIZE);
//                assert measurement == AddrMemContentsSeq(mem, offset_sp + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);
//            }
//        user_words 
//      + measurement
//      + AddrMemContentsSeq(mem, offset_sp + 2 * SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);
            { lemma_arrange_attestation_input_helper(user_words_mem, measurement_mem, mem,  
                                                     offset_sp, user_words, measurement); }

        user_words 
      + measurement
      + SeqRepeat(8, 0);
    }
    assert {:split_here} true;
}

#verbatim

lemma lemma_SaneState_implies_SaneShaGlobal(s:state)
    requires SaneState(s);
    ensures  SaneShaGlobal(va_get_globals(s));
{
    var globals := va_get_globals(s);
    reveal_SaneShaGlobal(); 
    assert ValidGlobalStateOpaque(globals) by {
        reveal_ValidGlobalStateOpaque(); 
        assert ValidGlobalState(globals) by {
            reveal_ValidMemState();   // Which we get from ValidState
        }
    }
    // TODO: ab
assume false;
    assert  ValidGlobalStateOpaque(globals)
 && ValidGlobal(K_SHA256s())
 && SizeOfGlobal(K_SHA256s()) == K_SHA256_BYTES
 && isUInt32(AddressOfGlobal(K_SHA256s()) + K_SHA256_BYTES) // We won't wrap around while accessing K_SHA256s
 && (forall j :: 0 <= j < K_SHA256_WORDS ==> GlobalContents(globals, K_SHA256s(), AddressOfGlobal(K_SHA256s()) + j * WORDSIZE) == K_SHA256(j));

}

#endverbatim

procedure {:timeLimitMultiplier 2} compute_hmac(
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr,
    ghost input:seq(word),
    ghost old_sp:word
    ) returns (
    ghost mac:seq(word)
    )

    reads
        globals;
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
         mem;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
        ValidMemRange(old_sp - STACKSIZE_ATTEST * WORDSIZE, old_sp);
    requires
        stack_bytes >= STACKSIZE_HMAC * WORDSIZE;
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
        nonStoppedDispatcher(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        r0 == KOM_SVC_ATTEST;
//        r10 == page_monvaddr(dispPg);
//        r11 == page_monvaddr(pagedb[dispPg].addrspace);

        ValidMemRange(sp + SHA_CTXSIZE * WORDSIZE, sp + 4 * SHA_CTXSIZE * WORDSIZE);
        input == AddrMemContentsSeq(mem, sp + SHA_CTXSIZE * WORDSIZE, 3 * SHA_CTXSIZE);
        r1 == sp + 3*SHA_CTXSIZE * WORDSIZE; 
        sp == old_sp - (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE;
     
        sp + (4 * SHA_CTXSIZE + 1) * WORDSIZE >= KOM_DIRECTMAP_VBASE + MonitorPhysBase() 
     || sp + (4 * SHA_CTXSIZE + 1) * WORDSIZE + 2*SHA_BLOCKSIZE*WORDSIZE <= KOM_DIRECTMAP_VBASE;

    ensures
        //AddrMemPreservingExcept(old(mem), mem, old_sp - STACKSIZE_ATTEST * WORDSIZE, old_sp);
        sp == old(sp);

        AddrMemPreservingExcept(old(mem), mem, StackLimit(), old_sp);
        ValidMemRange(sp, sp + SHA_CTXSIZE * WORDSIZE);
        mac == AddrMemContentsSeq(mem, sp, SHA_CTXSIZE);
        mac == HMAC_SHA256(AttestKey(), WordSeqToBytes(input));
{
    ghost var addrspace := pagedb[dispPg].addrspace;
    assert validAddrspacePage(pagedb, addrspace) by { reveal_validPageDb(); }

    // Stack layout [size in words]:
    //   sp := mac_output[8] || message [8+16] || gap[1] || tmp_ptr[2*SHA_BLOCKSIZE] || key_ptr[HMAC_KEYSIZE_WORDS]
    // where 
    //   message = user_words[8] || enclave_measurement [8] || 0 [8]
    // Total stack usage == 8 + 24 + 1 + 2 * SHA_BLOCKSIZE + HMAC_KEYSIZE_WORDS

    // Prove that this procedure's local stack region is valid
    ghost var STACKSIZE_LOCAL := 4 * SHA_CTXSIZE + 1 + 2 * SHA_BLOCKSIZE + HMAC_KEYSIZE_WORDS;
    calc {
        true; 
        ValidMemRange(old_sp - STACKSIZE_ATTEST * WORDSIZE, old_sp);
            { lemma_ValidMemRange_offset(old_sp - STACKSIZE_ATTEST * WORDSIZE, STACKSIZE_ATTEST, STACKSIZE_ATTEST - STACKSIZE_HMAC); }
        ValidMemRange(old_sp - (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE, old_sp);
        ValidMemRange(sp, sp + STACKSIZE_LOCAL * WORDSIZE);
    }

    // Arrange the key in memory
    ghost var key:seq(word);
    lemma_ValidMemRange_offset(sp, STACKSIZE_LOCAL, 4 * SHA_CTXSIZE + 1 + 2 * SHA_BLOCKSIZE);
    ADD(r4, sp, const((4 * SHA_CTXSIZE + 1 + 2 * SHA_BLOCKSIZE) * WORDSIZE)); 
    assert ValidMemRange(r4, r4 + HMAC_KEYSIZE_WORDS * WORDSIZE);
    key := load_attestion_key();
    ghost var key_mem;
    key_mem := mem;

    assert AddrMemContentsSeq(mem, sp + SHA_CTXSIZE * WORDSIZE, 3 * SHA_CTXSIZE)
        == input by {
        lemma_AddrMemContentsSeq_framing1(old(mem), mem, sp + SHA_CTXSIZE * WORDSIZE, 3 * SHA_CTXSIZE,
                                          r4, r4 + SHA_CTXSIZE * WORDSIZE);
    }

    // Call HMAC
    MOV(r0, sp);                                  // ctx
    ADD(r1, r1, const( (SHA_CTXSIZE + 1) * WORDSIZE));        // tmp_ptr
    MOV(r2, 1);                                   // num_blocks == 1
    ADD(r3, sp, const(SHA_CTXSIZE * WORDSIZE));   // input_ptr
    //ADD(r4, r1, const(2*SHA_BLOCKSIZE*WORDSIZE)); // key_ptr
    LDRglobaladdr(lr, K_SHA256s());

    ghost var pre_hmac_r1;
    pre_hmac_r1 := r1;

    assert SaneShaGlobal(globals) by { lemma_SaneState_implies_SaneShaGlobal(this); }

    // Prove that r1 == tmp_ptr points at a valid range of memory
    assert r1 == sp + (4 * SHA_CTXSIZE + 1) * WORDSIZE;
    calc {
        true;
        ValidMemRange(sp, sp + STACKSIZE_LOCAL * WORDSIZE);
            { lemma_ValidMemRange_offset(sp, STACKSIZE_LOCAL,
                                         4 * SHA_CTXSIZE + 1); }
        ValidMemRange(sp + (4 * SHA_CTXSIZE + 1) * WORDSIZE, sp + STACKSIZE_LOCAL * WORDSIZE);
        ValidMemRange(r1, sp + STACKSIZE_LOCAL * WORDSIZE);
            { lemma_ValidMemRange_reduced(r1,
                                          STACKSIZE_LOCAL - (4 * SHA_CTXSIZE + 1),
                                          HMAC_KEYSIZE_WORDS); }
        ValidMemRange(r1, r1 + 2 * SHA_BLOCKSIZE * WORDSIZE);
    }

    // Prove that there is still a valid range of memory below the stack pointer, for use by HMAC
    calc {
        true;
        ValidMemRange(old_sp - STACKSIZE_ATTEST * WORDSIZE, old_sp);
        ValidMemRange(sp + (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE - STACKSIZE_ATTEST * WORDSIZE, 
                      sp + (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE);
        ValidMemRange(sp - STACKSIZE_HMAC * WORDSIZE, sp + (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE);
            { lemma_ValidMemRange_reduced(sp - STACKSIZE_HMAC * WORDSIZE, 
                                          STACKSIZE_ATTEST,
                                          (STACKSIZE_ATTEST - STACKSIZE_HMAC)); }
        ValidMemRange(sp - STACKSIZE_HMAC * WORDSIZE, sp);
    }

    mac := hmac(key, input);
    assert mac == AddrMemContentsSeq(mem, sp, SHA_CTXSIZE);
    assert mac == HMAC_SHA256(AttestKey(), WordSeqToBytes(input));

    // Prove memory preservation
    calc {
        true;
        AddrMemPreservingExcept3(key_mem, mem,
                                 StackLimit(), sp,
                                 sp, sp + SHA_CTXSIZE * WORDSIZE,
                                 pre_hmac_r1, pre_hmac_r1 + 2 * SHA_BLOCKSIZE * WORDSIZE);
            { assert pre_hmac_r1 == sp + (4*SHA_CTXSIZE + 1) * WORDSIZE; }
        AddrMemPreservingExcept3(key_mem, mem,
                                 StackLimit(), sp,
                                 sp, sp + SHA_CTXSIZE * WORDSIZE,
                                 sp + (4*SHA_CTXSIZE + 1) * WORDSIZE, 
                                 sp + (4*SHA_CTXSIZE + 1 + 2 * SHA_BLOCKSIZE) * WORDSIZE); 
            { 
                lemma_AddrMemPreservingExcept3_condensed(key_mem, mem,
                                 StackLimit(), sp,
                                 sp, sp + SHA_CTXSIZE * WORDSIZE,
                                 sp + (4*SHA_CTXSIZE + 1) * WORDSIZE, 
                                 sp + (4*SHA_CTXSIZE + 1 + 2 * SHA_BLOCKSIZE) * WORDSIZE); 
            }
        AddrMemPreservingExcept(key_mem, mem, StackLimit(), sp + (4*SHA_CTXSIZE + 1 + 2 * SHA_BLOCKSIZE) * WORDSIZE);
        AddrMemPreservingExcept(key_mem, mem, StackLimit(), old_sp);
    }
    assert {:split_here} true;
}

//#verbatim
//function to_word(i:int) : word
//    requires 0 <= i < 0x1_0000_0000
//{
//    i as word
//}
//#endverbatim

procedure {:timeLimitMultiplier 2} svc_returning_attest_inner(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    returns (
    ghost mac_ptr:word,
    ghost mac:seq(word)
    )

    reads
        globals;
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
         mem;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        ValidState(exstate) && mode_of_state(exstate) != User;
        stack_bytes >= STACKSIZE_ATTEST * WORDSIZE;
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
        nonStoppedDispatcher(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        r0 == KOM_SVC_ATTEST;
//        r10 == page_monvaddr(dispPg);
//        r11 == page_monvaddr(pagedb[dispPg].addrspace);
        ValidMemRange(sp - STACKSIZE_ATTEST * WORDSIZE, sp);
    ensures
        // Framing
        StackPreserving(old(this), this);
        NonStackMemPreserving(old(this), this);
        sp == old(sp);

        // Results
        mac_ptr == sp - (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE;
        ValidMemRange(mac_ptr, mac_ptr + SHA_CTXSIZE * WORDSIZE);
        mac == AddrMemContentsSeq(mem, mac_ptr, SHA_CTXSIZE);
        mac == svcHmac(exstate, pagedb, dispPg);
{
    ghost var addrspace := pagedb[dispPg].addrspace;
    assert validAddrspacePage(pagedb, addrspace) by { reveal_validPageDb(); }
    ghost var spec_enclave_measurement := SHA256(WordSeqToBytes(pagedb[addrspace].entry.measurement));
    ghost var real_user_words := seq(r1, r2, r3, r4, r5, r6, r7, r8);
    // Giant OBSERVE to trigger CoreRegPreservingExcept
    ghost var helper_user_words := seq(OperandContents(this, OReg(R1)), 
                                       OperandContents(this, OReg(R2)), 
                                       OperandContents(this, OReg(R3)), 
                                       OperandContents(this, OReg(R4)), 
                                       OperandContents(this, OReg(R5)), 
                                       OperandContents(this, OReg(R6)), 
                                       OperandContents(this, OReg(R7)), 
                                       OperandContents(this, OReg(R8)));
    ghost var spec_user_words := seq(exstate.regs[R1], exstate.regs[R2], exstate.regs[R3], exstate.regs[R4],
                                     exstate.regs[R5], exstate.regs[R6], exstate.regs[R7], exstate.regs[R8]);
    assert real_user_words == helper_user_words == spec_user_words;

    // Stack layout [size in words]:
    //   sp := mac_output[8] || message [8+16] || gap[1] || tmp_ptr[2*SHA_BLOCKSIZE] || key_ptr[HMAC_KEYSIZE_WORDS]
    // where 
    //   message = user_words[8] || enclave_measurement [8] || 0 [8]
    // Total stack usage == 8 + 24 + 1 + 2 * SHA_BLOCKSIZE + HMAC_KEYSIZE_WORDS
    // Plus STACKSIZE_HMAC
    SUB(sp, sp, const((STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE));
    assert StackBytesRemaining(this, STACKSIZE_HMAC * WORDSIZE);
    //WordAlignedAdd(sp, (0 - 1) * (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE);
    
    // Arrange the user words in memory after the gap for the MAC output
    ghost var user_words;
    ghost var measurement;
    ghost var pre_input_sp;
    pre_input_sp := sp;
    user_words, measurement := arrange_attestation_input(pagedb, dispPg);

    assert spec_user_words == user_words;
    assert spec_enclave_measurement == measurement;
    
    assert pageDbCorresponds(this.m, pagedb) by {
        lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb);
    }

    ghost var input;
    input := user_words + measurement + SeqRepeat(8, 0);

    ghost var spec_message;
    spec_message := spec_user_words + spec_enclave_measurement + SeqRepeat(8, 0);
    assert spec_message == input;

    ghost var spec_hmac;
    spec_hmac := HMAC_SHA256(AttestKey(), WordSeqToBytes(spec_message));


    calc {
        old(sp) - (sp + SHA_CTXSIZE * WORDSIZE);
        old(sp) - (old(sp) - (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE  + SHA_CTXSIZE * WORDSIZE);
        (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE - SHA_CTXSIZE * WORDSIZE;
        (STACKSIZE_ATTEST - STACKSIZE_HMAC - SHA_CTXSIZE) * WORDSIZE;
    }

    // Prove stack memory is valid
    ghost var STACKSIZE_LOCAL := STACKSIZE_ATTEST - STACKSIZE_HMAC;
    ghost var size := STACKSIZE_ATTEST - STACKSIZE_HMAC - SHA_CTXSIZE;
    calc {
        true;
        ValidMemRange(old(sp) - STACKSIZE_ATTEST * WORDSIZE, old(sp));
            { lemma_ValidMemRange_offset(old(sp) - STACKSIZE_ATTEST * WORDSIZE, STACKSIZE_ATTEST, STACKSIZE_ATTEST - STACKSIZE_HMAC); }
        ValidMemRange(old(sp) - (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE, old(sp));
        ValidMemRange(sp, old(sp));
            { lemma_ValidMemRange_reduced(sp, STACKSIZE_LOCAL, STACKSIZE_LOCAL - SHA_CTXSIZE); }
        ValidMemRange(sp + SHA_CTXSIZE * WORDSIZE, old(sp));
            { lemma_ValidMemRange_reduced(sp + SHA_CTXSIZE * WORDSIZE, size, size - 4 * SHA_CTXSIZE); }
        ValidMemRange(sp + SHA_CTXSIZE * WORDSIZE, sp + 4 * SHA_CTXSIZE * WORDSIZE);
    }

    mac := compute_hmac(STACKSIZE_HMAC * WORDSIZE, pagedb, dispPg, input, old(sp));
    assert spec_hmac == mac;
    assert mac == svcHmac(exstate, pagedb, dispPg);
    mac_ptr := sp;

    calc {
        sp + (STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE;
        sp + STACKSIZE_LOCAL * WORDSIZE;
        (old(sp) - STACKSIZE_LOCAL * WORDSIZE) + STACKSIZE_LOCAL * WORDSIZE;  
        old(sp);
    }
    assert isUInt32(old(sp));
    ADD(sp, sp, const((STACKSIZE_ATTEST - STACKSIZE_HMAC) * WORDSIZE));
    assert sp == old(sp);
}


procedure svc_returning_attest(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    reads
        globals;
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
         spsr_mon; mem;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        ValidState(exstate) && mode_of_state(exstate) != User;
        stack_bytes >= (STACKSIZE_ATTEST + 10) * WORDSIZE;  // +10 to store volatile reigsters
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
        nonStoppedDispatcher(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        r0 == KOM_SVC_ATTEST;
//        r10 == page_monvaddr(dispPg);
//        r11 == page_monvaddr(pagedb[dispPg].addrspace);
        ValidMemRange(sp - (STACKSIZE_ATTEST + 10) * WORDSIZE, sp);
        //sp - STACKSIZE_ATTEST * WORDSIZE >= KOM_DIRECTMAP_VBASE + MonitorPhysBase();
    ensures
        StackPreserving(old(this), this);
        NonStackMemPreserving(old(this), this);
        let tuple := svcHandled(exstate, pagedb, dispPg) in
        let retRegs := firstOf2(tuple) in
        let handled_pagedb := secondOf2(tuple) in
        pagedb == handled_pagedb && preEntryReturn(old(this), this, retRegs);
{
    ghost var addrspace := pagedb[dispPg].addrspace;
    assert validAddrspacePage(pagedb, addrspace) by { reveal_validPageDb(); }

    ghost var remaining_stack_bytes;
    remaining_stack_bytes := stack_nonvolatiles(stack_bytes);
    lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb);
    
    // Prove we still have a valid stack region after pushing registers onto the stack
    assert sp == old(sp) - 40;
    calc {
        true;
        ValidMemRange(old(sp) - (STACKSIZE_ATTEST + 10) * WORDSIZE, old(sp));
        ValidMemRange(sp + 40 - (STACKSIZE_ATTEST + 10) * WORDSIZE, sp + 40);
        ValidMemRange(sp - STACKSIZE_ATTEST * WORDSIZE, sp + 40);
            { lemma_ValidMemRange_reduced(sp - STACKSIZE_ATTEST * WORDSIZE, 10 + STACKSIZE_ATTEST, 10); }
        ValidMemRange(sp - STACKSIZE_ATTEST * WORDSIZE, sp);
    }

    ghost var mac_ptr:word;
    ghost var mac:seq(word);
    mac_ptr, mac := svc_returning_attest_inner(exstate, remaining_stack_bytes, pagedb, dispPg);

    assert WordAligned(sp);
    WordAlignedAdd(sp, 36);
    WordAlignedAdd(sp, 32);
    WordAlignedAdd(sp, 28);
    WordAlignedAdd(sp, 24);
    WordAlignedAdd(sp, 20);
    WordAlignedAdd(sp, 16);
    WordAlignedAdd(sp, 12);
    WordAlignedAdd(sp,  8);
    WordAlignedAdd(sp,  4);

    remaining_stack_bytes := unstack_nonvolatiles(remaining_stack_bytes);

    assert mac_ptr == sp - (STACKSIZE_ATTEST - STACKSIZE_HMAC + 10) * WORDSIZE;
    // Load the mac into registers
    SUB(r0, sp, const((STACKSIZE_ATTEST - STACKSIZE_HMAC + 10) * WORDSIZE));
    load_memory_into_regs(mac);
    
    MOV(r0, const(encode_mode(User)));
    MSR(spsr_mon, r0);

    MOV(r0, const(KOM_ERR_SUCCESS));
    assert old(lr) == lr;
    assert OperandContents(this, OLR) == OperandContents(old(this), OLR);
    assert {:split_here} true;
}

procedure svc_returning_verify_step0(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    returns (
    ghost pagedb': PageDb
    )
    reads
        globals; lr;
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; 
         spsr_mon; mem;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        ValidState(exstate) && mode_of_state(exstate) != User;
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        r0 == KOM_SVC_VERIFY_STEP0;
    ensures
        StackPreserving(old(this), this);
        MemPreservingExcept(old(this), this, page_monvaddr(dispPg), page_monvaddr(dispPg) + DISP_CTXT_USER_WORDS + 8 * WORDSIZE);
        let tuple := svcHandled(exstate, pagedb, dispPg) in
        let retRegs := firstOf2(tuple) in
        let handled_pagedb := secondOf2(tuple) in
        pagedb' == handled_pagedb && preEntryReturn(old(this), this, retRegs);
        pageDbCorresponds(this.m, pagedb');
        validDispatcherPage(pagedb', dispPg);
{
    ghost var user_words := seq(r1, r2, r3, r4, r5, r6, r7, r8);
    pagedb' := pagedb[dispPg := pagedb[dispPg].(entry := pagedb[dispPg].entry.(verify_words := user_words))];

    LDRglobaladdr(r0, CurDispatcherOp());
    LDRglobal(r0, CurDispatcherOp(), r0, 0);
    assert r0 == page_monvaddr(dispPg);
    // Use r0 to grab DISP_CTXT_USER_WORDS

    STR(r1, r0, const(DISP_CTXT_USER_WORDS + 0 * WORDSIZE));
    STR(r2, r0, const(DISP_CTXT_USER_WORDS + 1 * WORDSIZE));
    STR(r3, r0, const(DISP_CTXT_USER_WORDS + 2 * WORDSIZE));
    STR(r4, r0, const(DISP_CTXT_USER_WORDS + 3 * WORDSIZE));
    STR(r5, r0, const(DISP_CTXT_USER_WORDS + 4 * WORDSIZE));
    STR(r6, r0, const(DISP_CTXT_USER_WORDS + 5 * WORDSIZE));
    STR(r7, r0, const(DISP_CTXT_USER_WORDS + 6 * WORDSIZE));
    STR(r8, r0, const(DISP_CTXT_USER_WORDS + 7 * WORDSIZE));

    MOV(r0, const(encode_mode(User)));
    MSR(spsr_mon, r0);

    assert firstOf2(svcHandled(exstate, pagedb, dispPg)) == tuple(KOM_ERR_SUCCESS,0,0,0,0,0,0,0,0);
    MOV(r0, const(KOM_ERR_SUCCESS));
    MOV(r1, 0);
    MOV(r2, 0);
    MOV(r3, 0);
    MOV(r4, 0);
    MOV(r5, 0);
    MOV(r6, 0);
    MOV(r7, 0);
    MOV(r8, 0);

    ghost var disp := pagedb'[dispPg].entry;
    ghost var pg := extractPage(this.m, dispPg);
    lemma_svc_returning_verify_step0_helper(old(this), pagedb, dispPg, old(this.m), this.m,
        user_words, pagedb', disp, pg);

    assert pageDbCorresponds(this.m, pagedb') by {
        assert pageDbCorrespondsOnly(this.m, pagedb', dispPg) by {
            assert pageDbEntryCorresponds(pagedb'[dispPg],
                                          extractPageDbEntry(this.m, dispPg))
                by { assert GlobalsInvariant(old(this), this);
                     reveal pageDbEntryCorresponds; }
            assert pageContentsCorresponds(dispPg, pagedb'[dispPg], pg)
                by { reveal pageContentsCorresponds; }
        }
        AllButOnePagePreserving(dispPg, old(this), this);
    }
}


procedure svc_returning_verify_step1(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    returns (
    ghost pagedb': PageDb
    )
    reads
        globals; lr; 
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; 
         spsr_mon; mem;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        ValidState(exstate) && mode_of_state(exstate) != User;
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR, OReg(R10)));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
        r0 == KOM_SVC_VERIFY_STEP1;
    ensures
        StackPreserving(old(this), this);
        MemPreservingExcept(old(this), this, page_monvaddr(dispPg), page_monvaddr(dispPg) + DISP_CTXT_VERIFY_MEASUREMENT + 8 * WORDSIZE);
        let tuple := svcHandled(exstate, pagedb, dispPg) in
        let retRegs := firstOf2(tuple) in
        let handled_pagedb := secondOf2(tuple) in
        pagedb' == handled_pagedb && preEntryReturn(old(this), this, retRegs);
        pageDbCorresponds(this.m, pagedb');
        validDispatcherPage(pagedb', dispPg);
{
    ghost var user_words := seq(r1, r2, r3, r4, r5, r6, r7, r8);
    pagedb' := pagedb[dispPg := pagedb[dispPg].(entry := pagedb[dispPg].entry.(verify_measurement := user_words))];

    LDRglobaladdr(r0, CurDispatcherOp());
    LDRglobal(r0, CurDispatcherOp(), r0, 0);
    assert r0 == page_monvaddr(dispPg);
    // Use r10 to grab DISP_CTXT_USER_WORDS

    STR(r1, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 0 * WORDSIZE));
    STR(r2, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 1 * WORDSIZE));
    STR(r3, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 2 * WORDSIZE));
    STR(r4, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 3 * WORDSIZE));
    STR(r5, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 4 * WORDSIZE));
    STR(r6, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 5 * WORDSIZE));
    STR(r7, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 6 * WORDSIZE));
    STR(r8, r0, const(DISP_CTXT_VERIFY_MEASUREMENT + 7 * WORDSIZE));

    MOV(r0, const(encode_mode(User)));
    MSR(spsr_mon, r0);

    assert firstOf2(svcHandled(exstate, pagedb, dispPg)) == tuple(KOM_ERR_SUCCESS,0,0,0,0,0,0,0,0);
    MOV(r0, const(KOM_ERR_SUCCESS));
    MOV(r1, 0);
    MOV(r2, 0);
    MOV(r3, 0);
    MOV(r4, 0);
    MOV(r5, 0);
    MOV(r6, 0);
    MOV(r7, 0);
    MOV(r8, 0);

    ghost var disp := pagedb'[dispPg].entry;
    ghost var pg := extractPage(this.m, dispPg);
    lemma_svc_returning_verify_step1_helper(old(this), pagedb, dispPg, old(this.m), this.m,
        user_words, pagedb', disp, pg);

    assert pageDbCorresponds(this.m, pagedb') by {
        assert pageDbCorrespondsOnly(this.m, pagedb', dispPg) by {
            assert pageDbEntryCorresponds(pagedb'[dispPg],
                                          extractPageDbEntry(this.m, dispPg))
                by { assert GlobalsInvariant(old(this), this);
                     reveal pageDbEntryCorresponds; }
            assert pageContentsCorresponds(dispPg, pagedb'[dispPg], pg)
                by { reveal pageContentsCorresponds; }
        }
        AllButOnePagePreserving(dispPg, old(this), this);
    }
}


procedure svc_returning(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    returns (
    ghost pagedb': PageDb
    )
    reads
        globals;
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
         spsr_mon; mem;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        stack_bytes >= (STACKSIZE_ATTEST + 10) * WORDSIZE;  
        ValidState(exstate) && mode_of_state(exstate) != User;
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
        nonStoppedDispatcher(pagedb, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        lr == old(lr);
        StackPreserving(old(this), this);
        if old(r0) == KOM_SVC_ATTEST || old(r0) > KOM_SVC_VERIFY_STEP2 then
            NonStackMemPreserving(old(this), this)
        else if old(r0) == KOM_SVC_VERIFY_STEP0 then 
            MemPreservingExcept(old(this), this, 
                                page_monvaddr(dispPg), 
                                page_monvaddr(dispPg) + DISP_CTXT_USER_WORDS + 8 * WORDSIZE)
        else if old(r0) == KOM_SVC_VERIFY_STEP1 then
            MemPreservingExcept(old(this), this, 
                                page_monvaddr(dispPg), 
                                page_monvaddr(dispPg) + DISP_CTXT_VERIFY_MEASUREMENT + 8 * WORDSIZE)
        else
            mem == old(mem);
//        AddrMemPreservingExcept2(old(mem), mem, 
//                             page_monvaddr(dispPg), 
//                             page_monvaddr(dispPg) + DISP_CTXT_USER_WORDS + 8 * WORDSIZE,
//                             page_monvaddr(dispPg),
//                             page_monvaddr(dispPg) + DISP_CTXT_VERIFY_MEASUREMENT + 8 * WORDSIZE);
        let tuple := svcHandled(exstate, pagedb, dispPg) in
        let retRegs := firstOf2(tuple) in
        let handled_pagedb := secondOf2(tuple) in
        pagedb' == handled_pagedb && preEntryReturn(old(this), this, retRegs);
{
    if (r0 == const(KOM_SVC_ATTEST)) {
        // Create an attestation
        svc_returning_attest(exstate, stack_bytes, pagedb, dispPg);
        pagedb' := pagedb;
    } else if (r0 == const(KOM_SVC_VERIFY_STEP0)) {
        // Store the user provided words to verify
        pagedb' := svc_returning_verify_step0(exstate, stack_bytes, pagedb, dispPg);
    } else if (r0 == const(KOM_SVC_VERIFY_STEP1)) {
        // Store the user provided measurement to verify
        pagedb' := svc_returning_verify_step1(exstate, stack_bytes, pagedb, dispPg);
    } else if (r0 == const(KOM_SVC_VERIFY_STEP2)) {
        // Do some verification
        assume false;
    } else {
        // Fall back position
        svc_returning_default(exstate, stack_bytes, pagedb, dispPg);
        pagedb' := pagedb;
    }

/*
...
    TODO: Add more stack space
        - precondition on stack_bytes
        - In entry.i.dfy, increase 
            const EXCEPTION_STACK_BYTES:int := 100*WORDSIZE;
*/

    
}

procedure {:frame false} svc_handler(ghost pagedb_in: PageDb, ghost dispPg: PageNr)
                            returns (ghost pagedb: PageDb)
    reads
        globals; /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
    modifies
        mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; cpsr; lr; spsr_mon;
    requires
        KomUserEntryPrecondition(this, pagedb_in, dispPg);
        InterruptContinuationPreconditionDef();
        InterruptContinuationInvariantDef();
        mode_of_state(this) == Supervisor && spsr_of_state(this).m == User;
        this.conf.ex == ExSVC;
        exists stack_bytes :: StackBytesRemaining(this, stack_bytes) && stack_bytes >= (STACKSIZE_ATTEST + 10) * WORDSIZE;
    ensures
        KomExceptionHandlerInvariant(old(this), pagedb_in, this, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    lemma_Establish_InterruptContinuationPrecondition(this, pagedb_in, dispPg);
    switch_to_monitor(Supervisor);
    lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb_in);

    if (r0 == const(KOM_SVC_EXIT)) {
        assert !isReturningSvc(old(this));
        pagedb := fault_exit(ExSVC, old(this), pagedb_in, dispPg);
        ORR(sp, sp, 1); // report that we're done
    } else {
        assert isReturningSvc(old(this));

        // sigh. trigger OReg(x) to see CoreRegPreservingExcept
        assert r9 == OperandContents(this, OReg(R9)) == old(r9);
        assert r10 == OperandContents(this, OReg(R10)) == old(r10);
        assert r11 == OperandContents(this, OReg(R11)) == old(r11);
        assert r12 == OperandContents(this, OReg(R12)) == old(r12);
        assert lr_usr == old(lr_usr) && sp_usr == old(sp_usr);

        pagedb := svc_returning(old(this), EXCEPTION_STACK_BYTES, pagedb_in, dispPg);
        ghost var tuple;
        tuple := svcHandled(old(this), pagedb, dispPg);
        assert pagedb == secondOf2(tuple);
        assert preEntryReturn(old(this), this, firstOf2(tuple));
    }

    assert validExceptionTransition(old(this), pagedb_in, this, pagedb, dispPg)
        by { reveal validExceptionTransition; }
}

procedure {:frame false} abort_handler(
    inline ex: exception,
    ghost pagedb_in: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    reads
        globals; /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
    modifies
        mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; cpsr; lr; spsr_mon;
    requires
        KomUserEntryPrecondition(this, pagedb_in, dispPg);
        InterruptContinuationPreconditionDef();
        InterruptContinuationInvariantDef();
        this.conf.ex == ex && (ex == ExAbt || ex == ExUnd);
        mode_of_state(this) == (if ex == ExAbt then Abort else Undefined);
        spsr_of_state(this).m == User;
    ensures
        KomExceptionHandlerInvariant(old(this), pagedb_in, this, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    lemma_Establish_InterruptContinuationPrecondition(this, pagedb_in, dispPg);
    switch_to_monitor(if ex == ExAbt then Abort else Undefined);
    lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb_in);

    pagedb := fault_exit(ex, old(this), pagedb_in, dispPg);
    ORR(sp, sp, 1); // report that we're done

    assert validExceptionTransition(old(this), pagedb_in, this, pagedb, dispPg)
        by { reveal_validExceptionTransition(); }
}

procedure save_disp_context_helper(operand base:reg, ghost dispPg:PageNr)
    requires/ensures
        SaneState(this);
    requires
        @base == OReg(R0);
        base == page_monvaddr(dispPg);
    reads
        globals;
        r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr_usr; sp_usr; lr; spsr_mon;
    modifies
        mem; r1;
    ensures
        MemPreservingExcept(old(this), this, old(base) + DISP_CTXT_R1,
                            old(base) + DISP_CTXT_PSR + WORDSIZE);
        let pg := extractPage(this.m, dispPg) in
            pg[old(base) + DISP_CTXT_R1] == old(r1)
            && pg[old(base) + DISP_CTXT_R2] == old(r2)
            && pg[old(base) + DISP_CTXT_R3] == old(r3)
            && pg[old(base) + DISP_CTXT_R4] == old(r4)
            && pg[old(base) + DISP_CTXT_R5] == old(r5)
            && pg[old(base) + DISP_CTXT_R6] == old(r6)
            && pg[old(base) + DISP_CTXT_R7] == old(r7)
            && pg[old(base) + DISP_CTXT_R8] == old(r8)
            && pg[old(base) + DISP_CTXT_R9] == old(r9)
            && pg[old(base) + DISP_CTXT_R10] == old(r10)
            && pg[old(base) + DISP_CTXT_R11] == old(r11)
            && pg[old(base) + DISP_CTXT_R12] == old(r12)
            && pg[old(base) + DISP_CTXT_LR] == old(lr_usr)
            && pg[old(base) + DISP_CTXT_SP] == old(sp_usr)
            && pg[old(base) + DISP_CTXT_PC] == old(lr)
            && pg[old(base) + DISP_CTXT_PSR] == old(spsr_mon);
{
    STR(r1, base, const(DISP_CTXT_R1));
    STR(r2, base, const(DISP_CTXT_R2));
    STR(r3, base, const(DISP_CTXT_R3));
    STR(r4, base, const(DISP_CTXT_R4));
    STR(r5, base, const(DISP_CTXT_R5));
    STR(r6, base, const(DISP_CTXT_R6));
    STR(r7, base, const(DISP_CTXT_R7));
    STR(r8, base, const(DISP_CTXT_R8));
    STR(r9, base, const(DISP_CTXT_R9));
    STR(r10, base, const(DISP_CTXT_R10));
    STR(r11, base, const(DISP_CTXT_R11));
    STR(r12, base, const(DISP_CTXT_R12));
    MRS_STR(lr_usr, base, const(DISP_CTXT_LR), r1);
    MRS_STR(sp_usr, base, const(DISP_CTXT_SP), r1);
    STR(lr, base, const(DISP_CTXT_PC));
    MRS_STR(spsr_mon, base, const(DISP_CTXT_PSR), r1);
}

procedure save_disp_context(inout operand base: reg,
                            ghost ex:exception, ghost exstate:state,
                            ghost dispPg:PageNr, ghost pagedb_in:PageDb)
                        returns  (ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        @base == OReg(R0);
        base == page_monvaddr(dispPg);
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        validDispatcherPage(pagedb_in, dispPg);
        ex == exstate.conf.ex && (ex == ExFIQ || ex == ExIRQ);
        ValidState(exstate) && mode_of_state(exstate) == Monitor
            && spsr_of_state(exstate).m == User;
        va_get_sreg(spsr(Monitor), exstate) == spsr_mon;
        forall r :: USER_REGS() ?[r] && r != R0
            ==> va_get_reg(r, exstate) == va_get_reg(r, this);
        ValidMem(sp) && va_get_reg(R0, exstate) == MemContents(this.m, sp);
        lr == TruncateWord(OperandContents(exstate, OLR) - 4);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    reads
        globals;
        r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr_usr; sp_usr; lr; sp; spsr_mon;
    modifies
        mem; r0; r1;
    ensures
        validPageDb(pagedb);
        pagedb == exPageDb(exceptionHandled(exstate, pagedb_in, dispPg));
        pageDbCorresponds(this.m, pagedb);
        MemPreservingExcept(old(this), this, old(base), old(base) + PAGESIZE);
        StackPreserving(old(this), this);
{
    ghost var gr0 := va_get_reg(R0, exstate);
    ghost var orig_disp := pagedb_in[dispPg].entry;
    ghost var orig_pg := extractPage(old(this.m), dispPg);
    assert orig_disp.entrypoint == orig_pg[base + DISPATCHER_ENTRYPOINT]
    by {
        assert pageDbDispatcherCorresponds(dispPg, orig_disp, orig_pg)
            by { reveal pageContentsCorresponds; }
        reveal pageDbDispatcherCorresponds;
    }

    save_disp_context_helper(base, dispPg);
    LDR(r1,sp,0);
    assert r1 == gr0;
    STR(r1, base, const(DISP_CTXT_R0));
    MOV(r1, 1);
    STR(r1, base, const(DISPATCHER_ENTERED));

    assert MemPreservingExcept(old(this), this, old(base), old(base) + DISP_SIZE);

    pagedb := exPageDb(exceptionHandled(exstate, pagedb_in, dispPg));
    lemma_exceptionHandled_validPageDb(exstate, pagedb_in, dispPg);

    ghost var disp := pagedb[dispPg].entry;
    ghost var pg := extractPage(this.m, dispPg);
    assert pageDbDispatcherCorresponds(dispPg, disp, pg) by {
        ghost var ctxt := disp.ctxt;
        ghost var pgbase := page_monvaddr(dispPg);
        assert ctxt == DispatcherContext(user_regs(exstate.regs), old(lr),
                                         old(spsr_mon));
        /*assert orig_disp.entrypoint == disp.entrypoint
            == pg[pgbase + DISPATCHER_ENTRYPOINT];
        assert pg[pgbase + DISP_CTXT_PC] == old(lr)
            == TruncateWord(OperandContents(exstate, OLR) - 4);
        // oh for a calc statement...
        assert pg[pgbase + DISP_CTXT_PSR] == old(spsr_mon)
            == exstate.sregs[spsr(mode_of_state(exstate))];
        assert pg[pgbase + DISP_CTXT_R0] == gr0 == ctxt.regs[R0];
        assert pg[pgbase + DISP_CTXT_LR] == old(lr_usr) == ctxt.regs[LR(User)];
        assert pg[pgbase + DISP_CTXT_SP] == old(sp_usr) == ctxt.regs[SP(User)];
        assert forall r :: USER_REGS() ?[r] && r != R0
            ==> va_get_reg(r, exstate) == va_get_reg(r, old(this)) == ctxt.regs[r];*/
        reveal pageDbDispatcherCorresponds;
    }

    assert pageDbCorresponds(this.m, pagedb) by {
        assert pageDbCorrespondsOnly(this.m, pagedb, dispPg) by {
            assert pageDbEntryCorresponds(pagedb[dispPg],
                                          extractPageDbEntry(this.m, dispPg))
                by { assert GlobalsInvariant(old(this), this);
                     reveal pageDbEntryCorresponds; }
            assert pageContentsCorresponds(dispPg, pagedb[dispPg], pg)
                by { reveal pageContentsCorresponds; }
        }
        AllButOnePagePreserving(dispPg, old(this), this);
    }
}

procedure {:frame false} interrupt_handler(
    inline ex: exception,
    ghost pagedb_in: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    reads
        globals; /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
    modifies
        mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; cpsr; lr; spsr_mon;
    requires
        KomUserEntryPrecondition(this, pagedb_in, dispPg);
        InterruptContinuationInvariantDef();
        this.conf.ex == ex && (ex == ExFIQ || ex == ExIRQ);
        mode_of_state(this) == Monitor;
        !interrupts_enabled(this);
    ensures
        KomInterruptHandlerInvariant(old(this), pagedb_in, this, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    // adjust LR for interrupt offset
    SUBWrap(lr, lr, 4);

    // push r0, r1
    SUB(sp, sp, const(2 * WORDSIZE));
    STR(r0, sp, 0);
    STR(r1, sp, const(WORDSIZE));

    assert ParentStackPreserving(old(this), this);

    // store pending interrupt
    inline if (ex == ExFIQ) {
        MOV(r1, const(7*WORDSIZE)); // exception table FIQ vector offset
    } else {
        MOV(r1, const(6*WORDSIZE)); // exception table IRQ vector offset
    }
    LDRglobaladdr(r0, PendingInterruptOp());
    STRglobal(r1, PendingInterruptOp(), r0, 0);

    // figure out where we came from
    MRS(r0, spsr_mon);
    AND(r0, r0, const(ARM_PSR_MODE_MASK));
    assert r0 == psr_mask_mode(old(spsr_mon));

    assert GlobalsPreservingExcept(old(this), this, set(PendingInterruptOp()));
    assert MemPreservingExcept(old(this), this, sp, sp + 2 * WORDSIZE);
    assert forall r :: r != R0 && r != R1 && r != LR(Monitor) && r != SP(Monitor)
        ==> va_get_reg(r, old(this)) == va_get_reg(r, this);

    if (r0 == const(encode_mode(User))) { // we came from user-mode
        assert spsr_of_state(old(this)).m == User;

        // save dispatcher context
        LDRglobaladdr(r0, CurDispatcherOp());
        LDRglobal(r0, CurDispatcherOp(), r0, 0);
        LDR(r1, sp, const(WORDSIZE));
        assert r1 == old(r1);
        lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb_in);
        pagedb := save_disp_context(r0, ex, old(this), dispPg, pagedb_in);

        MOV(r0, const(KOM_ERR_INTERRUPTED));
        MOV(r1, 0);
        assert tuple(r0, r1, pagedb) == exceptionHandled(old(this), pagedb_in, dispPg);

        ADD(sp, sp, const(2 * WORDSIZE));
        assert sp == old(sp);
        assert StackPreserving(old(this), this);
        ORR(sp, sp, 1);

        assert validExceptionTransition(old(this), pagedb_in, this, pagedb, dispPg)
            by { reveal_validExceptionTransition(); }
        assert KomExceptionHandlerInvariant(old(this), pagedb_in, this, dispPg);
    } else { // we came from another exception handler
        assert spsr_of_state(old(this)).m != User;
        assert priv_of_mode(spsr_of_state(old(this)).m) == PL1;

        // restore r0, r1, sp
        LDR(r0, sp, 0);
        LDR(r1, sp, const(WORDSIZE));
        ADD(sp, sp, const(2 * WORDSIZE));
        assert r0 == old(r0) && r1 == old(r1) && sp == old(sp);

        pagedb := pagedb_in;
        lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb);
        assert KomInterruptHandlerInvariant(old(this), pagedb_in, this, dispPg);
    }
}
