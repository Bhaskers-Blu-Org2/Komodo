include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"
include {:verbatim} "entry.i.dfy"

include "ARMdecls-unrefined.sdfy"

procedure switch_to_monitor()
    requires
        SaneConstants() && ValidState(this)  && SaneStack(this) && SaneMem(this.m);
        priv_of_state(this) == PL1 && world_of_state(this) == Secure;
        this.ok;
    ensures
        SaneState(this);
        AllMemInvariant(old(this), this);
        this.regs == old(this.regs);
{
    assert ValidPsrWord(cpsr) by { reveal_ValidSRegState(); }
    CPSID_IAF(const(encode_mode(Monitor)));
    lemma_update_psr(old(cpsr), encode_mode(Monitor), true, true);
}

procedure svc_handler(
    inout {:register OReg(R0)} retval:int,
    ghost user_state: state,
    ghost stack_bytes: int,
    ghost pagedb_in: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    requires
        SaneConstants() && ValidState(this)  && SaneStack(this) && SaneMem(this.m);
        this.ok;
        StackBytesRemaining(this, stack_bytes);
        ValidState(user_state) && mode_of_state(user_state) == User;
        evalExceptionTaken(user_state, ExSVC, this);
        this.conf.scr.ns == Secure;
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        nonStoppedDispatcher(pagedb_in, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
        mode_of_state(old(this)) != User && KomExceptionHandlerInvariant(old(this), pagedb_in, this, dispPg);
        tuple(r0, r1, pagedb) == exceptionHandled(old(this), pagedb_in, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    assert mode_of_state(this) == Supervisor
        by { lemma_evalExceptionTaken_Mode(user_state, ExSVC, this); }
    switch_to_monitor();
    ghost var start := this;

    r1 := r0;
    r0 := const(KOM_ERR_SUCCESS);

    LDRglobaladdr(r2, CurDispatcherOp());
    LDRglobal(r2, CurDispatcherOp(), r2, 0);
    assert r2 == page_monvaddr(dispPg);

    assert r0 == 0;
    STR(r0, r2, const(DISPATCHER_ENTERED));

    ghost var dispEntry := pagedb_in[dispPg].entry.(entered := false);
    ghost var pg := extractPage(this.m, dispPg);
    ghost var oldpg := extractPage(old(this).m, dispPg);
    assert pageDbDispatcherCorresponds(dispPg, dispEntry, pg) by {
        reveal_pageDbDispatcherCorresponds();
        assert pageDbDispatcherCorresponds(dispPg, pagedb_in[dispPg].entry, oldpg)
            by { reveal_pageContentsCorresponds(); }
        assert pg[page_monvaddr(dispPg) + DISPATCHER_ENTERED] == 0;
        assert forall a:addr :: addrInPage(a, dispPg)
            && a != page_monvaddr(dispPg) + DISPATCHER_ENTERED
            ==> pg[a] == oldpg[a];
    }

    pagedb := pagedb_in[dispPg := pagedb_in[dispPg].(entry := dispEntry)];
    assert pagedb == exPageDb(exceptionHandled(old(this), pagedb_in, dispPg));
    exceptionHandledValidPageDb(user_state, ExSVC, old(this), pagedb_in, dispPg);

    assert GlobalsInvariant(old(this), this);
    assert pageDbCorrespondsOnly(this.m, pagedb, dispPg)
        by { reveal_pageContentsCorresponds(); reveal_pageDbEntryCorresponds(); }
    AllButOnePagePreserving(dispPg, start, this);
    assert pageDbCorresponds(this.m, pagedb);

    assert validExceptionTransition(SysState(old(this), pagedb_in),
                                    SysState(this, pagedb), dispPg)
        by { reveal_validExceptionTransition(); }
}

procedure abort_handler(
    ghost user_state: state,
    ghost ex: exception,
    ghost stack_bytes: int,
    ghost pagedb_in: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    requires
        SaneConstants() && ValidState(this)  && SaneStack(this) && SaneMem(this.m);
        this.ok;
        StackBytesRemaining(this, stack_bytes);
        ValidState(user_state) && mode_of_state(user_state) == User;
        ex == ExAbt || ex == ExUnd;
        evalExceptionTaken(user_state, ex, this);
        this.conf.scr.ns == Secure;
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        nonStoppedDispatcher(pagedb_in, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
        mode_of_state(old(this)) != User && KomExceptionHandlerInvariant(old(this), pagedb_in, this, dispPg);
        tuple(r0, r1, pagedb) == exceptionHandled(old(this), pagedb_in, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    // switch to monitor mode
    lemma_evalExceptionTaken_Mode(user_state, ex, this);
    switch_to_monitor();
    ghost var start := this;

    LDRglobaladdr(r2, CurDispatcherOp());
    LDRglobal(r2, CurDispatcherOp(), r2, 0);
    assert r2 == page_monvaddr(dispPg);

    r0 := const(KOM_ERR_FAULT);
    r1 := 0;

    STR(r1, r2, const(DISPATCHER_ENTERED));

    ghost var dispEntry := pagedb_in[dispPg].entry.(entered := false);
    ghost var pg := extractPage(this.m, dispPg);
    ghost var oldpg := extractPage(old(this).m, dispPg);
    assert pageDbDispatcherCorresponds(dispPg, dispEntry, pg) by {
        reveal_pageDbDispatcherCorresponds();
        assert pageDbDispatcherCorresponds(dispPg, pagedb_in[dispPg].entry, oldpg)
            by { reveal_pageContentsCorresponds(); }
        assert pg[page_monvaddr(dispPg) + DISPATCHER_ENTERED] == 0;
        assert forall a:addr :: addrInPage(a, dispPg)
            && a != page_monvaddr(dispPg) + DISPATCHER_ENTERED
            ==> pg[a] == oldpg[a];
    }

    pagedb := pagedb_in[dispPg := pagedb_in[dispPg].(entry := dispEntry)];
    assert pagedb == exPageDb(exceptionHandled(old(this), pagedb_in, dispPg));
    exceptionHandledValidPageDb(user_state, ex, old(this), pagedb_in, dispPg);

    assert GlobalsInvariant(old(this), this);
    assert pageDbCorrespondsOnly(this.m, pagedb, dispPg)
        by { reveal_pageContentsCorresponds(); reveal_pageDbEntryCorresponds(); }
    AllButOnePagePreserving(dispPg, start, this);
    assert pageDbCorresponds(this.m, pagedb);

    assert validExceptionTransition(SysState(old(this), pagedb_in),
                                    SysState(this, pagedb), dispPg)
        by { reveal_validExceptionTransition(); }
}
