include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"
include {:verbatim} "entry.i.dfy"
include {:verbatim} "exceptions.i.dfy"

include "ARMdecls.sdfy"
include "kom_utils.sdfy"

#verbatim
function cpsr_of_state(s:state): word
    requires ValidState(s)
{ reveal_ValidSRegState(); s.sregs[cpsr] }
#endverbatim

procedure {:frame false} {:instruction Ins(CPSID_IAF(mod))}
CPSID_IAF(operand mod:word)
    requires/ensures
        ValidState(this) && this.ok;
        SaneStack(this) && SaneMem(this.m);
    requires
        InterruptContinuationInvariantDef();
        @mod is OConst;
        ValidModeEncoding(mod);
        priv_of_state(this) == PL1;
        ValidModeChange'(this, decode_mode(mod));
    modifies
        cpsr;
    ensures
        !interrupts_enabled(this);
        mode_of_state(this) == decode_mode(mod);
        StackPreserving(old(this), this);
        NonStackMemPreserving(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PendingInterruptOp()));
        this.conf.ttbr0 == old(this).conf.ttbr0;
        this.conf.scr == old(this).conf.scr;
        CoreRegPreservingExcept(old(this), this, set(OSP, OLR)); // banked
        forall m :: m != mode_of_exception(old(this).conf, ExIRQ)
            && m != mode_of_exception(old(this).conf, ExFIQ)
            ==> old(this).regs[LR(m)] == this.regs[LR(m)];
{
    reveal va_eval;
    exists s' :: maybeHandleInterrupt(old(this), s') && evalIns'(CPSID_IAF(@mod), s', this);
    lemma_PrivInterruptInvariants(old(this), s');
    assert mode_of_state(s') == mode_of_state(old(this))
        && world_of_state(s') == world_of_state(old(this));
    assert ValidInstruction(s', CPSID_IAF(@mod)) && evalCPSID_IAF(s', mod, this);
    lemma_update_psr(cpsr_of_state(s'), mod, true, true);
}

procedure {:frame false} switch_to_monitor(inline oldmode:mode)
    modifies
        cpsr; lr; /* spsr_mon; */
    reads
        /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
    requires
        InterruptContinuationInvariantDef();
        SaneConstants() && ValidState(this) && SaneStack(this) && SaneMem(this.m);
        priv_of_state(this) == PL1 && world_of_state(this) == Secure;
        mode_of_state(this) == oldmode;
        oldmode == Supervisor || oldmode == Abort || oldmode == Undefined;
        this.ok;
    ensures
        SaneState(this);
        SaneStack(this);
        StackPreserving(old(this), this);
        NonStackMemPreserving(old(this), this);
        GlobalsPreservingExcept(old(this), this, set(PendingInterruptOp()));
        CoreRegPreservingExcept(old(this), this, set(OSP, OLR)); // banked
        //spsr_of_state(this) == spsr_of_state(old(this));
        lr == OperandContents(old(this), OLR);
        this.conf.ttbr0 == old(this).conf.ttbr0;
        this.conf.scr == old(this).conf.scr;
{
    CPSID_IAF(const(encode_mode(Monitor)));

    // inline if (oldmode == Supervisor) {
    //    MRS(lr, spsr_svc);
    // } else if (oldmode == Abort) {
    //    MRS(lr, spsr_abt);
    // } else if (oldmode == Undefined) {
    //    MRS(lr, spsr_und);
    // }
    // MSR(spsr_mon, lr);

    inline if (oldmode == Supervisor) {
       MRS(lr, lr_svc);
    } else if (oldmode == Abort) {
       MRS(lr, lr_abt);
    } else if (oldmode == Undefined) {
       MRS(lr, lr_und);
    }
}

procedure fault_exit(
    inline ex: exception,
    ghost user_state: state,
    ghost exstate: state,
    ghost pagedb_in: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    reads
        globals;
    modifies
        mem; r0; r1; r2;
    requires/ensures
        SaneState(this);
    requires
        ValidState(user_state) && mode_of_state(user_state) == User;
        evalExceptionTaken(user_state, ex, exstate);
        ValidState(exstate) && mode_of_state(exstate) != User;
        exstate.conf.ex == ex && set(ExSVC, ExAbt, ExUnd) ?[ex];
        r1 == OperandContents(exstate, OReg(R1));
        //this.conf.scr.ns == Secure;
        validPageDb(pagedb_in);
        SaneMem(exstate.m);
        pageDbCorresponds(exstate.m, pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        nonStoppedDispatcher(pagedb_in, dispPg);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        tuple(r0, r1, pagedb) == exceptionHandled(exstate, pagedb_in, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validExceptionTransition(old(this), pagedb_in, this, pagedb, dispPg);
        MemPreservingExcept(old(this), this, page_monvaddr(dispPg),
                            page_monvaddr(dispPg) + PAGESIZE);
{
    LDRglobaladdr(r2, CurDispatcherOp());
    LDRglobal(r2, CurDispatcherOp(), r2, 0);
    assert r2 == page_monvaddr(dispPg);

    MOV(r0, 0);
    STR(r0, r2, const(DISPATCHER_ENTERED));
    inline if (ex == ExSVC) {
        assert r0 == KOM_ERR_SUCCESS;
    } else {
        MOV(r0, const(KOM_ERR_FAULT));
        MOV(r1, 0);
    }

    ghost var dispEntry := pagedb_in[dispPg].entry.(entered := false);
    ghost var pg := extractPage(this.m, dispPg);
    ghost var oldpg := extractPage(old(this).m, dispPg);
    assert pageDbDispatcherCorresponds(dispPg, dispEntry, pg) by {
        reveal pageDbDispatcherCorresponds;
        assert pageDbDispatcherCorresponds(dispPg, pagedb_in[dispPg].entry, oldpg)
            by { reveal pageContentsCorresponds; }
        assert pg[page_monvaddr(dispPg) + DISPATCHER_ENTERED] == 0;
        assert forall a:addr :: addrInPage(a, dispPg)
            && a != page_monvaddr(dispPg) + DISPATCHER_ENTERED
            ==> pg[a] == oldpg[a];
    }

    pagedb := pagedb_in[dispPg := pagedb_in[dispPg].(entry := dispEntry)];
    assert pagedb == exPageDb(exceptionHandled(exstate, pagedb_in, dispPg));
    exceptionHandledValidPageDb(user_state, ex, exstate, pagedb_in, dispPg);

    assert GlobalsInvariant(old(this), this);
    assert pageDbCorrespondsOnly(this.m, pagedb, dispPg)
        by { reveal pageContentsCorresponds; reveal pageDbEntryCorresponds; }
    AllButOnePagePreserving(dispPg, old(this), this);
    assert pageDbCorresponds(this.m, pagedb);

    reveal validExceptionTransition;
}

procedure svc_returning(
    ghost exstate: state,
    ghost stack_bytes: int,
    ghost pagedb: PageDb,
    ghost dispPg: PageNr)
    reads
        globals;
    modifies
         r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; lr;
         spsr_mon;
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        ValidState(exstate) && mode_of_state(exstate) != User;
        isReturningSvc(exstate);
        CoreRegPreservingExcept(exstate, this, set(OSP, OLR));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg);
    ensures
        lr == old(lr);
        StackPreserving(old(this), this);
        NonStackMemPreserving(old(this), this);
        preEntryReturn(this, old(lr), svcHandled(exstate, pagedb, dispPg));
{
    assert svcHandled(exstate, pagedb, dispPg) == tuple(KOM_ERR_INVALID,0,0,0,0,0,0,0,0);

    MOV(r0, const(encode_mode(User)));
    MSR(spsr_mon, r0);

    MOV(r0, const(KOM_ERR_INVALID));
    MOV(r1, 0);
    MOV(r2, 0);
    MOV(r3, 0);
    MOV(r4, 0);
    MOV(r5, 0);
    MOV(r6, 0);
    MOV(r7, 0);
    MOV(r8, 0);
}

#verbatim
predicate handler_requires(s: state, stack_bytes: int)
{
    InterruptContinuationInvariantDef()
    && SaneConstants() && ValidState(s)  && SaneStack(s) && SaneMem(s.m) && s.ok
    && StackBytesRemaining(s, stack_bytes)
    && s.conf.scr == SCRT(Secure, true, true)
    && mode_of_state(s) != User
}
#endverbatim

procedure {:frame false} svc_handler(
    ghost user_state: state,
    ghost stack_bytes: int,
    ghost pagedb0: PageDb,
    ghost pagedb1: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    reads
        globals; /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
    modifies
        mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; cpsr; lr; spsr_mon;
    requires
        handler_requires(this, stack_bytes);
        ValidState(user_state) && mode_of_state(user_state) == User;
        evalExceptionTaken(user_state, ExSVC, this);
        validPageDb(pagedb0) && validPageDb(pagedb1);
        nonStoppedDispatcher(pagedb0, dispPg);
        pagedb1 == updateUserPagesFromState(user_state, pagedb0, dispPg);
        pageDbCorresponds(this.m, pagedb1);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        KomExceptionHandlerInvariant(old(this), pagedb1, this, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    assert mode_of_state(this) == Supervisor
        by { lemma_evalExceptionTaken_Mode(user_state, ExSVC, this); }
    switch_to_monitor(Supervisor);
    lemma_SameMemAndGlobalsPreservesPageDb'(old(this), this, pagedb1);

    if (r0 == const(KOM_SVC_EXIT)) {
        assert !isReturningSvc(old(this));
        pagedb := fault_exit(ExSVC, user_state, old(this), pagedb1, dispPg);
        ORR(sp, sp, 1); // report that we're done
    } else {
        assert isReturningSvc(old(this));
        pagedb := pagedb1;
        svc_returning(old(this), stack_bytes, pagedb, dispPg);
        assert preEntryReturn(this, OperandContents(old(this), OLR),
                              svcHandled(old(this), pagedb, dispPg));
    }

    assert validExceptionTransition(old(this), pagedb1, this, pagedb, dispPg)
        by { reveal validExceptionTransition; }
}

procedure {:frame false} abort_handler(
    inline ex: exception,
    ghost user_state: state,
    ghost stack_bytes: int,
    ghost pagedb0: PageDb,
    ghost pagedb1: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    reads
        globals; /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
    modifies
        mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; cpsr; lr; spsr_mon;
    requires
        handler_requires(this, stack_bytes);
        ValidState(user_state) && mode_of_state(user_state) == User;
        ex == ExAbt || ex == ExUnd;
        evalExceptionTaken(user_state, ex, this);
        validPageDb(pagedb0) && validPageDb(pagedb1);
        nonStoppedDispatcher(pagedb0, dispPg);
        pagedb1 == updateUserPagesFromState(user_state, pagedb0, dispPg);
        pageDbCorresponds(this.m, pagedb1);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        KomExceptionHandlerInvariant(old(this), pagedb1, this, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ghost var m := if ex == ExAbt then Abort else Undefined;
    assert mode_of_state(this) == m
        by { lemma_evalExceptionTaken_Mode(user_state, ex, this); }
    switch_to_monitor(if ex == ExAbt then Abort else Undefined);
    lemma_SameMemAndGlobalsPreservesPageDb'(old(this), this, pagedb1);

    pagedb := fault_exit(ex, user_state, old(this), pagedb1, dispPg);
    ORR(sp, sp, 1); // report that we're done

    assert validExceptionTransition(old(this), pagedb1, this, pagedb, dispPg)
        by { reveal_validExceptionTransition(); }
}

procedure save_disp_context_helper(operand base:reg, ghost dispPg:PageNr)
    requires/ensures
        SaneState(this);
    requires
        @base == OReg(R0);
        base == page_monvaddr(dispPg);
    reads
        globals;
        r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr_usr; sp_usr; lr; spsr_mon;
    modifies
        mem; r1;
    ensures
        MemPreservingExcept(old(this), this, old(base) + DISP_CTXT_R1,
                            old(base) + DISP_CTXT_PSR + WORDSIZE);
        let pg := extractPage(this.m, dispPg) in
            pg[old(base) + DISP_CTXT_R1] == old(r1)
            && pg[old(base) + DISP_CTXT_R2] == old(r2)
            && pg[old(base) + DISP_CTXT_R3] == old(r3)
            && pg[old(base) + DISP_CTXT_R4] == old(r4)
            && pg[old(base) + DISP_CTXT_R5] == old(r5)
            && pg[old(base) + DISP_CTXT_R6] == old(r6)
            && pg[old(base) + DISP_CTXT_R7] == old(r7)
            && pg[old(base) + DISP_CTXT_R8] == old(r8)
            && pg[old(base) + DISP_CTXT_R9] == old(r9)
            && pg[old(base) + DISP_CTXT_R10] == old(r10)
            && pg[old(base) + DISP_CTXT_R11] == old(r11)
            && pg[old(base) + DISP_CTXT_R12] == old(r12)
            && pg[old(base) + DISP_CTXT_LR] == old(lr_usr)
            && pg[old(base) + DISP_CTXT_SP] == old(sp_usr)
            && pg[old(base) + DISP_CTXT_PC] == old(lr)
            && pg[old(base) + DISP_CTXT_PSR] == old(spsr_mon);
{
    STR(r1, base, const(DISP_CTXT_R1));
    STR(r2, base, const(DISP_CTXT_R2));
    STR(r3, base, const(DISP_CTXT_R3));
    STR(r4, base, const(DISP_CTXT_R4));
    STR(r5, base, const(DISP_CTXT_R5));
    STR(r6, base, const(DISP_CTXT_R6));
    STR(r7, base, const(DISP_CTXT_R7));
    STR(r8, base, const(DISP_CTXT_R8));
    STR(r9, base, const(DISP_CTXT_R9));
    STR(r10, base, const(DISP_CTXT_R10));
    STR(r11, base, const(DISP_CTXT_R11));
    STR(r12, base, const(DISP_CTXT_R12));
    MRS_STR(lr_usr, base, const(DISP_CTXT_LR), r1);
    MRS_STR(sp_usr, base, const(DISP_CTXT_SP), r1);
    STR(lr, base, const(DISP_CTXT_PC));
    MRS_STR(spsr_mon, base, const(DISP_CTXT_PSR), r1);
}

procedure save_disp_context(ghost ustate:state, ghost ex:exception,
                            ghost exstate:state,
                            ghost dispPg:PageNr, ghost pagedb_in:PageDb)
                        returns  (ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        validDispatcherPage(pagedb_in, dispPg);
        ValidState(ustate) && mode_of_state(ustate) == User;
        ex == exstate.conf.ex && (ex == ExFIQ || ex == ExIRQ);
        evalExceptionTaken(ustate, ex, exstate) && mode_of_state(exstate) == Monitor;
        CoreRegPreservingExcept(exstate, this, set(OReg(R0), OSP));
        forall o :: set(OSReg(spsr(Monitor)), OReg(LR(User)), OReg(SP(User))) ?[o]
            ==> OperandContents(exstate, o) == OperandContents(this, o);
        ValidMem(sp) && OperandContents(exstate, OReg(R0)) == MemContents(this.m, sp);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    reads
        globals;
        r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr_usr; sp_usr; lr; sp; spsr_mon;
    modifies
        mem; r0; r1;
    ensures
        validPageDb(pagedb);
        tuple(r0, r1, pagedb) == exceptionHandled(exstate, pagedb_in, dispPg);
        pageDbCorresponds(this.m, pagedb);
{
    ghost var gr0 := OperandContents(exstate, OReg(R0));
    ghost var base := page_monvaddr(dispPg);
    ghost var orig_disp := pagedb_in[dispPg].entry;

    assert orig_disp.entrypoint
            == extractPage(old(this.m), dispPg)[base + DISPATCHER_ENTRYPOINT]
        by { reveal pageContentsCorresponds; reveal pageDbDispatcherCorresponds; }

    LDRglobaladdr(r0, CurDispatcherOp());
    LDRglobal(r0, CurDispatcherOp(), r0, 0);
    assert r0 == base;
    assert this.m == old(this).m;

    save_disp_context_helper(r0, dispPg);
    ghost var st0 := this;
    LDR(r1,sp,0);
    assert r1 == gr0;
    STR(r1,r0,const(DISP_CTXT_R0));
    MOV(r1,1);
    STR(r1,r0,const(DISPATCHER_ENTERED));

    pagedb := exPageDb(exceptionHandled(exstate, pagedb_in, dispPg));
    exceptionHandledValidPageDb(ustate, ex, exstate, pagedb_in, dispPg);
    ghost var disp := pagedb[dispPg].entry;
    ghost var ctxt := disp.ctxt;
    ghost var pg := extractPage(this.m, dispPg);
    assert pageDbDispatcherCorresponds(dispPg, disp, pg) by {
        // TODO: figure out how to clean up this disgusting mess of triggers
        // and explicit assertions... later :(
        reveal pageDbDispatcherCorresponds;
        assert pg[base + DISPATCHER_ENTERED] == to_i(true) == to_i(disp.entered);
        assert orig_disp.entrypoint
            == disp.entrypoint
            == pg[base + DISPATCHER_ENTRYPOINT];
        assert pg[base + DISP_CTXT_PC] == old(lr) == OperandContents(exstate, OLR);
        // oh for a calc statement...
        assert pg[base + DISP_CTXT_PSR] == old(spsr_mon)
            == OperandContents(exstate, OSReg(spsr(Monitor)))
            == exstate.sregs[spsr(mode_of_state(exstate))];
        assert ctxt == DispatcherContext(exstate.regs, old(lr), old(spsr_mon));
        assert pg[base + DISP_CTXT_R0] == gr0 == ctxt.regs[R0];
        assert forall a:addr :: pg?[a] && a != base + DISP_CTXT_R0
                && a != base + DISPATCHER_ENTERED
            ==> extractPage(st0.m, dispPg)[a] == pg[a];
        assert forall r :: ValidRegOperand(OReg(r)) && r != R0
            ==> (OperandContents(old(this), OReg(r))
                == OperandContents(exstate, OReg(r)) == ctxt.regs[r]);
        assert pg[base + DISP_CTXT_R1] == old(r1) == ctxt.regs[R1];
        assert pg[base + DISP_CTXT_R2] == old(r2) == ctxt.regs[R2];
        assert pg[base + DISP_CTXT_R3] == old(r3) == ctxt.regs[R3];
        assert pg[base + DISP_CTXT_R4] == old(r4) == ctxt.regs[R4];
        assert pg[base + DISP_CTXT_R5] == old(r5) == ctxt.regs[R5];
        assert pg[base + DISP_CTXT_R6] == old(r6) == ctxt.regs[R6];
        assert pg[base + DISP_CTXT_R7] == old(r7) == ctxt.regs[R7];
        assert pg[base + DISP_CTXT_R8] == old(r8) == ctxt.regs[R8];
        assert pg[base + DISP_CTXT_R9] == old(r9) == ctxt.regs[R9];
        assert pg[base + DISP_CTXT_R10] == old(r10) == ctxt.regs[R10];
        assert pg[base + DISP_CTXT_R11] == old(r11) == ctxt.regs[R11];
        assert pg[base + DISP_CTXT_R12] == old(r12) == ctxt.regs[R12];
        assert pg[base + DISP_CTXT_LR] == old(lr_usr)
            == OperandContents(exstate, OReg(LR(User))) == ctxt.regs[LR(User)];
        assert pg[base + DISP_CTXT_SP] == old(sp_usr)
            == OperandContents(exstate, OReg(SP(User))) == ctxt.regs[SP(User)];
    }

    assert pageDbCorrespondsOnly(this.m, pagedb, dispPg) by {
        assert pageDbEntryCorresponds(pagedb[dispPg],
                                      extractPageDbEntry(this.m, dispPg))
            by { reveal pageDbEntryCorresponds;
                 assert GlobalsInvariant(old(this), this); }
        assert pageContentsCorresponds(dispPg, pagedb[dispPg], pg)
            by { reveal pageContentsCorresponds; }
    }
    AllButOnePagePreserving(dispPg, old(this), this);
    assert pageDbCorresponds(this.m, pagedb);

    MOV(r0, const(KOM_ERR_INTERRUPTED));
    MOV(r1, 0);
}

procedure {:frame false} interrupt_handler(
    inline ex: exception,
    ghost prior_state: state,
    ghost stack_bytes: int,
    ghost pagedb0: PageDb,
    ghost pagedb1: PageDb,
    ghost dispPg: PageNr) returns (ghost pagedb: PageDb)
    reads
        globals; /* spsr_svc; spsr_abt; spsr_und; */ lr_svc; lr_abt; lr_und;
    modifies
        mem; r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; sp; cpsr; lr; spsr_mon;
    requires
        handler_requires(this, stack_bytes);
        stack_bytes >= 2*WORDSIZE;
        ValidState(prior_state);
        ex == ExFIQ || ex == ExIRQ;
        evalExceptionTaken(prior_state, ex, this);
        validPageDb(pagedb0) && validPageDb(pagedb1);
        nonStoppedDispatcher(pagedb0, dispPg);
        if mode_of_state(prior_state) == User
            then pagedb1 == updateUserPagesFromState(prior_state, pagedb0, dispPg)
            else pagedb1 == pagedb0;
        pageDbCorresponds(this.m, pagedb1);
        GlobalFullContents(this.m, CurDispatcherOp()) == seq(page_monvaddr(dispPg));
    ensures
        KomInterruptHandlerInvariant(old(this), pagedb1, this, dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    assert mode_of_state(this) == Monitor
        by { lemma_evalExceptionTaken_Mode(prior_state, ex, this); }
    lemma_update_psr(cpsr_of_state(prior_state), encode_mode(Monitor), true, true);
    assert !interrupts_enabled(this);

    // push r0, r1
    SUB(sp, sp, const(2 * WORDSIZE));
    STR(r0, sp, 0);
    STR(r1, sp, const(WORDSIZE));

    // store pending interrupt
    LDRglobaladdr(r0, PendingInterruptOp());
    MOV(r1, 1);
    STRglobal(r1, PendingInterruptOp(), r0, 0);

    // figure out where we came from
    MRS(r0, spsr_mon);
    AND(r0, r0, 0x1f);
    assert r0 == psr_mask_mode(old(spsr_mon));
    if (r0 == const(encode_mode(User))) { // we came from user-mode
        assert spsr_of_state(old(this)).m == User;
        assert mode_of_state(prior_state) == User;

        // save dispatcher context
        LDR(r1, sp, const(WORDSIZE));
        assert r1 == old(r1);
        lemma_SameMemAndGlobalsPreservesPageDb'(old(this), this, pagedb1);
        pagedb := save_disp_context(prior_state, ex, old(this), dispPg, pagedb1);
        assert tuple(r0, r1, pagedb) == exceptionHandled(old(this), pagedb1, dispPg);

        ADD(sp, sp, const(2 * WORDSIZE));
        assert sp == old(sp);
        ORR(sp, sp, 1);
        assume KomInterruptHandlerInvariant(old(this), pagedb1, this, dispPg); // TODO
    } else { // we came from another exception handler
        assert spsr_of_state(old(this)).m != User;

        // restore r0, r1, sp
        LDR(r0, sp, 0);
        LDR(r1, sp, const(WORDSIZE));
        ADD(sp, sp, const(2 * WORDSIZE));
        assert r0 == old(r0) && r1 == old(r1) && sp == old(sp);

        pagedb := pagedb1;
        lemma_SameMemAndGlobalsPreservesPageDb'(old(this), this, pagedb);
    }

    assert validExceptionTransition(old(this), pagedb1, this, pagedb, dispPg)
        by { reveal_validExceptionTransition(); }
}
