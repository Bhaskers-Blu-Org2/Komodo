include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"
include {:verbatim} "entry.i.dfy"
include {:verbatim} "entrybits.i.dfy"

include "valedecls.vad"
include "kom_utils.vad"

#verbatim
lemma lemma_userspaceExecutionFn_ok(s:state, pc:word)
    requires ValidState(s) && s.ok && mode_of_state(s) == User
    requires ExtractAbsPageTable(s).Just?
    ensures userspaceExecutionFn(s, pc).0.ok
{
    reveal userspaceExecutionFn();
}

lemma lemma_evalMOVSPCLRUC_ok(s:state, r:state)
    requires ValidInstruction(s, MOVS_PCLR_TO_USERMODE_AND_CONTINUE()) && s.ok
    requires UsermodeContinuationPrecondition(s)
    requires evalMOVSPCLRUC(s, r)
    ensures r.ok
{
    var pc := OperandContents(s, OLR);
    reveal evalMOVSPCLRUC();
    assert ExtractAbsPageTable(s).Just?;
    var s2, s4 :|
        evalEnterUserspace(s, s2)
        && (lemma_evalEnterUserspace_preservesAbsPageTable(s, s2);
        var (s3, pc, ex) := userspaceExecutionFn(s2, pc);
        evalExceptionTaken(s3, ex, pc, s4)
        && UsermodeContinuationInvariant(s4, r));
    assert s2.ok;
    lemma_userspaceExecutionFn_ok(s2, pc);
    assert s4.ok;
}
#endverbatim

procedure {:frame false} {:instruction Ins(MOVS_PCLR_TO_USERMODE_AND_CONTINUE)}
MOVS_PCLR_TO_USERMODE_AND_CONTINUE()
    requires/ensures
        this.ok;
    requires
        !interrupts_enabled(this);
        ValidModeChange'(this, User);
        spsr_of_state(this).m == User;
        UsermodeContinuationPrecondition(takestep(this));
    ensures
        evalMOVSPCLRUC(takestep(old(this)), this);
{
    assert ValidInstruction(old(this), MOVS_PCLR_TO_USERMODE_AND_CONTINUE());
    assert evalIns(MOVS_PCLR_TO_USERMODE_AND_CONTINUE(), old(this), this)
        by { reveal va_eval; }
    ghost var s1 := takestep(old(this));
    assert evalIns'(MOVS_PCLR_TO_USERMODE_AND_CONTINUE(), s1, this);
    assert ValidInstruction(s1, MOVS_PCLR_TO_USERMODE_AND_CONTINUE());
    assert evalMOVSPCLRUC(s1, this) by { reveal va_eval; }
    lemma_evalMOVSPCLRUC_ok(s1, this);
}

#verbatim
const BANKED_FRAME_WORDS:int := 18;
const BANKED_FRAMESIZE:int := BANKED_FRAME_WORDS*WORDSIZE;

predicate {:opaque} wellformed_banked_regs_stackframe(m:memstate, a:addr)
    requires ValidMemState(m)
{
    ValidMemWords(a, BANKED_FRAME_WORDS)
    && forall i:int | 12 <= i <= 17 ::
        ValidPsrWord(MemContents(m, WordOffset(a, i)))
}

lemma lemma_wellformed_banked_regs_stackframe_preserved(m1:memstate, m2:memstate, a:addr)
    requires ValidMemState(m1) && ValidMemState(m2)
    requires wellformed_banked_regs_stackframe(m1, a)
    requires forall p:addr :: ValidMem(p) && (a <= p < a + BANKED_FRAMESIZE)
        ==> MemContents(m1, p) == MemContents(m2, p)
    ensures wellformed_banked_regs_stackframe(m2, a)
{
    reveal wellformed_banked_regs_stackframe();
    forall i:int | 12 <= i <= 17
        ensures ValidPsrWord(MemContents(m2, WordOffset(a, i)));
    {
        assert MemContents(m1, WordOffset(a, i)) == MemContents(m2, WordOffset(a, i));
    }
}

predicate {:opaque} banked_regs_stackframe(s:state, m:memstate, a:addr)
    requires ValidState(s) && ValidMemState(m)
    ensures banked_regs_stackframe(s,m,a) ==> wellformed_banked_regs_stackframe(m, a)
{
    reveal ValidRegState();
    reveal ValidSRegState();
    reveal wellformed_banked_regs_stackframe();

    wellformed_banked_regs_stackframe(m, a)
    && MemContents(m, WordOffset(a, 0))  == s.regs[SP(User)]
    && MemContents(m, WordOffset(a, 1))  == s.regs[SP(FIQ)]
    && MemContents(m, WordOffset(a, 2))  == s.regs[SP(IRQ)]
    && MemContents(m, WordOffset(a, 3))  == s.regs[SP(Supervisor)]
    && MemContents(m, WordOffset(a, 4))  == s.regs[SP(Abort)]
    && MemContents(m, WordOffset(a, 5))  == s.regs[SP(Undefined)]

    && MemContents(m, WordOffset(a, 6))  == s.regs[LR(User)]
    && MemContents(m, WordOffset(a, 7))  == s.regs[LR(FIQ)]
    && MemContents(m, WordOffset(a, 8))  == s.regs[LR(IRQ)]
    && MemContents(m, WordOffset(a, 9))  == s.regs[LR(Supervisor)]
    && MemContents(m, WordOffset(a, 10)) == s.regs[LR(Abort)]
    && MemContents(m, WordOffset(a, 11)) == s.regs[LR(Undefined)]

    && MemContents(m, WordOffset(a, 12)) == s.sregs[spsr(FIQ)]
    && MemContents(m, WordOffset(a, 13)) == s.sregs[spsr(IRQ)]
    && MemContents(m, WordOffset(a, 14)) == s.sregs[spsr(Supervisor)]
    && MemContents(m, WordOffset(a, 15)) == s.sregs[spsr(Abort)]
    && MemContents(m, WordOffset(a, 16)) == s.sregs[spsr(Undefined)]
    && MemContents(m, WordOffset(a, 17)) == s.sregs[spsr(Monitor)]
}

lemma lemma_stackunstack_banked_regs(s1:state, m1:memstate, s2:state, m2:memstate, a:addr)
    requires SaneState(s1) && ValidMemState(m1) && SaneState(s2) && ValidMemState(m2)
    requires banked_regs_stackframe(s1, m1, a) && banked_regs_stackframe(s2, m2, a)
    requires forall p:addr :: ValidMem(p) && (a <= p < a + BANKED_FRAMESIZE)
        ==> MemContents(m1, p) == MemContents(m2, p)
    ensures BankedRegsInvariant(s1, s2) && SpsrsInvariant(s1, s2)
{
    reveal wellformed_banked_regs_stackframe();

    // sigh. help Dafny see that we're enumerating all constructors of a datatype
    assert forall m:mode {:trigger SP(m)} {:trigger LR(m)} {:trigger spsr(m)} ::
        m.User? || m.FIQ? || m.IRQ? || m.Supervisor? || m.Abort? || m.Undefined?
        || m.Monitor?;

    assert BankedRegsInvariant(s1, s2) by {
        reveal ValidRegState();
        forall m | m != Monitor
            ensures s1.regs[SP(m)] == s2.regs[SP(m)] && s1.regs[LR(m)] == s2.regs[LR(m)]
            { reveal banked_regs_stackframe(); }
    }

    assert SpsrsInvariant(s1, s2) by {
        reveal ValidSRegState();
        forall m | m != User
            ensures s1.sregs[spsr(m)] == s2.sregs[spsr(m)]
            { reveal banked_regs_stackframe(); }
    }
}
#endverbatim

procedure stack_banked_regs1(out operand tmp:reg)
    requires/ensures
        SaneState(this);
    requires
        @tmp != OSP;
        sp + BANKED_FRAMESIZE <= StackBase();
        ValidMem(WordOffset(sp, 12));
        ValidMem(WordOffset(sp, 13));
        ValidMem(WordOffset(sp, 14));
        ValidMem(WordOffset(sp, 15));
        ValidMem(WordOffset(sp, 16));
        ValidMem(WordOffset(sp, 17));
    reads
        sp;
        spsr_fiq; spsr_irq; spsr_svc; spsr_abt; spsr_und; spsr_mon;
    modifies
        mem;
    ensures
        MemPreservingExcept(old(this), this, WordOffset(sp, 12), WordOffset(sp, 18));
        sp == old(sp);
        MemContents(this.m, WordOffset(sp, 12)) == spsr_fiq;
        MemContents(this.m, WordOffset(sp, 13)) == spsr_irq;
        MemContents(this.m, WordOffset(sp, 14)) == spsr_svc;
        MemContents(this.m, WordOffset(sp, 15)) == spsr_abt;
        MemContents(this.m, WordOffset(sp, 16)) == spsr_und;
        MemContents(this.m, WordOffset(sp, 17)) == spsr_mon;
{
    MRS_STR(spsr_fiq, sp, const(WordsToBytes(12)), tmp);
    MRS_STR(spsr_irq, sp, const(WordsToBytes(13)), tmp);
    MRS_STR(spsr_svc, sp, const(WordsToBytes(14)), tmp);
    MRS_STR(spsr_abt, sp, const(WordsToBytes(15)), tmp);
    MRS_STR(spsr_und, sp, const(WordsToBytes(16)), tmp);
    MRS_STR(spsr_mon, sp, const(WordsToBytes(17)), tmp);
}

procedure stack_banked_regs2(out operand tmp:reg)
    requires/ensures
        SaneState(this);
    requires
        @tmp != OSP;
        sp + BANKED_FRAMESIZE <= StackBase();
        ValidMem(WordOffset(sp, 0));
        ValidMem(WordOffset(sp, 1));
        ValidMem(WordOffset(sp, 2));
        ValidMem(WordOffset(sp, 3));
        ValidMem(WordOffset(sp, 4));
        ValidMem(WordOffset(sp, 5));
    reads
        sp;
        sp_usr; sp_fiq; sp_irq; sp_svc; sp_abt; sp_und;
    modifies
        mem;
    ensures
        MemPreservingExcept(old(this), this, WordOffset(sp, 0), WordOffset(sp, 6));
        sp == old(sp);
        MemContents(this.m, WordOffset(sp, 0)) == sp_usr;
        MemContents(this.m, WordOffset(sp, 1)) == sp_fiq;
        MemContents(this.m, WordOffset(sp, 2)) == sp_irq;
        MemContents(this.m, WordOffset(sp, 3)) == sp_svc;
        MemContents(this.m, WordOffset(sp, 4)) == sp_abt;
        MemContents(this.m, WordOffset(sp, 5)) == sp_und;
{
    MRS_STR(sp_usr, sp, const(WordsToBytes(0)), tmp);
    MRS_STR(sp_fiq, sp, const(WordsToBytes(1)), tmp);
    MRS_STR(sp_irq, sp, const(WordsToBytes(2)), tmp);
    MRS_STR(sp_svc, sp, const(WordsToBytes(3)), tmp);
    MRS_STR(sp_abt, sp, const(WordsToBytes(4)), tmp);
    MRS_STR(sp_und, sp, const(WordsToBytes(5)), tmp);
}

procedure stack_banked_regs3(out operand tmp:reg)
    requires/ensures
        SaneState(this);
    requires
        @tmp != OSP;
        sp + BANKED_FRAMESIZE <= StackBase();
        ValidMem(WordOffset(sp, 6));
        ValidMem(WordOffset(sp, 7));
        ValidMem(WordOffset(sp, 8));
        ValidMem(WordOffset(sp, 9));
        ValidMem(WordOffset(sp, 10));
        ValidMem(WordOffset(sp, 11));
    reads
        sp;
        lr_usr; lr_fiq; lr_irq; lr_svc; lr_abt; lr_und;
    modifies
        mem;
    ensures
        MemPreservingExcept(old(this), this, WordOffset(sp, 6), WordOffset(sp, 12));
        sp == old(sp);
        MemContents(this.m, WordOffset(sp, 6)) == lr_usr;
        MemContents(this.m, WordOffset(sp, 7)) == lr_fiq;
        MemContents(this.m, WordOffset(sp, 8)) == lr_irq;
        MemContents(this.m, WordOffset(sp, 9)) == lr_svc;
        MemContents(this.m, WordOffset(sp, 10)) == lr_abt;
        MemContents(this.m, WordOffset(sp, 11)) == lr_und;
{
    MRS_STR(lr_usr, sp, const(WordsToBytes(6)), tmp);
    MRS_STR(lr_fiq, sp, const(WordsToBytes(7)), tmp);
    MRS_STR(lr_irq, sp, const(WordsToBytes(8)), tmp);
    MRS_STR(lr_svc, sp, const(WordsToBytes(9)), tmp);
    MRS_STR(lr_abt, sp, const(WordsToBytes(10)), tmp);
    MRS_STR(lr_und, sp, const(WordsToBytes(11)), tmp);
}

procedure stack_banked_regs(out operand tmp:reg, ghost stack_bytes_in:int)
          returns (ghost stack_bytes:int)
    requires/ensures
        SaneState(this);
    requires
        @tmp != OSP;
        stack_bytes_in >= BANKED_FRAMESIZE;
        StackBytesRemaining(this, stack_bytes_in);
    reads
        spsr_fiq; spsr_irq; spsr_svc; spsr_abt; spsr_und; spsr_mon;
        sp_usr; sp_fiq; sp_irq; sp_svc; sp_abt; sp_und;
        lr_usr; lr_fiq; lr_irq; lr_svc; lr_abt; lr_und;
    modifies
        mem; sp;
    ensures
        sp == old(sp)-BANKED_FRAMESIZE;
        stack_bytes == stack_bytes_in-BANKED_FRAMESIZE;
        StackBytesRemaining(this,stack_bytes);
        banked_regs_stackframe(old(this), this.m, sp);
        NonStackMemPreserving(old(this),this);
        ParentStackPreserving(old(this),this);
{
    SUB(sp, sp, const(BANKED_FRAMESIZE));
    stack_bytes := stack_bytes_in - BANKED_FRAMESIZE;

    stack_banked_regs1(tmp);

    assert wellformed_banked_regs_stackframe(this.m, sp)
        by { reveal ValidSRegState; reveal wellformed_banked_regs_stackframe; }

    stack_banked_regs2(tmp);
    stack_banked_regs3(tmp);

    assert wellformed_banked_regs_stackframe(this.m, sp)
        by { reveal wellformed_banked_regs_stackframe; }
    assert banked_regs_stackframe(old(this), this.m, sp)
        by { reveal banked_regs_stackframe; }
}

procedure LDR_MSR_banked(
    out operand reg:sreg,
    operand base:word,
    operand ofs:word,
    out operand tmp:reg)
    requires/ensures
        SaneState(this);
    requires
        ValidBankedRegOperand(this, @reg) && @reg is OReg && @reg != OReg(SP(Monitor));
        ValidMem(base + ofs);
        @tmp != OSP && @tmp != @base && @tmp != @ofs;
    reads
        mem;
    ensures
        //CoreRegPreservingExcept(old(this), this, set(@tmp));
        forall r:ARMReg :: ((r is SP && r.spm != Monitor) || (r is LR && r.lrm != Monitor)) && r != @reg.r ==> this.regs[r] == old(this).regs[r];
        //sp == old(sp);
        SRegsInvariant(old(this), this);
        reg == MemContents(old(this.m), old(base+ofs));
{
    LDR(tmp, base, ofs);
    MSR(reg, tmp);
}

procedure LDR_MSR_spsr(
    out operand reg:sreg,
    operand base:word,
    ghost wofs:word,
    operand ofs:word,
    out operand tmp:reg)
    requires/ensures
        SaneState(this);
    requires
        @reg is OSReg && @reg.sr is spsr;
        @tmp != OSP && @tmp != @base;
        ValidMem(base) && wellformed_banked_regs_stackframe(this.m, base);
        12 <= wofs <= 17;
        @ofs is OConst;
        ofs == WordsToBytes(wofs);
    reads
        mem;
    ensures
        //sp == old(sp);
        //CoreRegPreservingExcept(old(this),this,set(@tmp));
        BankedRegsInvariant(old(this),this);
        forall sr :: this.sregs?[sr] && old(this).sregs?[sr] && sr != @reg.sr
            ==> this.sregs[sr] == old(this).sregs[sr];
        old(isUInt32(base + WordsToBytes(wofs)) && ValidMem(WordOffset(base, wofs)));
        reg == MemContents(old(this.m), old(WordOffset(base, wofs)));
{
    ghost var a := base + WordsToBytes(wofs);
    assert isUInt32(a) && a == WordOffset(base, wofs) && ValidMem(a)
        && ValidPsrWord(MemContents(this.m, a))
        by { reveal wellformed_banked_regs_stackframe; }
    LDR(tmp, base, ofs);
    MSR(reg, tmp);
}

procedure unstack_banked_regs1(out operand tmp:reg)
    requires/ensures
        SaneState(this);
    requires
        @tmp != OSP;
        sp + BANKED_FRAMESIZE <= StackBase();
        wellformed_banked_regs_stackframe(this.m, sp);
        ValidMem(WordOffset(sp, 0));
        ValidMem(WordOffset(sp, 1));
        ValidMem(WordOffset(sp, 2));
        ValidMem(WordOffset(sp, 3));
        ValidMem(WordOffset(sp, 4));
        ValidMem(WordOffset(sp, 5));
    reads
        sp;
        mem;
    modifies
        sp_usr; sp_fiq; sp_irq; sp_svc; sp_abt; sp_und;
    ensures
        sp == old(sp);
        MemContents(this.m, WordOffset(sp, 0)) == sp_usr;
        MemContents(this.m, WordOffset(sp, 1)) == sp_fiq;
        MemContents(this.m, WordOffset(sp, 2)) == sp_irq;
        MemContents(this.m, WordOffset(sp, 3)) == sp_svc;
        MemContents(this.m, WordOffset(sp, 4)) == sp_abt;
        MemContents(this.m, WordOffset(sp, 5)) == sp_und;
{
    LDR_MSR_banked(sp_usr, sp, const(WordsToBytes(0)), tmp);
    LDR_MSR_banked(sp_fiq, sp, const(WordsToBytes(1)), tmp);
    LDR_MSR_banked(sp_irq, sp, const(WordsToBytes(2)), tmp);
    LDR_MSR_banked(sp_svc, sp, const(WordsToBytes(3)), tmp);
    LDR_MSR_banked(sp_abt, sp, const(WordsToBytes(4)), tmp);
    LDR_MSR_banked(sp_und, sp, const(WordsToBytes(5)), tmp);
}

procedure unstack_banked_regs2(out operand tmp:reg)
    requires/ensures
        SaneState(this);
    requires
        @tmp != OSP;
        sp + BANKED_FRAMESIZE <= StackBase();
        wellformed_banked_regs_stackframe(this.m, sp);
        ValidMem(WordOffset(sp, 6));
        ValidMem(WordOffset(sp, 7));
        ValidMem(WordOffset(sp, 8));
        ValidMem(WordOffset(sp, 9));
        ValidMem(WordOffset(sp, 10));
        ValidMem(WordOffset(sp, 11));
    reads
        sp;
        mem;
    modifies
        lr_usr; lr_fiq; lr_irq; lr_svc; lr_abt; lr_und;
    ensures
        sp == old(sp);
        MemContents(this.m, WordOffset(sp, 6)) == lr_usr;
        MemContents(this.m, WordOffset(sp, 7)) == lr_fiq;
        MemContents(this.m, WordOffset(sp, 8)) == lr_irq;
        MemContents(this.m, WordOffset(sp, 9)) == lr_svc;
        MemContents(this.m, WordOffset(sp, 10)) == lr_abt;
        MemContents(this.m, WordOffset(sp, 11)) == lr_und;
{
    LDR_MSR_banked(lr_usr, sp, const(WordsToBytes(6)), tmp);
    LDR_MSR_banked(lr_fiq, sp, const(WordsToBytes(7)), tmp);
    LDR_MSR_banked(lr_irq, sp, const(WordsToBytes(8)), tmp);
    LDR_MSR_banked(lr_svc, sp, const(WordsToBytes(9)), tmp);
    LDR_MSR_banked(lr_abt, sp, const(WordsToBytes(10)), tmp);
    LDR_MSR_banked(lr_und, sp, const(WordsToBytes(11)), tmp);
}

procedure unstack_banked_regs3(out operand tmp:reg)
    requires/ensures
        SaneState(this);
    requires
        @tmp != OSP;
        sp + BANKED_FRAMESIZE <= StackBase();
        wellformed_banked_regs_stackframe(this.m, sp);
        ValidMem(WordOffset(sp, 12));
        ValidMem(WordOffset(sp, 13));
        ValidMem(WordOffset(sp, 14));
        ValidMem(WordOffset(sp, 15));
        ValidMem(WordOffset(sp, 16));
        ValidMem(WordOffset(sp, 17));
    reads
        sp;
        mem;
    modifies
        spsr_fiq; spsr_irq; spsr_svc; spsr_abt; spsr_und; spsr_mon;
    ensures
        sp == old(sp);
        MemContents(this.m, WordOffset(sp, 12)) == spsr_fiq;
        MemContents(this.m, WordOffset(sp, 13)) == spsr_irq;
        MemContents(this.m, WordOffset(sp, 14)) == spsr_svc;
        MemContents(this.m, WordOffset(sp, 15)) == spsr_abt;
        MemContents(this.m, WordOffset(sp, 16)) == spsr_und;
        MemContents(this.m, WordOffset(sp, 17)) == spsr_mon;
{
    LDR_MSR_spsr(spsr_fiq, sp, 12, const(WordsToBytes(12)), tmp);
    LDR_MSR_spsr(spsr_irq, sp, 13, const(WordsToBytes(13)), tmp);
    LDR_MSR_spsr(spsr_svc, sp, 14, const(WordsToBytes(14)), tmp);
    LDR_MSR_spsr(spsr_abt, sp, 15, const(WordsToBytes(15)), tmp);
    LDR_MSR_spsr(spsr_und, sp, 16, const(WordsToBytes(16)), tmp);
    LDR_MSR_spsr(spsr_mon, sp, 17, const(WordsToBytes(17)), tmp);
}
procedure unstack_banked_regs(out operand tmp:reg, ghost stack_bytes_in:int)
          returns (ghost stack_bytes:int)
    requires/ensures
        SaneState(this);
    requires
        @tmp == OReg(R2); //@tmp != OSP;
        
        isUInt32(sp + BANKED_FRAMESIZE);
        sp + BANKED_FRAMESIZE <= StackBase();
        StackBytesRemaining(this, stack_bytes_in);
        wellformed_banked_regs_stackframe(this.m, sp);
    reads
        mem;
    modifies
        sp;
        spsr_fiq; spsr_irq; spsr_svc; spsr_abt; spsr_und; spsr_mon;
        sp_usr; sp_fiq; sp_irq; sp_svc; sp_abt; sp_und;
        lr_usr; lr_fiq; lr_irq; lr_svc; lr_abt; lr_und;
    ensures
        sp == old(sp)+BANKED_FRAMESIZE;
        stack_bytes == stack_bytes_in + BANKED_FRAMESIZE;
        StackBytesRemaining(this, stack_bytes);
        banked_regs_stackframe(this, old(this.m), old(sp));
        //CoreRegPreservingExcept(old(this), this, set(@tmp,@sp));
{
    unstack_banked_regs1(tmp);
    unstack_banked_regs2(tmp);
    assert this.m == old(this.m);
    unstack_banked_regs3(tmp);

    reveal banked_regs_stackframe;
    assert sp == old(sp)
        && banked_regs_stackframe(this, old(this.m), old(sp));
    assert {:split_here} true;

    ADD(sp, sp, const(BANKED_FRAMESIZE));
    stack_bytes := stack_bytes_in + BANKED_FRAMESIZE;
}

procedure smc_enter_err(
    operand callno:reg,
    operand pagenr:reg,
    operand pagedb_base:reg,
    out operand err:reg,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        @callno == @err == OReg(R0) && @pagenr == OReg(R1);
        @pagedb_base == OReg(R12) && pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        callno == KOM_SMC_ENTER || callno == KOM_SMC_RESUME;
    reads
        globals; mem;
    modifies
        r8; r9; r10; r11;
    ensures
        SmcProcedureInvariant(old(this), this);
        err == smc_enter_err(pagedb, old(pagenr), old(callno) == KOM_SMC_RESUME);
{
    if (pagenr >= const(KOM_SECURE_NPAGES)) {
        assert !validPageNr(pagenr);
        MOV(err, const(KOM_ERR_INVALID_PAGENO));
    } else {
        assert validPageNr(pagenr);
        load_page_type(pagenr, pagedb_base, r10, r9, pagedb);
        if( r9 != const(KOM_PAGE_DISPATCHER) ) {
            assert !(pagedb[pagenr] is PageDbEntryTyped && pagedb[pagenr].entry is Dispatcher);
            MOV(err, const(KOM_ERR_INVALID_PAGENO));
        } else {
            assert pagedb[pagenr] is PageDbEntryTyped && pagedb[pagenr].entry is Dispatcher;

            ADD(r10, r10, const(PAGEDB_ENTRY_ADDRSPACE));
            assert r10 == WordAlignedAdd(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE);

            LDRglobal(r8, PageDb(), pagedb_base, r10);
            ghost var addrspace := pagedb[pagenr].addrspace;
            assert validPageNr(addrspace) by { reveal validPageDb; }
            assert r8 == page_monvaddr(addrspace) && WordAligned(r8) by {
                reveal pageDbEntryCorresponds;
                reveal validPageDb;
                assert pageDbCorrespondsOnly(this.m, pagedb, pagenr);
                ghost var entryWords := extractPageDbEntry(this.m, pagenr);
                assert entryWords[BytesToWords(PAGEDB_ENTRY_ADDRSPACE)] == 
                    page_monvaddr(pagedb[pagenr].addrspace);
                               
                extractPageDbToAbstractOne(this.m, pagenr, PAGEDB_ENTRY_ADDRSPACE);

                assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE;
                assert entryWords[BytesToWords(PAGEDB_ENTRY_ADDRSPACE)] ==
                    GlobalWord(this.m, PageDb(), r10);
                assert GlobalWord(this.m, PageDb(), r10) == 
                    page_monvaddr(pagedb[pagenr].addrspace);
            }
            lemma_WordAlignedAdd(r8,ADDRSPACE_STATE);

            assert ValidMem(r8 + ADDRSPACE_STATE) by { reveal validPageDb; }
            LDR(r8, r8, const(ADDRSPACE_STATE));
            assert r8 == KOM_ADDRSPACE_FINAL
                <==> pagedb[addrspace].entry.state == FinalState
            by {
                reveal validPageDb;
                reveal pageContentsCorresponds;
                reveal pageDbAddrspaceCorresponds;
            }

            if( r8 != const(KOM_ADDRSPACE_FINAL) ) {
                MOV(err, const(KOM_ERR_NOT_FINAL));
            } else {
                assert this.m == old(this.m);
                assert SaneState(this);
                page_monvaddr_impl(r9,pagenr,r10);
                assert r9 == page_monvaddr(pagenr);
                assert MemContents(this.m, page_monvaddr(pagenr) + 
                    DISPATCHER_ENTERED) == to_i(pagedb[pagenr].entry.entered)
                by {
                    reveal pageContentsCorresponds;
                    reveal pageDbDispatcherCorresponds;
                }
                LDR(r9,r9,const(DISPATCHER_ENTERED));
                
                assert r9 == 1 <==> pagedb[pagenr].entry.entered;

                assert callno == old(callno);
                if (callno == const(KOM_SMC_RESUME)) {
                    // smc_resume
                    if( r9 != 1 ) {
                        MOV(err, const(KOM_ERR_NOT_ENTERED));
                    } else {
                        MOV(err, const(KOM_ERR_SUCCESS));
                    }
                } else {
                    // smc_enter
                    if( r9 == 1 ) {
                        MOV(err, const(KOM_ERR_ALREADY_ENTERED));
                    } else {
                        MOV(err, const(KOM_ERR_SUCCESS));
                    }
                }
            }
        }
    }
}

#verbatim
lemma lemma_PageAligned_PageBase(x:word, y:word)
    requires PageAligned(x)
    requires y == BitwiseOr(x, 0x6a)
    ensures PageBase(y) == x
{
    assert WordAsBits(0x6a) == 0x6a by { reveal WordAsBits(); }
    lemma_BitsAndWordConversions();

    calc {
        PageBase(BitwiseOr(x, 0x6a));
        { reveal PageBase(); }
        BitwiseMaskHigh(BitwiseOr(x, 0x6a), PAGEBITS);
        { reveal BitwiseMaskHigh(); }
        BitsAsWord(BitAnd(BitOr(WordAsBits(x), 0x6a), BitmaskHigh(PAGEBITS)));
        { lemma_Bitmask12(); }
        BitsAsWord(BitAnd(BitOr(WordAsBits(x), 0x6a), 0xfffff000));
        { lemma_BitOrAndRelation(WordAsBits(x), 0x6a, 0xfffff000); }
        BitsAsWord(BitOr(BitAnd(WordAsBits(x), 0xfffff000), BitAnd(0x6a, 0xfffff000)));
        { reveal BitAnd(); }
        BitsAsWord(BitOr(BitAnd(WordAsBits(x), 0xfffff000), 0));
        { reveal BitOr(); }
        BitsAsWord(BitAnd(WordAsBits(x), 0xfffff000));
        { lemma_Bitmask12(); }
        BitsAsWord(BitAnd(WordAsBits(x), BitmaskHigh(PAGEBITS)));
        { reveal BitwiseMaskHigh(); }
        BitwiseMaskHigh(x, PAGEBITS);
        {
            assert PageBase(x) == x / PAGESIZE * PAGESIZE by { reveal PageBase(); }
            reveal PageAligned();
        }
        x;
    }
}
#endverbatim

procedure switch_addrspace(
    operand pagenr:reg,
    operand pagedb_base:reg,
    ghost isresume:bool,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        @pagenr == OReg(R1);
        @pagedb_base == OReg(R12) && pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validPageNr(pagenr);
        validDispatcherPage(pagedb, pagenr);
        !hasStoppedAddrspace(pagedb, pagenr);
    reads
        globals; mem;
    modifies
        scr; ttbr0; /* tlbiasid; */ r10; r11;
    ensures
        BankedRegsInvariant(old(this),this);
        this.conf.ttbr0.ptbase == page_paddr(l1pOfDispatcher(pagedb, old(pagenr)));
        this.conf.scr == SCRT(Secure, true, true);
{
    //-------------------------------------------------------------------------
    // update SCR
    //-------------------------------------------------------------------------

    // read SCR
    MRC(r10, scr);
    ghost var old_scr := r10;

    // clear NS bit
    AND(r10, r10, 0xfffffffe);

    // set IRQ and FIQ bits
    ORR(r10, r10, 6);

    // write SCR
    lemma_scr_entry(old_scr, r10);
    MCR(scr, r10);
    assert this.conf.scr.ns == Secure;

    //-------------------------------------------------------------------------
    // load l1p into ttbr0
    //-------------------------------------------------------------------------
    ghost var addrspace := pagedb[pagenr].addrspace;
    assert validAddrspacePage(pagedb, addrspace) by { reveal validPageDb; }
    ghost var l1p := l1pOfDispatcher(pagedb, pagenr);

    lemma_LeftShift3(pagenr);
    LSL(r10, pagenr, const(PAGEDB_ENTRY_SHIFT));
    assert r10 == G_PAGEDB_ENTRY(pagenr);
    ADD(r10, r10, const(PAGEDB_ENTRY_ADDRSPACE)); 
    assert r10 == WordAlignedAdd(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE);

    LDRglobal(r11, PageDb(), pagedb_base, r10);
    assert r11 == page_monvaddr(addrspace) by {
        reveal pageDbEntryCorresponds;
        assert validAddrspacePage(pagedb, addrspace);
    }

    LDR(r10,r11,const(ADDRSPACE_L1PT_PHYS));

    assert r10 == page_paddr(pagedb[addrspace].entry.l1ptnr) by {
        assert pageDbAddrspaceCorresponds(addrspace, pagedb[addrspace].entry,
            extractPage(this.m, addrspace))
        by {
            assert validAddrspacePage(pagedb, addrspace);
            assert pageDbCorrespondsOnly(this.m, pagedb, addrspace);
            reveal pageContentsCorresponds;
        }
        reveal pageDbAddrspaceCorresponds;
    }

    assert r10 == page_paddr(l1p);
    ORR(r10, r10, 0x6a); // magic low bits ==> use cache for PT walks
    MCR(ttbr0, r10);
    assert this.conf.ttbr0.ptbase == page_paddr(l1p) by {
        assert this.conf.ttbr0.ptbase == PageBase(r10);
        assert r10 == BitwiseOr(page_paddr(l1p), 0x6a);
        lemma_PageAligned_PageBase(page_paddr(l1p), r10);
    }

    // flush non-global TLB entries with ASID 0 (the only one we use)
    // (this code is now in the printer, in lieu of a trusted spec)
    //MOV(r10, 0);
    //MCR(tlbiasid, r10);
}

procedure leave_secure_world(out operand tmp:reg)
    requires/ensures
        SaneState(this);
    requires
        @tmp != OSP;
    modifies
        scr;
    ensures
        //BankedRegsInvariant(old(this),this);
        //SpsrsInvariant(old(this), this);
        this.conf.scr.ns == NotSecure && !this.conf.scr.irq && !this.conf.scr.fiq;
{
    // read SCR
    MRC(tmp, scr);
    ghost var old_scr := tmp;

    // clear IRQ and FIQ bits
    AND(tmp, tmp, 0xfffffff9);

    // set NS bit
    ORR(tmp, tmp, 1);

    // write SCR
    lemma_scr_exit(old_scr, tmp);
    MCR(scr, tmp);
}

procedure pre_entry_enter(
    operand pagenr:reg,
    operand arg1:reg,
    operand arg2:reg,
    operand arg3:reg,
    operand pagedb_base:reg,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        @pagenr == OReg(R1) && @arg1 == OReg(R2) && @arg2 == OReg(R3) && @arg3 == OReg(R4);
        @pagedb_base == OReg(R12) && pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        smc_enter_err(pagedb, pagenr, false) == KOM_ERR_SUCCESS;
    reads
        mem;
    modifies
        globals; scr; ttbr0; /* tlbiasid; */ spsr_mon;
        r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr; lr_usr; sp_usr;
    ensures
        GlobalsPreservingExcept(old(this), this, set(CurDispatcherOp()));
        GlobalWord(this.m, CurDispatcherOp(), 0) == page_monvaddr(old(pagenr));
        pageDbCorresponds(this.m, pagedb);
        StackPreserving(old(this), this);
        //BankedRegsInvariant(old(this), this);
        preEntryEnter(old(this), this, pagedb, old(pagenr), old(arg1), old(arg2), old(arg3));
        spsr_of_state(this).m == User;
        this.conf.scr == SCRT(Secure, true, true);
        !spsr_of_state(this).i && !spsr_of_state(this).f;
        //sp == old(sp);
{
    assert validPageNr(pagenr);
    assert validDispatcherPage(pagedb, pagenr);
    assert !hasStoppedAddrspace(pagedb, pagenr);
    ghost var l1p := l1pOfDispatcher(pagedb, pagenr);

    //-------------------------------------------------------------------------
    //  Switch addrspace
    //-------------------------------------------------------------------------
    switch_addrspace(pagenr, pagedb_base, false, pagedb);
    assert pagenr == old(pagenr);

    //-------------------------------------------------------------------------
    // Set SPSR to Usermode
    //-------------------------------------------------------------------------
    MOV(r10, 0x10);
    assert psr_mask_mode(0x10) == 0x10 by {
        assert WordAsBits(0x10) == 0x10 && WordAsBits(0x1f) == 0x1f
            by { reveal WordAsBits; }
        assert BitAnd(0x10, 0x1f) == 0x10 by { reveal BitAnd; }
        lemma_WordBitEquiv(0x10, 0x10);
    }
    assert BitwiseAnd(0x10, ARM_PSR_FIQ) == 0x00 by {
        assert WordAsBits(0x10) == 0x10 && WordAsBits(0x40) == 0x40
            by { reveal WordAsBits; }
        assert BitAnd(0x10, 0x40) == 0x00 by { reveal BitAnd; }
        lemma_WordBitEquiv(0x00, 0x00);
    }
    assert BitwiseAnd(0x10, ARM_PSR_IRQ) == 0x00 by {
        assert WordAsBits(0x10) == 0x10 && WordAsBits(0x80) == 0x80
            by { reveal WordAsBits; }
        assert BitAnd(0x10, 0x80) == 0x00 by { reveal BitAnd; }
        lemma_WordBitEquiv(0x00, 0x00);
    }
    assert decode_mode(psr_mask_mode(r10)) == User;
    assert ValidModeChange'(this, User);
    assert ValidModeChange(this, r10);
    MSR(spsr_mon, r10);
    assert spsr_of_state(this).m == User;
    assert !spsr_of_state(this).i && !spsr_of_state(this).f;
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Load entrypoint into LR
    //-------------------------------------------------------------------------
    page_monvaddr_impl(r10,pagenr,r11);
    LDR(lr,r10,const(DISPATCHER_ENTRYPOINT));
    assert lr == pagedb[pagenr].entry.entrypoint
    by {
        assert pageDbCorrespondsOnly(this.m,pagedb,pagenr);
        assert validDispatcherPage(pagedb,pagenr);
        reveal pageContentsCorresponds;
        assert pageContentsCorresponds(pagenr,pagedb[pagenr],
            extractPage(this.m,pagenr));
        reveal pageDbDispatcherCorresponds;
    }

    //-------------------------------------------------------------------------
    // Update current dispatcher
    //-------------------------------------------------------------------------
    LDRglobaladdr(r12, CurDispatcherOp());
    STRglobal(r10, CurDispatcherOp(), r12, 0);

    //-------------------------------------------------------------------------
    //  Move arguments to regs, zero the rest
    //-------------------------------------------------------------------------
    MOV(r0, arg1);
    MOV(r1, arg2);
    MOV(r2, arg3);
    MOV(r3, 0);
    MOV(r4, 0);
    MOV(r5, 0);
    MOV(r6, 0);
    MOV(r7, 0);
    MOV(r8, 0);
    MOV(r9, 0);
    MOV(r10, 0);
    MOV(r11, 0);
    MOV(r12, 0);
    MSR(sp_usr, r12);
    MSR(lr_usr, r12);

    //-------------------------------------------------------------------------
    lemma_SameMemAndGlobalsPreservesPageDb'(old(this), this, pagedb);
}

procedure pre_entry_resume_context(ghost dispPg:PageNr, ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        lr == page_monvaddr(dispPg);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        validDispatcherPage(pagedb, dispPg) && pagedb[dispPg].entry.entered;
    reads
        mem;
    modifies
        r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr_usr; sp_usr; lr;
    ensures
        //SRegsInvariant(old(this),this);
        //sp == old(sp);
        let disp := pagedb[dispPg].entry in
        r0 == disp.ctxt.regs[R0] && r1 == disp.ctxt.regs[R1] &&
        r2 == disp.ctxt.regs[R2] && r3 == disp.ctxt.regs[R3] &&
        r4 == disp.ctxt.regs[R4] && r5 == disp.ctxt.regs[R5] &&
        r6 == disp.ctxt.regs[R6] && r7 == disp.ctxt.regs[R7] &&
        r8 == disp.ctxt.regs[R8] && r9 == disp.ctxt.regs[R9] &&
        r10 == disp.ctxt.regs[R10] && r11 == disp.ctxt.regs[R11] &&
        r12 == disp.ctxt.regs[R12]
        && lr_usr == disp.ctxt.regs[LR(User)]
        && sp_usr == disp.ctxt.regs[SP(User)]
        && lr == pagedb[dispPg].entry.ctxt.pc;
{
    ghost var disp := pagedb[dispPg].entry;

    LDR_MSR_banked(lr_usr, lr, const(DISP_CTXT_LR), r0);
    LDR_MSR_banked(sp_usr, lr, const(DISP_CTXT_SP), r0);
    LDR(r0,lr,const(DISP_CTXT_R0));
    LDR(r1,lr,const(DISP_CTXT_R1));
    LDR(r2,lr,const(DISP_CTXT_R2));
    LDR(r3,lr,const(DISP_CTXT_R3));
    LDR(r4,lr,const(DISP_CTXT_R4));
    LDR(r5,lr,const(DISP_CTXT_R5));
    LDR(r6,lr,const(DISP_CTXT_R6));
    LDR(r7,lr,const(DISP_CTXT_R7));
    LDR(r8,lr,const(DISP_CTXT_R8));
    LDR(r9,lr,const(DISP_CTXT_R9));
    LDR(r10,lr,const(DISP_CTXT_R10));
    LDR(r11,lr,const(DISP_CTXT_R11));
    LDR(r12,lr,const(DISP_CTXT_R12));
    LDR(lr,lr,const(DISP_CTXT_PC));

    assert r0 == disp.ctxt.regs[R0] && r1 == disp.ctxt.regs[R1] &&
           r2 == disp.ctxt.regs[R2] && r3 == disp.ctxt.regs[R3] &&
           r4 == disp.ctxt.regs[R4] && r5 == disp.ctxt.regs[R5] &&
           r6 == disp.ctxt.regs[R6] && r7 == disp.ctxt.regs[R7] &&
           r8 == disp.ctxt.regs[R8] && r9 == disp.ctxt.regs[R9] &&
           r10 == disp.ctxt.regs[R10] && r11 == disp.ctxt.regs[R11] &&
           r12 == disp.ctxt.regs[R12]
           && lr_usr == disp.ctxt.regs[LR(User)]
           && sp_usr == disp.ctxt.regs[SP(User)]
           && lr == pagedb[dispPg].entry.ctxt.pc
    by {
        assert validDispatcherPage(pagedb,dispPg);
        ghost var pg := extractPage(this.m,dispPg);
        reveal pageDbDispatcherCorresponds;
        reveal pageDbDispatcherContextCorresponds;
        assert pageDbDispatcherCorresponds(dispPg, pagedb[dispPg].entry, pg) by {
            assert pageDbCorrespondsOnly(this.m,pagedb,dispPg);
            reveal pageContentsCorresponds;
            assert pageContentsCorresponds(dispPg,pagedb[dispPg], pg);
        }
    }
}

procedure pre_entry_resume(
    operand pagenr:reg,
    operand pagedb_base:reg,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        @pagenr == OReg(R1);
        @pagedb_base == OReg(R12) && pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        smc_enter_err(pagedb, pagenr, true) == KOM_ERR_SUCCESS;
    reads
        mem;
    modifies
        globals; scr; ttbr0; /* tlbiasid; */ spsr_mon;
        r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr_usr; sp_usr; lr;
    ensures
        GlobalsPreservingExcept(old(this),this, set(CurDispatcherOp()));
        GlobalWord(this.m, CurDispatcherOp(), 0) == page_monvaddr(old(pagenr));
        pageDbCorresponds(this.m, pagedb);
        StackPreserving(old(this), this);
        preEntryResume(old(this), this, pagedb, old(pagenr));
        spsr_of_state(this).m == User;
        this.conf.scr == SCRT(Secure, true, true);
        !spsr_of_state(this).i && !spsr_of_state(this).f;
        //sp == old(sp);
{
    ghost var dispPg := pagenr;
    assert validPageNr(dispPg);
    assert validDispatcherPage(pagedb, dispPg);
    assert !hasStoppedAddrspace(pagedb, dispPg);

    //-------------------------------------------------------------------------
    //  Switch addrspace
    //-------------------------------------------------------------------------
    switch_addrspace(pagenr, pagedb_base, true, pagedb);
    assert pagenr == old(pagenr);

    //-------------------------------------------------------------------------
    // Update current dispatcher
    //-------------------------------------------------------------------------
    page_monvaddr_impl(lr,pagenr,r0);
    LDRglobaladdr(r2, CurDispatcherOp());
    STRglobal(lr, CurDispatcherOp(), r2, 0);
    // help dafny see pagedb invariant
    globalUnmodifiedImpliesCorrespondingPreserved(pagedb,old(this).m,this.m);

    //-------------------------------------------------------------------------
    // Restore SPSR
    //-------------------------------------------------------------------------
    assert validDispatcherContext(pagedb[dispPg].entry.ctxt) by { reveal validPageDb; }

    LDR(r0,lr,const(DISP_CTXT_PSR));
    assert r0 == pagedb[dispPg].entry.ctxt.cpsr by
    {
        assert pageDbCorrespondsOnly(this.m,pagedb,dispPg);
        reveal pageContentsCorresponds;
        assert pageContentsCorresponds(dispPg,pagedb[dispPg],
            extractPage(this.m,dispPg));
        reveal pageDbDispatcherCorresponds;
        reveal pageDbDispatcherContextCorresponds;
    }

    assert decode_mode'(psr_mask_mode(pagedb[dispPg].entry.ctxt.cpsr)) == Just(User);
    ghost var dc := pagedb[dispPg].entry.ctxt;
    assert psr_mask_fiq(dc.cpsr) == 0;
    assert psr_mask_irq(dc.cpsr) == 0;
    MSR(spsr_mon, r0);
    assert this.sregs[spsr(Monitor)] == pagedb[dispPg].entry.ctxt.cpsr;
    assert spsr_of_state(this).m == User;

    //-------------------------------------------------------------------------
    // Restore integer context
    //-------------------------------------------------------------------------
    pre_entry_resume_context(dispPg, pagedb);
}

#verbatim
lemma lemma_sp_bit_helper1(x:word, y:word)
    requires OpaqueEven(x)
    requires y == x || y == BitwiseOr(x, 1)
    requires BitwiseAnd(y, 1) == 0
    ensures x == y
{
    assert BitsAsWord(1) == 1 by { reveal BitsAsWord(); }
    lemma_BitsAndWordConversions();
    reveal BitAnd();
    reveal BitOr();
}

lemma lemma_sp_bit_helper(x:word, y:word)
    requires OpaqueEven(x)
    requires y == x || y == BitwiseOr(x, 1)
    requires BitwiseAnd(y, 1) != 0
    ensures y - 1 == x
{
    reveal OpaqueEven();
    assert BitsAsWord(1) == 1 && BitsAsWord(2) == 2 by { reveal BitsAsWord(); }
    lemma_BitsAndWordConversions();

    assert BitwiseAnd(y, 1) == 1 by { reveal BitAnd(); }
    assert BitMod(WordAsBits(x), 2) == 0 by { lemma_BitModEquiv(x, 2); }
    assert y != x by { reveal BitAnd(); reveal BitMod(); }
    lemma_BitOrOneIsLikePlus(x);
}

lemma lemma_aligned_sp(s:state)
    requires SaneState(s)
    ensures OpaqueEven(va_get_osp(s))
{ reveal OpaqueEven(); reveal WordAligned(); }
#endverbatim

procedure {:frame false} enclaveexecution_loop(
        ghost pagedb_in: PageDb,
        ghost dispPg: PageNr)
    returns (ghost pagedb:PageDb, ghost steps:nat)
    requires/ensures
        SaneState(this);
    requires
        KomUserEntryPrecondition(this, pagedb_in, dispPg);
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        UsermodeContinuationInvariantDef();
        UsermodeContinuationPreconditionDef();
        finalDispatcher(pagedb_in, dispPg);
        spsr_of_state(this).m == User;
        this.conf.ttbr0.ptbase == page_paddr(l1pOfDispatcher(pagedb_in, dispPg));
        GlobalWord(this.m, CurDispatcherOp(), 0) == page_monvaddr(dispPg);
    modifies
        sp; globals;
    ensures
        GlobalsPreservingExcept(old(this), this, set(PendingInterruptOp()));
        StackPreserving(old(this), this);
        validEnclaveExecution(old(this), pagedb_in, this, pagedb, dispPg, steps);
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    ghost var loop0 := this;
    ghost var loop1 := this;
    ghost var retToEnclave := true;
    steps := 0;
    pagedb := pagedb_in;
    ghost var states := seq(tuple(this, pagedb));

    lemma_aligned_sp(this);
    lemma_sp_alignment(old(sp));
    ghost var loopcmp := OCmp(OTstEq, OSP, OConst(1));

    while (tst_eq(sp, 1)) // test bottom bit of SP for this kludge
        invariant
            SaneState(loop0);
            SaneStateAfterException(this) && this.ok;
            ParentStackPreserving(old(this), this);
            GlobalsPreservingExcept(old(this), this, set(PendingInterruptOp()));
            validPageDb(pagedb) && pageDbCorresponds(this.m, pagedb);
            finalDispatcher(pagedb, dispPg);
            this.conf.scr == old(this).conf.scr;
            this.conf.ttbr0.ptbase == page_paddr(l1pOfDispatcher(pagedb, dispPg));
            retToEnclave ==> spsr_of_state(this).m == User;
            if retToEnclave then sp == old(sp) else sp == BitwiseOr(old(sp), 1);
            partialEnclaveExecution(states, dispPg, steps);
            states[0] == tuple(old(this), pagedb_in);
            retToEnclave ==> !spsr_of_state(this).f && !spsr_of_state(this).i;
            if retToEnclave then states[steps] == tuple(loop1, pagedb)
                else validEnclaveExecution(old(this), pagedb_in, loop1, pagedb, dispPg, steps);
            equivStates(loop1, this);
        decreases *;
    {
        ghost var loop_pagedb := pagedb;
        loop0 := this;

        // XXX: trigger wonky vale loop condition lemmas
        assert exists s :: ValidState(s) && evalGuard(s, loopcmp, this) && evalOBool(s, loopcmp);

        // SP & 1 == 0 => go to usermode
        assert sp == old(sp) && retToEnclave by { lemma_sp_bit_helper1(old(sp), sp); }

        calc {
            OperandContents(loop0, OSP);
            sp;
            old(sp);
        }

        assert KomUserEntryPrecondition(takestep(this), pagedb, dispPg);
        lemma_Establish_UsermodeContinuationPrecondition(takestep(this), pagedb, dispPg);
        MOVS_PCLR_TO_USERMODE_AND_CONTINUE();

        pagedb, retToEnclave := lemma_evalMOVSPCLRUC(loop0, loop_pagedb, this, dispPg);
        lemma_validEnclaveExecutionStep_PageDb(loop0, loop_pagedb, this, pagedb,
                                               dispPg, retToEnclave);

        lemma_validEnclaveExecutionStepPre(loop1, loop0, loop_pagedb, this, pagedb, dispPg, retToEnclave);

        ghost if (retToEnclave) {
            assert sp == old(sp);
            ghost var states' := states;
            lemma_partialEnclaveExecution_append(states, this, pagedb, dispPg, steps);
            states := states + seq(tuple(this, pagedb));
            steps := steps + 1;
        } else {
            assert sp == BitwiseOr(old(sp), 1);
            lemma_partialEnclaveExecution_done(states, this, pagedb, dispPg, steps);
            assert validEnclaveExecution(old(this), pagedb_in, this, pagedb, dispPg, steps);
        }
        loop1 := this;
    }

    // XXX: trigger wonky vale loop condition lemmas
    assert exists s :: ValidState(s) && evalGuard(s, loopcmp, this) && !evalOBool(s, loopcmp);

    // clear lower bit of SP, which was set to exit the loop
    lemma_sp_bit_helper(old(sp), sp);
    assert !retToEnclave;
    SUB(sp, sp, 1);
    assert sp == old(sp);

    assert validExceptionTransition(loop1, pagedb, this, pagedb, dispPg)
        by { reveal validExceptionTransition; }
    lemma_validEnclaveExecutionPost(old(this), pagedb_in, loop1, pagedb, this,
                                    dispPg, steps);
}

#verbatim
lemma lemma_ValidEntryPost(s:state, sd:PageDb, r1:state, rd:PageDb, r2:state, dp:word,
                           a1:word, a2:word, a3:word)
    requires ValidState(s) && ValidState(r1) && ValidState(r2) && validPageDb(sd)
    requires SaneConstants()
    requires validExceptionTransition(r1, rd, r2, rd, dp)
    requires OperandContents(r1, OReg(R0)) == OperandContents(r2, OReg(R0))
    requires OperandContents(r1, OReg(R1)) == OperandContents(r2, OReg(R1))
    requires InsecureMemInvariant(r1, r2)
    ensures smc_enter(s, sd, r1, rd, dp, a1, a2, a3)
        ==> smc_enter(s, sd, r2, rd, dp, a1, a2, a3)
    ensures smc_resume(s, sd, r1, rd, dp) ==> smc_resume(s, sd, r2, rd, dp)
{
    reveal ValidRegState();

    if smc_enter(s, sd, r1, rd, dp, a1, a2, a3) {
        if smc_enter_err(sd, dp, false) == KOM_ERR_SUCCESS {
            lemma_validEnterPost(s, sd, r1, rd, r2, dp, a1, a2, a3);
        }
    }

    if smc_resume(s, sd, r1, rd, dp) {
        if smc_enter_err(sd, dp, true) == KOM_ERR_SUCCESS {
            lemma_validResumePost(s, sd, r1, rd, r2, dp);
        }
    }
}
#endverbatim

procedure {:frame false} {:timeLimitMultiplier 2} smc_enterresume_success(
    operand pagenr:reg,
    operand arg1:reg,
    operand arg2:reg,
    operand arg3:reg,
    operand callno:reg,
    operand pagedb_base:reg,
    out operand err:reg,
    out operand val:reg,
    ghost pagedb_in: PageDb,
    ghost stack_bytes: int)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        @pagenr == OReg(R1) && @arg1 == OReg(R2) && @arg2 == OReg(R3) && @arg3 == OReg(R4);
        @callno == OReg(R5) && @err == OReg(R0) && @val == OReg(R1);
        @pagedb_base == OReg(R12) && pagedb_base == AddressOfGlobal(PageDb());
        stack_bytes >= BANKED_FRAMESIZE + EXCEPTION_STACK_BYTES;
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        UsermodeContinuationInvariantDef();
        UsermodeContinuationPreconditionDef();
        callno == KOM_SMC_ENTER || callno == KOM_SMC_RESUME;
        smc_enter_err(pagedb_in, pagenr, callno == KOM_SMC_RESUME) == KOM_ERR_SUCCESS;
    modifies // XXX: all saved and restored; not in fact "modified" on return!
        spsr_fiq; spsr_irq; spsr_svc; spsr_abt; spsr_und; spsr_mon;
        sp_usr; sp_fiq; sp_irq; sp_svc; sp_abt; sp_und;
        lr_usr; lr_fiq; lr_irq; lr_svc; lr_abt; lr_und; sp;
    modifies
        mem; globals; scr; ttbr0; /* tlbiasid; */ spsr_mon;
        r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr_usr; sp_usr; lr;
    ensures
        EnterResumeSmcProcedureInvariant(old(this), this);
        if old(callno) == KOM_SMC_ENTER then
            smc_enter(old(this), pagedb_in, this, pagedb,
                      old(pagenr), old(arg1), old(arg2), old(arg3))
        else
            smc_resume(old(this), pagedb_in, this, pagedb,
                       old(pagenr));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    ghost var dispPg := old(pagenr);
    assert finalDispatcher(pagedb, dispPg);

    ghost var stack_bytes_local;
    stack_bytes_local := stack_banked_regs(r0, stack_bytes);
    lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb);

    ghost var s0 := this;

    if (callno == const(KOM_SMC_ENTER)) {
        pre_entry_enter(pagenr, arg1, arg2, arg3, pagedb_base, pagedb);
        assert preEntryEnter(old(this), this, pagedb, dispPg, old(arg1),
                             old(arg2), old(arg3));
    } else {
        pre_entry_resume(pagenr, pagedb_base, pagedb);
        assert preEntryResume(old(this), this, pagedb, dispPg);
    }

    ghost var steps:nat;
    assert KomUserEntryPrecondition(this, pagedb, dispPg);
    pagedb, steps := enclaveexecution_loop(pagedb, dispPg);

    assert StackPreserving(s0, this);
    ghost var s6 := this;
    ghost var s6_sp := sp;

    lemma_ValidEntryPre(old(this), s0, pagedb_in, s6, pagedb, dispPg,
                            old(arg1), old(arg2), old(arg3));

    leave_secure_world(r2);

    lemma_wellformed_banked_regs_stackframe_preserved(s0.m, this.m, sp);
    assert StackPreserving(s6, this);
    stack_bytes_local := unstack_banked_regs(r2, stack_bytes_local);
    assert stack_bytes_local == stack_bytes;
    assert GlobalsInvariant(s6, this);
    lemma_SameMemAndGlobalsPreservesPageDb(s6, this, pagedb);

    assert StackPreserving(old(this), this);
    lemma_stackunstack_banked_regs(old(this), s0.m, this, s6.m, s6_sp);

    assert validExceptionTransition(s6, pagedb, this, pagedb, dispPg)
        by { reveal validExceptionTransition; }
    lemma_ValidEntryPost(old(this), pagedb_in, s6, pagedb, this,
                         dispPg, old(arg1), old(arg2), old(arg3));
}

procedure {:frame false} kom_smc_enterresume(
    operand callno:reg,
    operand disppg:reg,
    operand arg1:reg,
    operand arg2:reg,
    operand arg3:reg,
    operand pagedb_base:reg,
    out operand err:reg,
    out operand val:reg,
    ghost pagedb_in:PageDb,
    ghost stack_bytes: int)
    returns (ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        @callno == OReg(R0) && @disppg == OReg(R1);
        @arg1 == OReg(R2) && @arg2 == OReg(R3) && @arg3 == OReg(R4);
        @err == OReg(R0) && @val == OReg(R1);
        @pagedb_base == OReg(R12) && pagedb_base == AddressOfGlobal(PageDb());
        stack_bytes >= BANKED_FRAMESIZE + EXCEPTION_STACK_BYTES;
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        UsermodeContinuationInvariantDef();
        UsermodeContinuationPreconditionDef();
        this.conf.scr.ns == NotSecure; // FIXME: cleanup
        callno == KOM_SMC_ENTER || callno == KOM_SMC_RESUME;
    modifies // XXX: all saved and restored; not in fact "modified" on return!
        spsr_fiq; spsr_irq; spsr_svc; spsr_abt; spsr_und; spsr_mon;
        sp_usr; sp_fiq; sp_irq; sp_svc; sp_abt; sp_und;
        lr_usr; lr_fiq; lr_irq; lr_svc; lr_abt; lr_und; sp;
    modifies
        mem; globals; scr; ttbr0; /* tlbiasid; */ spsr_mon;
        r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr_usr; sp_usr; lr;
    ensures
        EnterResumeSmcProcedureInvariant(old(this), this);
        if old(callno) == KOM_SMC_ENTER then
            smc_enter(old(this), pagedb_in, this, pagedb, old(disppg),
                      old(arg1), old(arg2), old(arg3))
        else
            smc_resume(old(this), pagedb_in, this, pagedb, old(disppg));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    MOV(r5, callno);
    smc_enter_err(callno, disppg, pagedb_base, err, pagedb_in);
    if (err != const(KOM_ERR_SUCCESS) ) {
        pagedb := pagedb_in;
        MOV(val, 0);
    } else {
        ghost var s0 := this;
        pagedb := smc_enterresume_success(disppg, arg1, arg2, arg3, r5, pagedb_base,
                                          err, val, pagedb_in, stack_bytes);
    }
}
