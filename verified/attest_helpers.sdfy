include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"
include {:verbatim} "entry.i.dfy"
include {:verbatim} "exceptions.i.dfy"

include "ARMdecls.sdfy"
include "kom_utils.sdfy"
include "sha/hmac.sdfy"

#verbatim
//const STACKSIZE_ATTEST:int := 8 + 24 + 1 + 2 * SHA_BLOCKSIZE + HMAC_KEYSIZE_WORDS + STACKSIZE_HMAC;
// workaround Dafny const-bug which results in stack overflow
const T1:int := HMAC_KEYSIZE_WORDS + STACKSIZE_HMAC;
const T2:int := 2 * SHA_BLOCKSIZE;
const T3:int := 33;
const T4:int := T1 + T2;
const STACKSIZE_ATTEST:int := T3 + T4;
#endverbatim

procedure addrspace_va_for_page_va(
    operand page_va: reg,
    out operand as_va: reg,
    out operand tmp: reg,
    ghost pagenr:PageNr,
    ghost pagedb:PageDb)
    reads
        globals;
    requires/ensures
        SaneState(this);
    requires
        @as_va != @tmp; @as_va != OSP; @tmp != OSP;
        page_va == page_monvaddr(pagenr);
        validPageDb(pagedb) && pageDbCorresponds(this.m, pagedb);
        pagedb[pagenr] is PageDbEntryTyped;
    ensures
        as_va == page_monvaddr(pagedb[pagenr].addrspace);
{
    // compute page number
    SUB(as_va, page_va, const(KOM_DIRECTMAP_VBASE));
    LDRglobaladdr(tmp, SecurePhysBaseOp());
    LDRglobal(tmp, SecurePhysBaseOp(), tmp, 0);
    SUB(as_va, as_va, tmp);
    lemma_RightShift12(as_va);
    LSR(as_va, as_va, const(PAGEBITS));
    assert as_va == monvaddr_page(old(page_va)) == pagenr;

    // retrieve addrspace field from pagedb
    // TODO: avoid pointless double-shift
    lemma_LeftShift3(as_va);
    LSL(as_va, as_va, const(PAGEDB_ENTRY_SHIFT));
    ADD(as_va, as_va, const(PAGEDB_ENTRY_ADDRSPACE));
    assert as_va == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE;
    LDRglobaladdr(tmp, PageDb());
    LDRglobal(as_va, PageDb(), tmp, as_va);

    reveal pageDbEntryCorresponds;
    PageDbCorrespondsImpliesEntryCorresponds(this.m, pagedb, pagenr);
    extractPageDbToAbstractOne(this.m, pagenr, PAGEDB_ENTRY_ADDRSPACE);
}
procedure load_attestion_key() returns (ghost key:seq(word))
    reads
        globals; r4;
    modifies 
        mem; r2; r3; 
    requires/ensures
        SaneState(this);
        ValidMemRange(r4, r4 + SHA_CTXSIZE * WORDSIZE);
    ensures
        AddrMemPreservingExcept(old(mem), mem, r4, r4 + SHA_CTXSIZE * WORDSIZE);
        AddrMemContentsSeq(mem, r4, SHA_CTXSIZE) == key == AttestKey();
{
    assert ValidGlobal(AttestKeyOp()) by { reveal SaneShaGlobal; }
    LDRglobaladdr(r2, AttestKeyOp());

    LDRglobal(r3, AttestKeyOp(), r2, const(0 * WORDSIZE));
    STR(r3, r4, const(0 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(1 * WORDSIZE));
    STR(r3, r4, const(1 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(2 * WORDSIZE));
    STR(r3, r4, const(2 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(3 * WORDSIZE));
    STR(r3, r4, const(3 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(4 * WORDSIZE));
    STR(r3, r4, const(4 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(5 * WORDSIZE));
    STR(r3, r4, const(5 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(6 * WORDSIZE));
    STR(r3, r4, const(6 * WORDSIZE));
    LDRglobal(r3, AttestKeyOp(), r2, const(7 * WORDSIZE));
    STR(r3, r4, const(7 * WORDSIZE));
    //key := AttestKey();

    assert WordAligned(r4);
    WordAlignedAdd(r4, 1*WORDSIZE);
    WordAlignedAdd(r4, 2*WORDSIZE);
    WordAlignedAdd(r4, 3*WORDSIZE);
    WordAlignedAdd(r4, 4*WORDSIZE);
    WordAlignedAdd(r4, 5*WORDSIZE);
    WordAlignedAdd(r4, 6*WORDSIZE);
    WordAlignedAdd(r4, 7*WORDSIZE);

    key := 
        seq(AddrMemContents(mem, r4 + 0*WORDSIZE),
            AddrMemContents(mem, r4 + 1*WORDSIZE),
            AddrMemContents(mem, r4 + 2*WORDSIZE),
            AddrMemContents(mem, r4 + 3*WORDSIZE),
            AddrMemContents(mem, r4 + 4*WORDSIZE),
            AddrMemContents(mem, r4 + 5*WORDSIZE),
            AddrMemContents(mem, r4 + 6*WORDSIZE),
            AddrMemContents(mem, r4 + 7*WORDSIZE));
    lemma_package_hash_result(mem, r4, key);    // Ensures AddMemContentsSeq(mem, r4, SHA_CTXSIZE) == key
    assert key == GlobalFullContents(this.m, AttestKeyOp());
    assert GlobalFullContents(this.m, AttestKeyOp()) == AttestKey();
    assert {:split_here} true;
}

procedure load_memory_into_regs(ghost contents:seq(word))
    reads
        mem; r0;
    modifies 
         r1; r2; r3; r4; r5; r6; r7; r8; 
    requires/ensures
        SaneState(this);
    requires
        ValidMemRange(r0, r0 + SHA_CTXSIZE * WORDSIZE);
        SeqLength(contents) == 8;
        AddrMemContentsSeq(mem, r0, SHA_CTXSIZE) == contents;
    ensures
        r1 == contents[0];
        r2 == contents[1];
        r3 == contents[2];
        r4 == contents[3];
        r5 == contents[4];
        r6 == contents[5];
        r7 == contents[6];
        r8 == contents[7];
{
    assert WordAligned(r0);
    WordAlignedAdd(r0, 1*WORDSIZE);
    WordAlignedAdd(r0, 2*WORDSIZE);
    WordAlignedAdd(r0, 3*WORDSIZE);
    WordAlignedAdd(r0, 4*WORDSIZE);
    WordAlignedAdd(r0, 5*WORDSIZE);
    WordAlignedAdd(r0, 6*WORDSIZE);
    WordAlignedAdd(r0, 7*WORDSIZE);

    LDR(r1, r0, const(0 * WORDSIZE));
    LDR(r2, r0, const(1 * WORDSIZE));
    LDR(r3, r0, const(2 * WORDSIZE));
    LDR(r4, r0, const(3 * WORDSIZE));
    LDR(r5, r0, const(4 * WORDSIZE));
    LDR(r6, r0, const(5 * WORDSIZE));
    LDR(r7, r0, const(6 * WORDSIZE));
    LDR(r8, r0, const(7 * WORDSIZE));
}

#verbatim
lemma lemma_SeqRepeat8()
    ensures SeqRepeat(8, 0) == [0, 0, 0, 0, 0, 0, 0, 0];
{
}
#endverbatim

procedure zero_pad_memory() 
    reads
        r1;
    modifies 
        mem; r2; 
    requires/ensures
        SaneState(this);
        ValidMemRange(r1, r1 + SHA_CTXSIZE * WORDSIZE);
    ensures
        AddrMemPreservingExcept(old(mem), mem, r1, r1 + SHA_CTXSIZE * WORDSIZE);
        AddrMemContentsSeq(mem, r1, SHA_CTXSIZE) == SeqRepeat(8, 0);
{
    MOV(r2, 0);
    STR(r2, r1, const(0 * WORDSIZE));
    STR(r2, r1, const(1 * WORDSIZE));
    STR(r2, r1, const(2 * WORDSIZE));
    STR(r2, r1, const(3 * WORDSIZE));
    STR(r2, r1, const(4 * WORDSIZE));
    STR(r2, r1, const(5 * WORDSIZE));
    STR(r2, r1, const(6 * WORDSIZE));
    STR(r2, r1, const(7 * WORDSIZE));
    
    ghost var zeroes := seq(0, 0, 0, 0, 0, 0, 0, 0);
    lemma_package_hash_result(mem, r1, zeroes);    
    lemma_SeqRepeat8();
}

#verbatim

lemma lemma_arrange_attestation_input_helper(
        user_words_mem:memmap,
        measurement_mem:memmap,
        mem:memmap,
        base:nat,
        user_words:seq<word>,
        measurement:seq<word>)
    requires ValidMemRange(base, base + 3 * SHA_CTXSIZE * WORDSIZE);
    requires ValidAddrMemStateOpaque(user_words_mem)
          && ValidAddrMemStateOpaque(measurement_mem)
          && ValidAddrMemStateOpaque(mem);

    requires user_words      == AddrMemContentsSeq(user_words_mem,  base,                              SHA_CTXSIZE);
    requires measurement     == AddrMemContentsSeq(measurement_mem, base + SHA_CTXSIZE * WORDSIZE,     SHA_CTXSIZE);
    requires SeqRepeat(8, 0) == AddrMemContentsSeq(mem,             base + 2 * SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);

    requires AddrMemPreservingExcept(user_words_mem, measurement_mem, 
                                     base +     SHA_CTXSIZE * WORDSIZE, 
                                     base + 2 * SHA_CTXSIZE * WORDSIZE)
    requires AddrMemPreservingExcept(measurement_mem, mem,
                                     base + 2 * SHA_CTXSIZE * WORDSIZE, 
                                     base + 3 * SHA_CTXSIZE * WORDSIZE)
    ensures AddrMemContentsSeq(mem, base, 3 * SHA_CTXSIZE) == user_words + measurement + SeqRepeat(8, 0);
{
    calc {
        true;
        ValidMemRange(base, base + 3 * SHA_CTXSIZE * WORDSIZE);
            { lemma_ValidMemRange_reduced(base, 3 * SHA_CTXSIZE, 2 * SHA_CTXSIZE); }
        ValidMemRange(base, base + SHA_CTXSIZE * WORDSIZE);
    }
    
    calc {
        true;
        ValidMemRange(base, base + 3 * SHA_CTXSIZE * WORDSIZE);
            { lemma_ValidMemRange_offset(base, 3 * SHA_CTXSIZE, SHA_CTXSIZE); }
        ValidMemRange(base + SHA_CTXSIZE * WORDSIZE, base + 2 * SHA_CTXSIZE * WORDSIZE);
    }
    
    calc {
        true;
        ValidMemRange(base, base + 3 * SHA_CTXSIZE * WORDSIZE);
            { lemma_ValidMemRange_offset(base, 3 * SHA_CTXSIZE, 2 * SHA_CTXSIZE); }
        ValidMemRange(base + 2 * SHA_CTXSIZE * WORDSIZE, base + 3 * SHA_CTXSIZE * WORDSIZE);
    }

    // Propagate memory contents to latest version of memory
    calc {
        user_words;
        AddrMemContentsSeq(user_words_mem, base, SHA_CTXSIZE);
            { lemma_AddrMemContentsSeq_framing1(user_words_mem, measurement_mem, 
                                     base, SHA_CTXSIZE, 
                                     base +     SHA_CTXSIZE * WORDSIZE, 
                                     base + 2 * SHA_CTXSIZE * WORDSIZE); }
        AddrMemContentsSeq(measurement_mem, base, SHA_CTXSIZE);
            { lemma_AddrMemContentsSeq_framing1(measurement_mem, mem,
                                     base, SHA_CTXSIZE, 
                                     base + 2 * SHA_CTXSIZE * WORDSIZE, 
                                     base + 3 * SHA_CTXSIZE * WORDSIZE); }
        AddrMemContentsSeq(mem, base, SHA_CTXSIZE);
    }

    calc {
        measurement;
        AddrMemContentsSeq(measurement_mem, base + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);
            { lemma_AddrMemContentsSeq_framing1(measurement_mem, mem, 
                                                base + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE,
                                                base + 2 * SHA_CTXSIZE * WORDSIZE, 
                                                base + 3 * SHA_CTXSIZE * WORDSIZE);
            }
        AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);
    }


    calc {
        AddrMemContentsSeq(mem, base, 3 * SHA_CTXSIZE);
            { lemma_AddrMemContentsSeq_adds(mem, base, 3 * SHA_CTXSIZE, SHA_CTXSIZE); }
        AddrMemContentsSeq(mem, base, SHA_CTXSIZE) 
      + AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE, 2 * SHA_CTXSIZE);
        user_words + AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE, 2 * SHA_CTXSIZE);
            { lemma_AddrMemContentsSeq_adds(mem, base + SHA_CTXSIZE * WORDSIZE, 2 * SHA_CTXSIZE, SHA_CTXSIZE); }
        user_words 
      + AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE) 
      + AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);

        user_words 
      + AddrMemContentsSeq(mem, base + SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE) 
      + AddrMemContentsSeq(mem, base + 2 * SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);

        user_words 
      + measurement
      + AddrMemContentsSeq(mem, base + 2 * SHA_CTXSIZE * WORDSIZE, SHA_CTXSIZE);

        user_words 
      + measurement
      + SeqRepeat(8, 0);
    }
}
#endverbatim


procedure stack_all_regs(ghost stack_bytes:int)
    returns (ghost stack_bytes_ret:int)
    reads
        r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr;
    modifies
        sp; mem;
    requires/ensures
        SaneState(this);
    requires
        stack_bytes >= 56;
        StackBytesRemaining(this,stack_bytes);
    ensures
        sp == old(sp-56);
 
        MemContents(this.m, sp)    == old(r12);
        MemContents(this.m, sp+4)  == old(r11);
        MemContents(this.m, sp+8)  == old(r10);
        MemContents(this.m, sp+12) == old(r9);
        MemContents(this.m, sp+16) == old(r8);
        MemContents(this.m, sp+20) == old(r7);
        MemContents(this.m, sp+24) == old(r6);
        MemContents(this.m, sp+28) == old(r5);
        MemContents(this.m, sp+32) == old(r4);
        MemContents(this.m, sp+36) == old(r3);
        MemContents(this.m, sp+40) == old(r2);
        MemContents(this.m, sp+44) == old(r1);
        MemContents(this.m, sp+48) == old(r0);
        MemContents(this.m, sp+52) == old(lr);

        NonStackMemPreserving(old(this),this);
        ParentStackPreserving(old(this),this);

        stack_bytes_ret == stack_bytes-56;
        StackBytesRemaining(this,stack_bytes_ret);
{
    SUB(sp, sp, 56);

    STR(lr,  sp, 52);
    STR(r0,  sp, 48);
    STR(r1,  sp, 44);
    STR(r2,  sp, 40);
    STR(r3,  sp, 36);
    STR(r4,  sp, 32);
    STR(r5,  sp, 28);
    STR(r6,  sp, 24);
    STR(r7,  sp, 20);
    STR(r8,  sp, 16);
    STR(r9,  sp, 12);
    STR(r10, sp, 8);
    STR(r11, sp, 4);
    STR(r12, sp, 0);

    stack_bytes_ret := stack_bytes - 56;
}

procedure unstack_all_regs(ghost stack_bytes:int)
    returns (ghost stack_bytes_ret:int)
    reads
        mem;
    modifies
        r0; r1; r2; r3; r4; r5; r6; r7; r8; r9; r10; r11; r12; lr; sp;
    requires/ensures
        SaneState(this);
    requires
        isUInt32(sp + 56);
        sp + 56 <= StackBase();
        StackBytesRemaining(this, stack_bytes);
    ensures
        sp == old(sp+56);
        
        old(MemContents(this.m, sp))    == r12;
        old(MemContents(this.m, sp+4))  == r11;
        old(MemContents(this.m, sp+8))  == r10;
        old(MemContents(this.m, sp+12)) == r9;
        old(MemContents(this.m, sp+16)) == r8;
        old(MemContents(this.m, sp+20)) == r7;
        old(MemContents(this.m, sp+24)) == r6;
        old(MemContents(this.m, sp+28)) == r5;
        old(MemContents(this.m, sp+32)) == r4;
        old(MemContents(this.m, sp+36)) == r3;
        old(MemContents(this.m, sp+40)) == r2;
        old(MemContents(this.m, sp+44)) == r1;
        old(MemContents(this.m, sp+48)) == r0;
        old(MemContents(this.m, sp+52)) == lr;

        stack_bytes_ret == stack_bytes + 56;
        StackBytesRemaining(this, stack_bytes_ret);
{
    LDR(r12, sp, 0);
    LDR(r11, sp, 4);
    LDR(r10, sp, 8);
    LDR(r9,  sp, 12);
    LDR(r8,  sp, 16);
    LDR(r7,  sp, 20);
    LDR(r6,  sp, 24);
    LDR(r5,  sp, 28);
    LDR(r4,  sp, 32);
    LDR(r3,  sp, 36);
    LDR(r2,  sp, 40);
    LDR(r1,  sp, 44);
    LDR(r0,  sp, 48);
    LDR(lr,  sp, 52);

    stack_bytes_ret := stack_bytes + 56;
}
