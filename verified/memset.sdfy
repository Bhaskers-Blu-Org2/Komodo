procedure memset(inout {:operand} base:int, {:operand} val:int, inout {:operand} size:int)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@base, @val, @size), 3);
        WordAligned(base);
        WordAligned(size);
        isUInt32(val);
        isUInt32(base + size);
        ValidMemRange(base, base + size);
        base >= StackBase() || base + size <= StackLimit();
    ensures
        GlobalsInvariant(old(this),this);
        SmcProcedureInvariant(old(this),this);
        RegPreservingExcept(old(this), this, set(@base,@size));
        MemPreservingExcept(old(this), this, old(base), old(base + size));
        forall i :: old(base) <= i < old(base + size) && WordAligned(i)
            ==> MemContents(this.m,i) == old(val);
{
    ghost var lower := base;
    ghost var limit := base + size;

    // beyond this point, "base" is where we're up to, and "size" is the limit
    ADD(size, size, base);

    while (base < size)
        invariant
            SaneState(this);
            GlobalsInvariant(old(this),this);
            SmcProcedureInvariant(old(this),this);
            WordAligned(base);
            size == limit;
            lower <= base <= limit;
            lower >= StackBase() || limit <= StackLimit();
            forall i :: (lower <= i < base) && WordAligned(i)
                ==> MemContents(this.m,i) == old(val);
            MemPreservingExcept(old(this), this, lower, limit);
            RegPreservingExcept(old(this), this, set(@base, @size));
            val == old(val);
        decreases
            size - base;
    {
        ghost var prevThis := this;
        STR(val, base, 0);
        assert forall p :: ValidMem(p) && p != base
            ==> MemContents(prevThis.m, p) == MemContents(this.m, p);
        assert WordAligned(base + 4);
        ADD(base, base, 4);
    }
}
