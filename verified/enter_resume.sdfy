#verbatim
predicate validSysState'(s:SysState)
{
    validSysState(s) && pageDbCorresponds(s.hw.m, s.d)
}
#endverbatim

procedure smc_enter_err(
    {:register OReg(R0)} pagenr:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    out {:register OReg(R0)} err:int,
    ghost s:SysState)
    returns (ghost s':SysState)
    requires 
        this == s.hw;
        SaneState(this);
        validSysState'(s);
    ensures
        this == s'.hw; 
        SaneState(this);
        validSysState'(s');
        RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
    ensures
        tuple(s'.d, err) == smc_enter_premium(s.d, pagenr, arg1, arg2, arg3);
{
    reveal_smc_enter_premium();
    if (pagenr >= sp_op_const(KOM_SECURE_NPAGES())) {
        assert !validPageNr(pagenr);
        
        err := sp_op_const(KOM_ERR_INVALID_PAGENO());
        s' := s.(hw := this);
    } else {
        assert validPageNr(pagenr);

        LDRglobaladdr(r12, PageDb());
        r11 := sp_op_const(PAGEDB_ENTRY_SIZE());
        MUL(r10,pagenr,r11);
        assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
        LDRglobal(r9, PageDb(), r12, r10);
        forall :: pageDbEntryCorresponds(s.d[pagenr], extractPageDbEntry(this.m, pagenr))
        {
            reveal_validPageDb();
        }
        forall :: r9 == GlobalWord(s.hw.m, PageDb(), r10) &&
            r9 == pageDbEntryTypeVal(s.d[pagenr])
        {
            reveal_pageDbEntryCorresponds(); 
            reveal_validPageDb();

            assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
            ghost var entryWords := extractPageDbEntry(this.m, pagenr);
            assert entryWords[BytesToWords(PAGEDB_ENTRY_TYPE())] ==
                GlobalWord(this.m, PageDb(), r10);
            assert GlobalWord(this.m, PageDb(), r10) == 
                pageDbEntryTypeVal(s.d[pagenr]);
        }
        assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
        if( r9 != sp_op_const(KOM_PAGE_DISPATCHER()) ) {
            assert !(s.d[pagenr] is PageDbEntryTyped && s.d[pagenr].entry is Dispatcher);

            err := sp_op_const(KOM_ERR_INVALID_PAGENO());
            s' := s.(hw := this);
        } else {
            assert s.d[pagenr] is PageDbEntryTyped && s.d[pagenr].entry is Dispatcher;

            ADD(r10, r10, sp_op_const(PAGEDB_ENTRY_ADDRSPACE()));
            assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
            WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE(), r10);
           
            LDRglobal(r8, PageDb(), r12, r10);
            ghost var addrspace := s.d[pagenr].addrspace;
            forall :: validPageNr(addrspace)
            {
                reveal_validPageDb();
            }
            forall :: r8 == page_monvaddr(addrspace) && WordAligned(r8)
            {
                reveal_pageDbEntryCorresponds();
                reveal_validPageDb();
                assert pageDbCorrespondsOnly(this.m, s.d, pagenr);
                ghost var entryWords := extractPageDbEntry(this.m, pagenr);
                assert entryWords[BytesToWords(PAGEDB_ENTRY_ADDRSPACE())] == 
                    page_monvaddr(s.d[pagenr].addrspace);
                
               
                extractPageDbToAbstractOne(this.m, pagenr, PAGEDB_ENTRY_ADDRSPACE());

                assert r10 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
                assert entryWords[BytesToWords(PAGEDB_ENTRY_ADDRSPACE())] ==
                    GlobalWord(this.m, PageDb(), r10);
                assert GlobalWord(this.m, PageDb(), r10) == 
                    page_monvaddr(s.d[pagenr].addrspace);
            }
            WordAlignedAdd_(r8,ADDRSPACE_STATE(),r8+ADDRSPACE_STATE());
           
            forall :: ValidMem(r8 + ADDRSPACE_STATE())
                { reveal_validPageDb(); } 
            LDR(r8, r8, sp_op_const(ADDRSPACE_STATE()));
            forall :: 
            (r8 == KOM_ADDRSPACE_FINAL() ==>
                s.d[addrspace].entry.state == FinalState) &&
            (r8 != KOM_ADDRSPACE_FINAL() ==>
                s.d[addrspace].entry.state != FinalState)
            {
                reveal_validPageDb();
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            // this particular RegPreserving assert saved 30s.
            assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
            if( r8 != sp_op_const(KOM_ADDRSPACE_FINAL()) ) {
                forall :: s.d[addrspace].entry.state != FinalState { reveal_validPageDb(); }
                err := sp_op_const(KOM_ERR_NOT_FINAL());
                s' := s.(hw := this);
            } else {
                forall :: s.d[addrspace].entry.state == FinalState { reveal_validPageDb(); }
                
                assert this.m == old(this.m);
                assert SaneState(this);
                page_monvaddr_impl(r9,pagenr,r10);
                assert r9 == page_monvaddr(pagenr);
                forall :: MemContents(this.m, page_monvaddr(pagenr) + 
                    DISPATCHER_ENTERED()) == to_i(s.d[pagenr].entry.entered)
                {
                    reveal_pageContentsCorresponds();
                    reveal_pageDbDispatcherCorresponds();
                }
                LDR(r9,r9,sp_op_const(DISPATCHER_ENTERED()));
                
                assert r9 == 1 ==> s.d[pagenr].entry.entered;
                assert r9 != 1 ==> !(s.d[pagenr].entry.entered);
                assert RegPreservingExcept(old(this),this,set(@r12,@r11,@r10,@r9,@r8,@r0));
                if( r9 == 1 ) {
                    err := sp_op_const(KOM_ERR_ALREADY_ENTERED());
                    s' := s.(hw := this);
                } else {
                    err := sp_op_const(KOM_ERR_SUCCESS());
                    s' := s.(hw := this);
                }
            }
        }
    }
}

procedure havoc_state(ghost s:SysState)
    returns (ghost s':SysState)
    requires
        this == s.hw;
        validSysState'(s);
        SaneState(s.hw);
    ensures
        this == s'.hw;
        validSysState'(s');
        SaneState(s'.hw);
{
    s' := s;
}

procedure pre_entry_enter(
    {:register OReg(R0)} err:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    {:register OReg(R5)} pagenr:int,
    ghost s:SysState)
    returns (ghost s':SysState)
    requires
        this == s.hw;
        mode_of_state(s.hw) == Monitor;
        validSysState'(s);
        SaneState(s.hw);
        isUInt32(arg1) && isUInt32(arg2) && isUInt32(arg3);
        specErr(smc_enter_premium(s.d, pagenr, arg1, arg2, arg3)) == 
            KOM_ERR_SUCCESS();
        err == KOM_ERR_SUCCESS();
    ensures
        this == s'.hw;
        validSysState'(s');
        SaneState(s'.hw);
        //RegPreservingExcept(old(this),this,set(@));
        // tuple(s.d, err) == smc_enter_premium(s.d, pagenr, arg1, arg2, arg3);
        // err == KOM_ERR_SUCCESS();
        preEntryEnter(s,s',pagenr, arg1, arg2, arg3);
        spsr_of_state(s'.hw).m == User;
{
    reveal_validPageDb();
    reveal_ValidRegState();
    reveal_smc_enter_premium();
    ghost var d := s.d;
    assert validDispatcherPage(s.d, pagenr);
    assert !hasStoppedAddrspace(s.d, pagenr);
    ghost var l1p := l1pOfDispatcher(s.d, pagenr);
  
    // TODO: read r12, clear lsb, store into MCR
    // MRC(r12,scr);
    // Dafny/Spartan are unlikely to enjoy bit vector math
    
    r10 := 0;
    MCR(OSReg(scr), r12);
    forall :: this.conf.scr.ns == Secure
    {
        //FIXME
        assume false;
        assert BitwiseAnd(r10,1) != 1;
        assert decode_scr(r10) == SCR(Secure, false, false);
    }
  
    //-------------------------------------------------------------------------
    // load l1p into ttbr0
    //-------------------------------------------------------------------------
    LDRglobaladdr(r12, PageDb());
    assert validPageNr(pagenr);
    r11 := sp_op_const(PAGEDB_ENTRY_SIZE());
    MUL(r10,pagenr,r11);
    assert r10 == G_PAGEDB_ENTRY(pagenr);
    ADD(r9, r10, sp_op_const(PAGEDB_ENTRY_ADDRSPACE())); 
    assert r9 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
    WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE(), r9);

    LDRglobal(r11, PageDb(), r12, r9);
    ghost var addrspace := s.d[pagenr].addrspace;
    forall :: r11 == page_monvaddr(addrspace) && WordAligned(r11) 
        && PageAligned(r11)
    {
        reveal_pageDbEntryCorresponds(); reveal_pageContentsCorresponds();
        reveal_validPageDb();
        assert validAddrspacePage(s.d, s.d[pagenr].addrspace);
    }

    forall :: ValidMem(r11 + ADDRSPACE_L1PT_PHYS())
        { reveal_validPageDb(); } 

    // page_monvaddr_impl(r9,r11,r10); 
    LDR(r10,r11,sp_op_const(ADDRSPACE_L1PT_PHYS()));

    forall :: r10 == page_paddr(d[addrspace].entry.l1ptnr)
    {
        assert pageDbCorrespondsOnly(this.m, d, addrspace);
        assert validAddrspacePage(d, addrspace);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(addrspace, d[addrspace],
            extractPage(this.m, addrspace));
        reveal_pageDbAddrspaceCorresponds();
    }
    
    assert r10 == page_paddr(l1p);

    // reveal_pageContentsCorresponds();
    // reveal_pageDbAddrspaceCorresponds();
    MSR(OSReg(ttbr0), r10);

    // XXX Need this back.
    // MaskWithSizeIsAligned(r10, 0x1000);
    // BitwiseMaskHigh(r10, 12); 
    assert isUInt32(r10);
    assert isUInt32(0xffff_f000);
    forall :: r10 == BitwiseAnd(r10, 0xffff_f000){
        // XXX TODO FIXME.
        // I'm not sure if we're dealing with bitvector stuff yet.
        // I also think this worked without cheating at some point...
        assume false;
    }
    // XXX This was an assert before.
    assume this.conf.ttbr0.ptbase == page_paddr(l1p);
    //-------------------------------------------------------------------------
    
    //-------------------------------------------------------------------------
    //  Move arguments to regs
    //-------------------------------------------------------------------------
    r0 := arg1;
    r1 := arg2;
    r2 := arg3;
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Set SPSR to Usermode
    //-------------------------------------------------------------------------
    r10 := 0x10;
    assume psr_mask_mode(r10) == 0x10;
    assert decode_mode(psr_mask_mode(r10)) == User;
    assert ValidModeChange'(this, User);
    assert ValidModeChange(this, r10);
    MSR(OSReg(spsr(Monitor)), r10);
    assert spsr_of_state(this).m == User;
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Update current dispatcher
    //-------------------------------------------------------------------------
    LDRglobaladdr(r12, CurAddrspaceOp());
    STRglobal(pagenr, CurAddrspaceOp(), r12, 0);

    s' := s.(g := s.g.(g_cur_dispatcher := pagenr)).(hw := this);
    assert this == s'.hw;
    forall :: validSysState'(s')
    {
        assert s.d == s'.d;
        assert s'.hw.m.addresses == s.hw.m.addresses;
        globalUnmodifiedImpliesCorrespondingPreserved(s.d,s.hw.m,s'.hw.m);
    }
    //-------------------------------------------------------------------------
   
    assert s.d == s'.d;
    assert s'.hw.conf.ttbr0.ptbase == page_paddr(l1p);
    assert s'.hw.conf.scr.ns == Secure; // XXX FIXME TODO
    assert s'.g.g_cur_dispatcher == pagenr;
    assert s'.hw.regs[R0] == arg1 && s'.hw.regs[R1] == arg2 &&
        s'.hw.regs[R2] == arg3; 
    assert s'.g.g_cur_dispatcher == pagenr;
    assert WSMemInvariantExceptAddrspaceAtPage(s.hw,s'.hw, s.d, l1p);
    assert preEntryEnter(s,s',pagenr, arg1, arg2, arg3);

}

#verbatim
//predicate ApplicationUsermodeContinuationInvariant(s:state, r:state)
//    requires ValidState(s)
//    ensures  ApplicationUsermodeContinuationInvariant(s, r) ==> ValidState(r)
//    ensures  ApplicationUsermodeContinuationInvariant(s, r) ==> r.ok
//{
//    ValidState(r) && r.ok
//}
#endverbatim


procedure kom_smc_enter(
    {:register OReg(R0)} pagenr:int,
    {:register OReg(R1)} arg1:int,
    {:register OReg(R2)} arg2:int,
    {:register OReg(R3)} arg3:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost s:SysState)
    returns (ghost s':SysState)
    requires 
        this == s.hw; 
        validSysState'(s);
        mode_of_state(s.hw) == Monitor;
        SaneState(s.hw);
    ensures
        this == s'.hw;
        validSysState'(s');
        tuple(s'.d, err) == smc_enter_premium(s.d, pagenr, arg1, arg2, arg3);
        validEnter(s,s',pagenr,arg1,arg2,arg3);
{
    //reveal_validEnter();
    reveal_smc_enter_premium();
    r5 := pagenr;
    ghost var s_err;
    s_err := smc_enter_err(@r0,@r1,@r2,@r3,@r0,s.(hw := this));
    if(err != sp_op_const(KOM_ERR_SUCCESS()) ) {
        val := sp_op_const(0);
        s' := s_err.(hw := this);
        assert validSysState'(s');
        assert tuple(s'.d, err) == smc_enter(s.d, pagenr, arg1, arg2, arg3);
        assert err != KOM_ERR_SUCCESS();
    } else {
        
        ghost var s1;
        ghost var s2;

        ghost var l1p := l1pOfDispatcher(s.d, pagenr);

        s1 := s_err.(hw := this);  
        assert validSysState'(s1);
        assert this == s1.hw;
        assert SaneState(s1.hw);
        
        assert r5 == pagenr;
        s2 := pre_entry_enter(err,r5,arg1,arg2,arg3,s1);
        assert preEntryEnter(s1,s2,pagenr,arg1,arg2,arg3);

        assert spsr_of_state(s2.hw).m == User;

        
        // s3 := havoc_state(s2);
        // assume entryTransitionEnter(s2,s3);
        // s4 := havoc_state(s3);
        // XXX: workaround dafny crash; the following failing assert was an assume
        // assert s4.d == s3.d && userspaceExecution(s3.hw, s4.hw, s3.d);
        // s' := havoc_state(s4);
        
        // XXX: workaround dafny crash; the following failing asserts were assumes
        // assert validERTransition(s4, s');
        // assert tuple(r0,r1,s'.d) == exceptionHandled(s4);

        MOVS_PCLR_TO_USERMODE_AND_CONTINUE();
        exists ex, s3, s4, s5 :: ValidState(s3) && ValidState(s4) && ValidState(s5)
            && evalEnterUserspace(s2.hw, s3)
            && evalUserspaceExecution(s3, s4)
            && evalExceptionTaken(s4, ex, s5)
            && ApplicationUsermodeContinuationInvariant(s5, this);

        s' :=s2.(hw := this);
       
       /*
        assert SaneConstants();
        assert ValidState(s');
        assert ValidStack(s');
        assert SaneMem(s'.m);
        assert mode_of_state(s') == Monitor;
        
        assert SaneState(s');
        */
    
        assume SaneState(s'.hw);
        
        assert this == s'.hw;
        assert validSysState'(s2);
        assert s2.d == s'.d;
        evalMOVSPCLRUCPreservesPageDb(s2.d, s2.hw, s'.hw, l1p);
        assert validSysState(s');
        assert tuple(s'.d, err) == smc_enter(s.d, pagenr, arg1, arg2, arg3);

        assert validEnter(s,s',pagenr,arg1,arg2,arg3);
    }
}
