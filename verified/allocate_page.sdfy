#verbatim
lemma BoundedAddrspaceRefs(d:PageDb, n:PageNr)
    requires validPageDb(d)
    requires isAddrspace(d, n)
    ensures d[n].entry.refcount <= KOM_SECURE_NPAGES()
{
    reveal_validPageNrs();
    reveal_validPageDb();
    assert addrspaceRefs(d,n) <= validPageNrs();
    assert d[n].entry.refcount == |addrspaceRefs(d,n)|;
    SubsetCardinality(addrspaceRefs(d,n), validPageNrs());
}

function increfAddrspaceEntry(entry:PageDbEntry): PageDbEntry
    requires entry.PageDbEntryTyped? && entry.entry.Addrspace?
{
    entry.(entry := entry.entry.(refcount := entry.entry.refcount + 1))
}

function increfAddrspacePageDb(d:PageDb, n:PageNr): PageDb
    requires validAddrspacePage(d, n)
    requires wellFormedPageDb(d)
    ensures wellFormedPageDb(d)
{
    d[n := increfAddrspaceEntry(d[n])]
}

lemma AllocatePageImpliesIncrefAddrspace(dbin: PageDb, pg: PageNr,
                                         aspg: PageNr, entry: PageDbEntryTyped)
    requires validPageDb(dbin)
    requires validAddrspacePage(dbin, aspg)
    requires allocatePageEntryValid(entry)
    requires allocatePage(dbin, pg, aspg, entry).1 == KOM_ERR_SUCCESS()
    ensures (allocatePage(dbin, pg, aspg, entry).0)[aspg]
        == increfAddrspaceEntry(dbin[aspg]);
{
}
#endverbatim

procedure addrspace_incref(
    {:operand} as_va:addr,
    out {:operand} tmp:int,
    ghost pagedb_in:PageDb,
    ghost pagenr:PageNr)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@as_va, @tmp), 2);
        validPageDb(pagedb_in);
        validAddrspacePage(pagedb_in, pagenr);
        as_va == page_monvaddr(pagenr);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        GlobalsPreservingExcept(old(this),this,set(PageDb()));
        StackPreserving(old(this),this);
        MemPreservingExcept(old(this),this, as_va, as_va + PAGESIZE());
        RegPreservingExcept(old(this),this, set(@tmp));
        pagedb == increfAddrspacePageDb(pagedb_in, pagenr);
        pageDbCorresponds(this.m, pagedb);
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, pagenr);
    pagedb := increfAddrspacePageDb(pagedb_in, pagenr);

    LDR(tmp, as_va, sp_op_const(ADDRSPACE_REF()));

    // help dafny see that refcount++ won't overflow
    forall :: tmp == pagedb_in[pagenr].entry.refcount
        && tmp <= KOM_SECURE_NPAGES()
    {
        reveal_pageContentsCorresponds();
        reveal_pageDbAddrspaceCorresponds();
        assert pageDbAddrspaceCorresponds(pagenr,
                pagedb_in[pagenr].entry, extractPage(this.m, pagenr));
        assert tmp == pagedb_in[pagenr].entry.refcount;
        BoundedAddrspaceRefs(pagedb_in, pagenr);
    }

    ADD(tmp, tmp, 1);
    assert tmp == pagedb[pagenr].entry.refcount;
    STR(tmp, as_va, sp_op_const(ADDRSPACE_REF()));

    forall p :| validPageNr(p) ::
        pageDbEntryCorresponds(pagedb[p], extractPageDbEntry(this.m, p))
    {
        reveal_pageDbEntryCorresponds();
        assert pageDbEntryCorresponds(pagedb_in[p],
                                      extractPageDbEntry(old(this).m, p));
        assert extractPageDbEntry(this.m, p) == extractPageDbEntry(old(this).m, p);
    }

    AllButOnePagePreserving(pagenr, old(this), this);
    assert pageDbCorrespondsExcluding(this.m, pagedb, pagenr);

    forall :: pageContentsCorresponds(pagenr, pagedb[pagenr],
                                extractPage(this.m, pagenr))
    {
        reveal_pageContentsCorresponds();
        reveal_pageDbAddrspaceCorresponds();
    }
}

procedure allocate_page_success(
    {:operand} pagenr:int,
    {:operand} as_va:addr,
    {:operand} typeval:int,
    {:operand} pagedb_base:addr,
    out {:operand} tmp:int,
    out {:operand} tmp2:int,
    ghost pagedb_in:PageDb,
    ghost entry:PageDbEntry)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@pagenr, @as_va, @pagedb_base, @tmp, @tmp2), 5);
        ValidOperand(@typeval) && @typeval is OConst;
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        wellFormedPageDbEntry(entry);
        entry is PageDbEntryTyped && validAddrspacePage(pagedb_in, entry.addrspace);
        allocatePageEntryValid(entry.entry);
        typeval == pageDbEntryTypeVal(entry);
        as_va == page_monvaddr(entry.addrspace);
        pageDbCorresponds(this.m, pagedb_in);
        validPageNr(pagenr) && pageIsFree(pagedb_in, pagenr);
        pagedb_in[entry.addrspace].entry.state == InitState;
    ensures
        GlobalsPreservingExcept(old(this),this,set(PageDb()));
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this),this, set(@tmp, @tmp2));
        pagedb == specPageDb(allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry));
        pageDbCorrespondsExcluding(this.m, pagedb, pagenr);
        pageDbEntryCorresponds(pagedb[pagenr], extractPageDbEntry(this.m, pagenr));
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, entry.addrspace);
    assert specErr(allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry))
        == KOM_ERR_SUCCESS();
    pagedb := specPageDb(allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry));

    // increment AS refcount
    ghost var pagedb_incref;
    pagedb_incref := addrspace_incref(as_va, tmp, pagedb_in, entry.addrspace);
    assert GlobalsPreservingExcept(old(this),this,set(PageDb()));
    AllocatePageImpliesIncrefAddrspace(pagedb_in, pagenr, entry.addrspace, entry.entry);
    assert pagedb_incref[entry.addrspace] == pagedb[entry.addrspace];
    assert pageDbCorrespondsOnly(this.m, pagedb, entry.addrspace);
    assert pageDbCorrespondsExcluding(this.m, pagedb_in, entry.addrspace);

    // remember that no other pages changed
    ghost var midway := this;
    AllButOnePagePreserving(entry.addrspace, old(this), midway);

    // update pagedb
    tmp := typeval;
    tmp2 := sp_op_const(PAGEDB_ENTRY_SIZE());
    assert pagenr < 256 && tmp2 == 8; // sigh.
    MUL(tmp2,pagenr,tmp2);
    assert tmp2 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
    STRglobal(tmp, PageDb(), pagedb_base, tmp2);
    ADD(tmp2, tmp2, sp_op_const(PAGEDB_ENTRY_ADDRSPACE()));
    assert tmp2 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
    STRglobal(as_va, PageDb(), pagedb_base, tmp2);

    // no pages changed across pagedb update
    assert this.m.addresses == midway.m.addresses;

    forall :: pageDbEntryCorresponds(pagedb[pagenr], extractPageDbEntry(this.m, pagenr))
    {
        assert extractPageDbEntry(this.m, pagenr)
            == seq(pageDbEntryTypeVal(entry), as_va);
        reveal_pageDbEntryCorresponds();
    }

    forall :: pageDbCorrespondsOnly(this.m, pagedb, entry.addrspace) {
        assert pageDbCorrespondsOnly(midway.m, pagedb, entry.addrspace);
        assert extractPageDbEntry(this.m, entry.addrspace)
            == extractPageDbEntry(midway.m, entry.addrspace);
        assert extractPage(this.m, entry.addrspace)
            == extractPage(midway.m, entry.addrspace);
    }

    forall :: pageDbCorrespondsExcluding(this.m, pagedb, pagenr)
    {
        assert forall i :: validPageNr(i) && i != entry.addrspace
        ==> extractPage(this.m, i) == extractPage(old(this.m), i);
    }
}

procedure allocate_page(
    {:operand} pagenr:int,
    {:operand} as_pagenr:int,
    {:operand} typeval:int,
    {:operand} pagedb_base:addr,
    out {:operand} tmp:int,
    out {:operand} tmp2:int,
    out {:operand} err:int,
    ghost pagedb_in:PageDb,
    ghost entry:PageDbEntry)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        @tmp2 != OLR && @tmp != OLR && @as_pagenr != OLR && @err != OLR;
        @tmp2 != OSP && @tmp != OSP && @as_pagenr != OSP && @err != OSP;
        DistinctRegOperands(set(@pagenr, @as_pagenr, @pagedb_base, @tmp, @tmp2, @err), 6);
        ValidOperand(@typeval) && @typeval is OConst;
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        wellFormedPageDbEntry(entry);
        entry is PageDbEntryTyped && validAddrspacePage(pagedb_in, entry.addrspace);
        allocatePageEntryValid(entry.entry);
        typeval == pageDbEntryTypeVal(entry);
        as_pagenr == entry.addrspace;
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        GlobalsPreservingExcept(old(this),this,set(PageDb()));
        StackPreserving(old(this),this);
        RegPreservingExcept(old(this),this, set(@tmp, @tmp2, @err));
        tuple(pagedb, err)
            == allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry);
        // we update all of the pagedb except the target page itself,
        // which is the responsibility of the caller
        if err == KOM_ERR_SUCCESS()
        then pageDbCorrespondsExcluding(this.m, pagedb, pagenr)
            && pageDbEntryCorresponds(pagedb[pagenr],
                                     extractPageDbEntry(this.m, pagenr))
        else pagedb == pagedb_in && pageDbCorresponds(this.m, pagedb);
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, entry.addrspace);
    pagedb := pagedb_in;

    if (pagenr >= sp_op_const(KOM_SECURE_NPAGES())) {
        err := sp_op_const(KOM_ERR_INVALID_PAGENO());
    } else {
        assert validPageNr(pagenr);
        // NB: using err as a second tmp reg here
        err := sp_op_const(PAGEDB_ENTRY_SIZE());
        assert pagenr < 256 && err == 8; // sigh.
        MUL(err,pagenr,err);
        assert err == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE();
        assert pagedb_base == old(pagedb_base) == AddressOfGlobal(PageDb());
        LDRglobal(tmp, PageDb(), pagedb_base, err);

        forall :: tmp == pageDbEntryTypeVal(pagedb_in[pagenr])
        {
            reveal_pageDbEntryCorresponds();
            PageDbCorrespondsImpliesEntryCorresponds(this.m, pagedb_in, pagenr);
        }

        if (tmp != sp_op_const(KOM_PAGE_FREE())) {
            err := sp_op_const(KOM_ERR_PAGEINUSE());
        } else {
            page_monvaddr_impl(tmp2, as_pagenr, err);

            LDR(tmp, tmp2, sp_op_const(ADDRSPACE_STATE()));
            forall :: tmp == pageDbAddrspaceStateVal(pagedb[entry.addrspace].entry.state)
            {
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            if (tmp != sp_op_const(KOM_ADDRSPACE_INIT())) {
                err := sp_op_const(KOM_ERR_ALREADY_FINAL());
            } else {
                assert pageDbCorresponds(this.m, pagedb);
                assert DistinctRegOperands(set(@pagenr, @as_pagenr,
                    @pagedb_base, @tmp, @tmp2, @err), 6);
                pagedb := allocate_page_success(pagenr, tmp2, typeval,
                                pagedb_base, tmp, err, pagedb_in, entry);
                err := sp_op_const(KOM_ERR_SUCCESS());
            }
        }
    }
}
