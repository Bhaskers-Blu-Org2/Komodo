include {:verbatim} "Sets.dfy"
include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"
include "ARMdecls-unrefined.sdfy"
include "kom_utils.sdfy"

#verbatim
lemma BoundedAddrspaceRefs(d:PageDb, n:PageNr)
    requires validPageDb(d)
    requires isAddrspace(d, n)
    ensures d[n].entry.refcount <= KOM_SECURE_NPAGES
{
    reveal_validPageNrs();
    reveal_validPageDb();
    assert addrspaceRefs(d,n) <= validPageNrs();
    assert d[n].entry.refcount == |addrspaceRefs(d,n)|;
    SubsetCardinality(addrspaceRefs(d,n), validPageNrs());
}

function increfAddrspaceEntry(entry:PageDbEntry): PageDbEntry
    requires entry.PageDbEntryTyped? && entry.entry.Addrspace?
{
    entry.(entry := entry.entry.(refcount := entry.entry.refcount + 1))
}

function increfAddrspacePageDb(d:PageDb, n:PageNr): PageDb
    requires validAddrspacePage(d, n)
    requires wellFormedPageDb(d)
    ensures wellFormedPageDb(d)
{
    d[n := increfAddrspaceEntry(d[n])]
}

lemma AllocatePageImpliesIncrefAddrspace(dbin: PageDb, pg: PageNr,
                                         aspg: PageNr, entry: PageDbEntryTyped)
    requires validPageDb(dbin)
    requires validAddrspacePage(dbin, aspg)
    requires allocatePageEntryValid(entry)
    requires allocatePage(dbin, pg, aspg, entry).1 == KOM_ERR_SUCCESS
    ensures (allocatePage(dbin, pg, aspg, entry).0)[aspg]
        == increfAddrspaceEntry(dbin[aspg]);
{
}
#endverbatim

procedure addrspace_incref(
    operand as_va:addr,
    out operand tmp:int,
    ghost pagedb_in:PageDb,
    ghost pagenr:PageNr)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        DistinctRegOperands(set(@as_va, @tmp), 2);
        validPageDb(pagedb_in);
        validAddrspacePage(pagedb_in, pagenr);
        as_va == page_monvaddr(pagenr);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        GlobalsInvariant(old(this),this);
        SmcProcedureInvariant(old(this),this);
        MemPreservingExcept(old(this),this, as_va, as_va + PAGESIZE);
        RegPreservingExcept(old(this),this, set(@tmp));
        pagedb == increfAddrspacePageDb(pagedb_in, pagenr);
        pageDbCorresponds(this.m, pagedb);
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, pagenr);
    pagedb := increfAddrspacePageDb(pagedb_in, pagenr);

    LDR(tmp, as_va, const(ADDRSPACE_REF));

    // help dafny see that refcount++ won't overflow
    forall :: tmp == pagedb_in[pagenr].entry.refcount
        && tmp <= KOM_SECURE_NPAGES
    {
        reveal_pageContentsCorresponds();
        reveal_pageDbAddrspaceCorresponds();
        assert pageDbAddrspaceCorresponds(pagenr,
                pagedb_in[pagenr].entry, extractPage(this.m, pagenr));
        assert tmp == pagedb_in[pagenr].entry.refcount;
        BoundedAddrspaceRefs(pagedb_in, pagenr);
    }

    ADD(tmp, tmp, 1);
    assert tmp == pagedb[pagenr].entry.refcount;
    STR(tmp, as_va, const(ADDRSPACE_REF));

    forall p :| validPageNr(p) ::
        pageDbEntryCorresponds(pagedb[p], extractPageDbEntry(this.m, p))
    {
        reveal_pageDbEntryCorresponds();
        assert pageDbEntryCorresponds(pagedb_in[p],
                                      extractPageDbEntry(old(this).m, p));
        assert extractPageDbEntry(this.m, p) == extractPageDbEntry(old(this).m, p);
    }

    AllButOnePagePreserving(pagenr, old(this), this);
    assert pageDbCorrespondsExcluding(this.m, pagedb, pagenr);

    forall :: pageContentsCorresponds(pagenr, pagedb[pagenr],
                                extractPage(this.m, pagenr))
    {
        reveal_pageContentsCorresponds();
        reveal_pageDbAddrspaceCorresponds();
    }
}

procedure allocate_page_success(
    operand pagenr:int,
    operand as_va:addr,
    operand typeval:int,
    operand pagedb_base:addr,
    out operand tmp:int,
    out operand tmp2:int,
    ghost pagedb_in:PageDb,
    ghost entry:PageDbEntry)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        //DistinctRegOperands(set(@pagenr, @as_va, @pagedb_base, @tmp, @tmp2), 5);
        ValidRegOperand(@pagenr) && ValidRegOperand(@as_va) && ValidRegOperand(@pagedb_base);
        ValidRegOperand(@tmp) && ValidRegOperand(@tmp2);
        @tmp != @pagenr && @tmp != @as_va && @tmp != @pagedb_base && @tmp != @tmp2;
        @tmp2 != @pagenr && @tmp2 != @as_va && @tmp2 != @pagedb_base;
        @tmp != @sp && @tmp2 != @sp && @as_va != @sp;

        ValidOperand(@typeval) && @typeval is OConst;
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        wellFormedPageDbEntry(entry);
        entry is PageDbEntryTyped && validAddrspacePage(pagedb_in, entry.addrspace);
        allocatePageEntryValid(entry.entry);
        typeval == pageDbEntryTypeVal(entry);
        as_va == page_monvaddr(entry.addrspace);
        pageDbCorresponds(this.m, pagedb_in);
        validPageNr(pagenr) && pageIsFree(pagedb_in, pagenr);
        pagedb_in[entry.addrspace].entry.state == InitState;
    ensures
        GlobalsPreservingExcept(old(this),this,set(PageDb()));
        SmcProcedureInvariant(old(this),this);
        RegPreservingExcept(old(this),this, set(@tmp, @tmp2));
        pagenr == old(pagenr); // redundant with the above, but makes life easier
        pagedb == specPageDb(allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry));
        pageDbCorrespondsExcluding(this.m, pagedb, pagenr);
        pageDbEntryCorresponds(pagedb[pagenr], extractPageDbEntry(this.m, pagenr));
{
    ValidPageDbImpliesValidAddrspace(pagedb_in, entry.addrspace);
    ghost var res := allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry);
    assert specErr(res) == KOM_ERR_SUCCESS;
    pagedb := specPageDb(res);

    // increment AS refcount
    ghost var pagedb_incref;
    pagedb_incref := addrspace_incref(as_va, tmp, pagedb_in, entry.addrspace);
    AllocatePageImpliesIncrefAddrspace(pagedb_in, pagenr, entry.addrspace, entry.entry);
    assert pagedb_incref[entry.addrspace] == pagedb[entry.addrspace];
    assert pageDbCorrespondsOnly(this.m, pagedb, entry.addrspace);
    assert pageDbCorrespondsExcluding(this.m, pagedb_in, entry.addrspace);

    // remember that no other pages changed
    ghost var midway := this;
    AllButOnePagePreserving(entry.addrspace, old(this), midway);
    assert RegPreservingExcept(old(this), midway, set(@tmp));

    // update pagedb
    tmp := typeval;
    lemma_LeftShift3(pagenr);
    LSL(tmp2,pagenr,const(PAGEDB_ENTRY_SHIFT));
    assert tmp2 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE;
    STRglobal(tmp, PageDb(), pagedb_base, tmp2);
    ADD(tmp2, tmp2, const(PAGEDB_ENTRY_ADDRSPACE));
    assert tmp2 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE;
    STRglobal(as_va, PageDb(), pagedb_base, tmp2);

    // no pages changed across pagedb update
    assert this.m.addresses == midway.m.addresses;
    assert RegPreservingExcept(midway, this, set(@tmp, @tmp2));

    forall :: pageDbEntryCorresponds(pagedb[pagenr], extractPageDbEntry(this.m, pagenr))
    {
        assert extractPageDbEntry(this.m, pagenr)
            == seq(pageDbEntryTypeVal(entry), as_va);
        reveal_pageDbEntryCorresponds();
    }

    forall :: pageDbCorrespondsOnly(this.m, pagedb, entry.addrspace) {
        assert pageDbCorrespondsOnly(midway.m, pagedb, entry.addrspace);
        assert extractPageDbEntry(this.m, entry.addrspace)
            == extractPageDbEntry(midway.m, entry.addrspace);
        assert extractPage(this.m, entry.addrspace)
            == extractPage(midway.m, entry.addrspace);
    }

    forall :: pageDbCorrespondsExcluding(this.m, pagedb, pagenr)
    {
        assert forall i :: validPageNr(i) && i != entry.addrspace
        ==> extractPage(this.m, i) == extractPage(old(this.m), i);
    }
}

procedure allocate_page(
    operand pagenr:int,
    operand as_pagenr:int,
    operand typeval:int,
    operand pagedb_base:addr,
    out operand tmp:int,
    out operand tmp2:int,
    out operand err:int,
    ghost pagedb_in:PageDb,
    ghost entry:PageDbEntry)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
    requires
        //DistinctRegOperands(set(@pagenr, @as_pagenr, @pagedb_base, @tmp, @tmp2, @err), 6);
        ValidRegOperand(@pagenr) && ValidRegOperand(@as_pagenr) && ValidRegOperand(@pagedb_base);
        ValidRegOperand(@tmp) && ValidRegOperand(@tmp2) && ValidRegOperand(@err);
        @tmp != @tmp2 && @tmp != @pagenr && @tmp != @as_pagenr && @tmp != @pagedb_base;
        @tmp2 != @err && @tmp2 != @pagenr && @tmp2 != @as_pagenr && @tmp2 != @pagedb_base;
        @err != @tmp && @err != @pagenr && @err != @as_pagenr && @err != @pagedb_base;
        @tmp != @sp && @tmp2 != @sp && @err != @sp;

        ValidOperand(@typeval) && @typeval is OConst;
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        wellFormedPageDbEntry(entry);
        entry is PageDbEntryTyped && validAddrspacePage(pagedb_in, entry.addrspace);
        allocatePageEntryValid(entry.entry);
        typeval == pageDbEntryTypeVal(entry);
        as_pagenr == entry.addrspace;
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        GlobalsPreservingExcept(old(this),this,set(PageDb()));
        SmcProcedureInvariant(old(this),this);
        RegPreservingExcept(old(this),this, set(@tmp, @tmp2, @err));
        pagenr == old(pagenr); // redundant with the above, but makes life easier
        tuple(pagedb, err)
            == allocatePage(pagedb_in, pagenr, entry.addrspace, entry.entry);
        // we update all of the pagedb except the target page itself,
        // which is the responsibility of the caller
        if err == KOM_ERR_SUCCESS
        then pageDbCorrespondsExcluding(this.m, pagedb, pagenr)
            && pageDbEntryCorresponds(pagedb[pagenr],
                                     extractPageDbEntry(this.m, pagenr))
        else pagedb == pagedb_in && pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    ghost var specRes := allocatePage(pagedb, pagenr, entry.addrspace, entry.entry);
    ValidPageDbImpliesValidAddrspace(pagedb, entry.addrspace);

    // unpack DistinctRegOperands to help the verifier
    /*
    assert @tmp != @tmp2 && @tmp != @pagenr && @tmp != @as_pagenr && @tmp != @pagedb_base;
    assert @tmp2 != @err && @tmp2 != @pagenr && @tmp2 != @as_pagenr && @tmp2 != @pagedb_base;
    assert @err != @tmp && @err != @pagenr && @err != @as_pagenr && @err != @pagedb_base; */

    if (pagenr >= const(KOM_SECURE_NPAGES)) {
        assert !validPageNr(pagenr);
        err := const(KOM_ERR_INVALID_PAGENO);
        assert err == specErr(specRes);
    } else {
        assert validPageNr(pagenr);
        // NB: using err as a second tmp reg here
        lemma_LeftShift3(pagenr);
        LSL(err,pagenr,const(PAGEDB_ENTRY_SHIFT));
        assert err == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_TYPE;
        assert pagedb_base == old(pagedb_base) == AddressOfGlobal(PageDb());
        LDRglobal(tmp, PageDb(), pagedb_base, err);

        forall :: tmp == pageDbEntryTypeVal(pagedb_in[pagenr])
        {
            reveal_pageDbEntryCorresponds();
            PageDbCorrespondsImpliesEntryCorresponds(this.m, pagedb_in, pagenr);
        }

        ghost var midway1 := this;
        assert RegPreservingExcept(old(this), midway1, set(@tmp, @err));

        if (tmp != const(KOM_PAGE_FREE)) {
            assert !pageIsFree(pagedb, pagenr);
            err := const(KOM_ERR_PAGEINUSE);
            assert err == specErr(specRes);
        } else {
            assert pageIsFree(pagedb, pagenr);
            page_monvaddr_impl(tmp2, as_pagenr, err);
            LDR(tmp, tmp2, const(ADDRSPACE_STATE));
            ghost var addrsp := pagedb[entry.addrspace].entry;
            forall :: tmp == pageDbAddrspaceStateVal(addrsp.state)
            {
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            ghost var midway2 := this;
            assert RegPreservingExcept(midway1, midway2, set(@tmp, @tmp2, @err));

            if (tmp != const(KOM_ADDRSPACE_INIT)) {
                assert addrsp.state != InitState;
                err := const(KOM_ERR_ALREADY_FINAL);
                assert err == specErr(specRes);
            } else {
                assert addrsp.state == InitState;
                pagedb := allocate_page_success(pagenr, tmp2, typeval,
                                pagedb_base, tmp, err, pagedb_in, entry);
                err := const(KOM_ERR_SUCCESS);
            }

            assert RegPreservingExcept(midway2, this, set(@tmp, @tmp2, @err));
        }
    }
}
