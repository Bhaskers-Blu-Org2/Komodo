procedure pre_entry_resume(
    {:register OReg(R1)} pagenr:int,
    ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
        smc_enter_err(pagedb, pagenr, true) == KOM_ERR_SUCCESS();
    ensures
        AddrMemInvariant(old(this),this);
        GlobalsPreservingExcept(old(this),this, set(CurDispatcherOp()));
        pageDbCorresponds(this.m, pagedb);
        StackPreserving(old(this),this);
        preEntryResume(old(this), this, pagedb, pagenr);
        spsr_of_state(this).m == User;
        sp == old(sp);
{
    ghost var dispPg := pagenr;
    assert validPageNr(dispPg);
    assert validDispatcherPage(pagedb, dispPg);
    assert !hasStoppedAddrspace(pagedb, dispPg);

    //-------------------------------------------------------------------------
    //  Switch addrspace
    //-------------------------------------------------------------------------
    switch_addrspace(pagenr, true, pagedb);
    assert pagenr == old(pagenr);

    //-------------------------------------------------------------------------
    // Update current dispatcher
    //-------------------------------------------------------------------------
    LDRglobaladdr(r2, CurDispatcherOp());
    STRglobal(pagenr, CurDispatcherOp(), r2, 0);
    // help dafny see pagedb invariant
    globalUnmodifiedImpliesCorrespondingPreserved(pagedb,old(this).m,this.m);

    //-------------------------------------------------------------------------
    // Restore SPSR
    //-------------------------------------------------------------------------
    page_monvaddr_impl(lr,pagenr,r0);
    assert validDispatcherContext(pagedb[dispPg].entry.ctxt) by { reveal_validPageDb(); }

    LDR(r0,lr,sp_op_const(DISP_CTXT_PSR()));
    assert r0 == pagedb[dispPg].entry.ctxt.cpsr by
    {
        assert pageDbCorrespondsOnly(this.m,pagedb,dispPg);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(dispPg,pagedb[dispPg],
            extractPage(this.m,dispPg));
        reveal_pageDbDispatcherCorresponds();
    }

    assert decode_mode'(psr_mask_mode(pagedb[dispPg].entry.ctxt.cpsr)) == Just(User);
    MSR(OSReg(spsr(Monitor)),r0);
    assert this.sregs[spsr(Monitor)] == pagedb[dispPg].entry.ctxt.cpsr;
    assert spsr_of_state(this).m == User;

    //-------------------------------------------------------------------------
    // Restore integer context
    //-------------------------------------------------------------------------
    ghost var disp := pagedb[dispPg].entry;

    LDR(r0,lr,sp_op_const(DISP_CTXT_LR()));
    MSR(lr_usr,r0);

    LDR(r0,lr,sp_op_const(DISP_CTXT_SP()));
    MSR(sp_usr,r0);

    LDR(r0,lr,sp_op_const(DISP_CTXT_R0()));
    LDR(r1,lr,sp_op_const(DISP_CTXT_R1()));
    LDR(r2,lr,sp_op_const(DISP_CTXT_R2()));
    LDR(r3,lr,sp_op_const(DISP_CTXT_R3()));
    LDR(r4,lr,sp_op_const(DISP_CTXT_R4()));
    LDR(r5,lr,sp_op_const(DISP_CTXT_R5()));
    LDR(r6,lr,sp_op_const(DISP_CTXT_R6()));
    LDR(r7,lr,sp_op_const(DISP_CTXT_R7()));
    LDR(r8,lr,sp_op_const(DISP_CTXT_R8()));
    LDR(r9,lr,sp_op_const(DISP_CTXT_R9()));
    LDR(r10,lr,sp_op_const(DISP_CTXT_R10()));
    LDR(r11,lr,sp_op_const(DISP_CTXT_R11()));
    LDR(r12,lr,sp_op_const(DISP_CTXT_R12()));
    LDR(lr,lr,sp_op_const(DISP_CTXT_PC()));

    reveal_ValidRegState(); 
    assert r0 == disp.ctxt.regs[R0] && r1 == disp.ctxt.regs[R1] &&
           r2 == disp.ctxt.regs[R2] && r3 == disp.ctxt.regs[R3] &&
           r4 == disp.ctxt.regs[R4] && r5 == disp.ctxt.regs[R5] &&
           r6 == disp.ctxt.regs[R6] && r7 == disp.ctxt.regs[R7] &&
           r8 == disp.ctxt.regs[R8] && r9 == disp.ctxt.regs[R9] &&
           r10 == disp.ctxt.regs[R10] && r11 == disp.ctxt.regs[R11] &&
           r12 == disp.ctxt.regs[R12]
           && this.regs[LR(User)] == disp.ctxt.regs[LR(User)]
           && this.regs[SP(User)] == disp.ctxt.regs[SP(User)]
           && lr == pagedb[dispPg].entry.ctxt.pc
    by {
        assert pageDbCorrespondsOnly(this.m,pagedb,dispPg);
        assert validDispatcherPage(pagedb,dispPg);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(dispPg,pagedb[dispPg],
            extractPage(this.m,dispPg));
        reveal_pageDbDispatcherCorresponds();
    }
}

#verbatim
lemma lemma_validResumePre(s0:state, s1:state, sd:PageDb, r:state, rd:PageDb, dp:word)
    requires ValidState(s0) && ValidState(s1) && ValidState(r) && validPageDb(sd)
    requires smc_enter_err(sd, dp, true) == KOM_ERR_SUCCESS()
    requires validResume(SysState(s1, sd), SysState(r, rd), dp)
    ensures validResume(SysState(s0, sd), SysState(r, rd), dp)
{
    reveal_validResume();
}
#endverbatim

procedure smc_resume_success(
    {:register OReg(R1)} pagenr:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost pagedb_in: PageDb,
    ghost stack_bytes: int)
    returns (ghost pagedb: PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        stack_bytes >= banked_regs_framesize();
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        AUCIdef();
        smc_enter_err(pagedb_in, pagenr, true) == KOM_ERR_SUCCESS();
    ensures
        EnterResumeSmcProcedureInvariant(old(this), this);
        validResume(SysState(old(this), pagedb_in), SysState(this, pagedb), old(pagenr));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    pagedb := pagedb_in;
    ghost var dispPg := old(pagenr);
    ghost var exs;
    assert nonStoppedDispatcher(pagedb, dispPg);

    ghost var stack_bytes_local;
    stack_bytes_local := stack_banked_regs(r0, stack_bytes);
    lemma_SameMemAndGlobalsPreservesPageDb(old(this), this, pagedb);

    ghost var s0 := this;
    pre_entry_resume(pagenr,pagedb);
    ghost var s1 := this;
    assert preEntryResume(old(this),this,pagedb,dispPg);

    MOVS_PCLR_TO_USERMODE_AND_CONTINUE();
    lemma_evalMOVSPCLRUC(s1, this, pagedb_in, dispPg);
    exs, pagedb := lemma_validResume(s0, s1, this, pagedb_in, dispPg);
    ghost var s6 := this;
    ghost var s6_sp := sp;

    lemma_wellformed_banked_regs_stackframe_preserved(s0.m, this.m, sp);
    stack_bytes_local := unstack_banked_regs(r2, stack_bytes_local);
    assert stack_bytes_local == stack_bytes;
    lemma_SameMemAndGlobalsPreservesPageDb(s6, this, pagedb);

    assert StackPreserving(old(this), this);
    lemma_stackunstack_banked_regs(old(this), s0.m, this, s6.m, s6_sp);

    leave_secure_world(r2);

    lemma_validResumePre(old(this), s0, pagedb_in, s6, pagedb, dispPg);

    assert validExceptionTransition(SysState(s6, pagedb), SysState(this, pagedb), dispPg)
        by { reveal_validExceptionTransition(); }
    lemma_validResumePost(old(this), pagedb_in, s6, pagedb, this, dispPg);
}


procedure kom_smc_resume(
    {:register OReg(R1)} disppg:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost pagedb_in:PageDb,
    ghost stack_bytes: int)
    returns (ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
        StackBytesRemaining(this, stack_bytes);
    requires
        stack_bytes >= banked_regs_framesize();
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
        AUCIdef();
        this.conf.scr.ns == NotSecure; // FIXME: cleanup
    ensures
        EnterResumeSmcProcedureInvariant(old(this), this);
        smc_resume(old(this), pagedb_in, this, pagedb, old(disppg));
        validPageDb(pagedb);
        pageDbCorresponds(this.m, pagedb);
{
    r5 := 1; // do an error check for resume
    smc_enter_err(disppg,r5,err,true,pagedb_in);
    if(err != sp_op_const(KOM_ERR_SUCCESS()) ) {
        pagedb := pagedb_in;
        val := 0;
    } else {
        ghost var s0 := this;
        pagedb := smc_resume_success(disppg, err, val, pagedb_in, stack_bytes);
        lemma_validResumePre(old(this), s0, pagedb_in, this, pagedb, old(disppg));
    }
}
