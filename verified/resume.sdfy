procedure pre_entry_resume(
    {:register OReg(R0)} err:int,
    {:register OReg(R5)} pagenr:int,
    ghost s:SysState)
    returns (ghost s':SysState)
    requires
        this == s.hw;
        mode_of_state(s.hw) == Monitor;
        validSysState'(s);
        SaneState(s.hw);
        specErr(smc_resume_premium(s.d, pagenr)) == 
            KOM_ERR_SUCCESS();
        err == KOM_ERR_SUCCESS();
    ensures
        this == s'.hw;
        validSysState'(s');
        SaneState(s'.hw);
        preEntryResume(s,s',pagenr);
        spsr_of_state(s'.hw).m == User;
        s'.g.g_sps  == s.g.g_sps;
        s'.g.g_lrs  == s.g.g_lrs;
        s'.g.g_psrs == s.g.g_psrs;
        OperandContents(s'.hw, OLR) ==
            s'.d[s'.g.g_cur_dispatcher].entry.ctxt.pc;
{
    reveal_validPageDb();
    reveal_ValidRegState(); 
    reveal_ValidSRegState();
    ghost var d := s.d;
    assert validDispatcherPage(s.d, pagenr);
    assert !hasStoppedAddrspace(s.d, pagenr);
    ghost var l1p := l1pOfDispatcher(s.d, pagenr);

    // TODO: read r12, clear lsb, store into MCR
    // MRC(r12,scr);
    
    r10 := 0;
    MCR(OSReg(scr), r10);
    forall :: this.conf.scr.ns == Secure
    {
        //FIXME
        assume false;
        assert BitwiseAnd(r10,1) != 1;
        assert decode_scr(r10) == SCR(Secure, false, false);
    }
  
    //-------------------------------------------------------------------------
    // load l1p into ttbr0
    //-------------------------------------------------------------------------
    LDRglobaladdr(r12, PageDb());
    assert validPageNr(pagenr);
    r11 := sp_op_const(PAGEDB_ENTRY_SIZE());
    MUL(r10,pagenr,r11);
    assert r10 == G_PAGEDB_ENTRY(pagenr);
    ADD(r9, r10, sp_op_const(PAGEDB_ENTRY_ADDRSPACE())); 
    assert r9 == G_PAGEDB_ENTRY(pagenr) + PAGEDB_ENTRY_ADDRSPACE();
    WordAlignedAdd_(G_PAGEDB_ENTRY(pagenr), PAGEDB_ENTRY_ADDRSPACE(), r9);

    LDRglobal(r11, PageDb(), r12, r9);
    ghost var addrspace := s.d[pagenr].addrspace;
    forall :: r11 == page_monvaddr(addrspace) && WordAligned(r11) 
        && PageAligned(r11)
    {
        reveal_pageDbEntryCorresponds(); reveal_pageContentsCorresponds();
        reveal_validPageDb();
        assert validAddrspacePage(s.d, s.d[pagenr].addrspace);
    }

    forall :: ValidMem(r11 + ADDRSPACE_L1PT_PHYS())
        { reveal_validPageDb(); } 

    // page_monvaddr_impl(r9,r11,r10); 
    LDR(r10,r11,sp_op_const(ADDRSPACE_L1PT_PHYS()));

    forall :: r10 == page_paddr(d[addrspace].entry.l1ptnr)
    {
        assert pageDbCorrespondsOnly(this.m, d, addrspace);
        assert validAddrspacePage(d, addrspace);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(addrspace, d[addrspace],
            extractPage(this.m, addrspace));
        reveal_pageDbAddrspaceCorresponds();
    }
    
    assert r10 == page_paddr(l1p);

    // reveal_pageContentsCorresponds();
    // reveal_pageDbAddrspaceCorresponds();
    MSR(OSReg(ttbr0), r10);

    assert isUInt32(r10);
    assert isUInt32(0xffff_f000);
    forall :: r10 == BitwiseAnd(r10, 0xffff_f000){
        assume false;
    }
    assert this.conf.ttbr0.ptbase == page_paddr(l1p);
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Set SPSR to Usermode
    //-------------------------------------------------------------------------
    r10 := 0x10;
    assume psr_mask_mode(r10) == 0x10;
    assert decode_mode(psr_mask_mode(r10)) == User;
    assert ValidModeChange'(this, User);
    assert ValidModeChange(this, r10);
    MSR(OSReg(spsr(Monitor)), r10);
    assert spsr_of_state(this).m == User;
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Load pc from context into OLR
    //-------------------------------------------------------------------------
    page_monvaddr_impl(r10,pagenr,r11);
    // XXX TODO this should be the offset for the pc from context not the 
    // entrypoint. Need to impl this in pagedb.i first 
    assert DISPATCHER_ENTRYPOINT() == 4;
    assert ValidMem(r10 + DISPATCHER_ENTRYPOINT());
    LDR(r11,r10,sp_op_const(DISPATCHER_ENTRYPOINT()));
    forall :: r11 == d[pagenr].entry.ctxt.pc
    {
        assume false;
        assert pageDbCorrespondsOnly(this.m,d,pagenr);
        assert validDispatcherPage(d,pagenr);
        reveal_pageContentsCorresponds();
        assert pageContentsCorresponds(pagenr,d[pagenr],
            extractPage(this.m,pagenr));
        reveal_pageDbDispatcherCorresponds();
    }
    
    lr := r11;
    assert OperandContents(this, OLR) ==
        d[pagenr].entry.ctxt.pc;

    //-------------------------------------------------------------------------
    // Update current dispatcher
    //-------------------------------------------------------------------------
    LDRglobaladdr(r12, CurAddrspaceOp());
    STRglobal(pagenr, CurAddrspaceOp(), r12, 0);
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Restore context
    //-------------------------------------------------------------------------
    ghost var disp := s.d[pagenr].entry;
    forall :: this.sregs[cpsr] == disp.ctxt.cpsr
    {
        // TODO implement me
        assume false;
    }
    
    forall :: this.regs == disp.ctxt.regs
        [LR(FIQ)        := s.hw.regs[LR(FIQ)]]
        [LR(IRQ)        := s.hw.regs[LR(IRQ)]]
        [LR(Supervisor) := s.hw.regs[LR(Supervisor)]]
        [LR(Abort)      := s.hw.regs[LR(Abort)]]
        [LR(Undefined)  := s.hw.regs[LR(Undefined)]]
        [LR(Monitor)    := s.hw.regs[LR(Monitor)]]
        [SP(FIQ)        := s.hw.regs[SP(FIQ)]]
        [SP(IRQ)        := s.hw.regs[SP(IRQ)]]
        [SP(Supervisor) := s.hw.regs[SP(Supervisor)]]
        [SP(Abort)      := s.hw.regs[SP(Abort)]]
        [SP(Undefined)  := s.hw.regs[SP(Undefined)]]
        [SP(Monitor)    := s.hw.regs[SP(Monitor)]]
    {
        // TODO implement me
        assume false;
    }
    //-------------------------------------------------------------------------
    
    s' := s.(g := s.g.(g_cur_dispatcher := pagenr)).(hw := this);
    assert this == s'.hw;
    forall :: validSysState'(s')
    {
        assert s.d == s'.d;
        assert s'.hw.m.addresses == s.hw.m.addresses;
        globalUnmodifiedImpliesCorrespondingPreserved(s.d,s.hw.m,s'.hw.m);
    }

    
    assert s'.d == s.d;
    assert s'.hw.conf.ttbr0.ptbase == page_paddr(l1p);
    assert s'.hw.conf.scr.ns == Secure;

    assert s'.g.g_cur_dispatcher == pagenr;
   
    assert s'.hw.regs == disp.ctxt.regs
        [LR(FIQ)        := s.hw.regs[LR(FIQ)]]
        [LR(IRQ)        := s.hw.regs[LR(IRQ)]]
        [LR(Supervisor) := s.hw.regs[LR(Supervisor)]]
        [LR(Abort)      := s.hw.regs[LR(Abort)]]
        [LR(Undefined)  := s.hw.regs[LR(Undefined)]]
        [LR(Monitor)    := s.hw.regs[LR(Monitor)]]
        [SP(FIQ)        := s.hw.regs[SP(FIQ)]]
        [SP(IRQ)        := s.hw.regs[SP(IRQ)]]
        [SP(Supervisor) := s.hw.regs[SP(Supervisor)]]
        [SP(Abort)      := s.hw.regs[SP(Abort)]]
        [SP(Undefined)  := s.hw.regs[SP(Undefined)]]
        [SP(Monitor)    := s.hw.regs[SP(Monitor)]];
    
    assert s'.hw.sregs[cpsr] == disp.ctxt.cpsr;
    
    assert WSMemInvariantExceptAddrspaceAtPage(s.hw, s'.hw, s.d, l1p);
}

procedure kom_smc_resume(
    {:register OReg(R0)} pagenr:int,
    out {:register OReg(R0)} err:int,
    out {:register OReg(R1)} val:int,
    ghost s:SysState)
    returns (ghost s':SysState)
    requires 
        this == s.hw; 
        validSysState'(s);
        mode_of_state(s.hw) == Monitor;
        SaneState(s.hw);
        AUCIdef();
    ensures
        this == s'.hw;
        validSysState'(s');
        specErr(smc_resume_premium(s.d, pagenr)) != KOM_ERR_SUCCESS() ==>
            tuple(s'.d, err) == smc_resume_premium(s.d, pagenr);
        validResume(s,s',pagenr);
{
    reveal_smc_enter_premium();
    r5 := pagenr;
    ghost var s_err;
    r4 := 1; // do an error check for resume, not enter
    s_err := smc_enter_err(@r0,@r1,@r2,@r3,@r4,@r0,s.(hw := this));
    if(err != sp_op_const(KOM_ERR_SUCCESS()) ) {
        val := sp_op_const(0);
        s' := s_err.(hw := this);
        assert validSysState'(s');
        assert tuple(s'.d, err) == smc_resume(s.d, pagenr);
        assert err != KOM_ERR_SUCCESS();
    } else {
        ghost var s1;
        ghost var s2;

        ghost var l1p := l1pOfDispatcher(s.d, pagenr);

        ghost var s_stash;
        s_stash := stash_banked_regs(s_err.(hw := this));

        s1 := s_stash.(hw := this);  

        assert errCheck(s, s1);

        //assert err == KOM_ERR_SUCCESS();
        //assert tuple(s1.d, err) == smc_resume(s.d, pagenr);
        //assert validSysState'(s1);
        //assert this == s1.hw;
        //assert SaneState(s1.hw);

        assert r5 == pagenr;
        s2 := pre_entry_resume(err,r5,s1);
        assert preEntryResume(s1,s2,pagenr);
        //assert OperandContents(s.hw, OLR) ==
        //    s2.d[s2.g.g_cur_dispatcher].entry.ctxt.pc;

        //assert s2.d == s1.d;

        assert spsr_of_state(s2.hw).m == User;

        MOVS_PCLR_TO_USERMODE_AND_CONTINUE();
        exists ex, s3, s4, s5 :: ValidState(s3) && ValidState(s4) && ValidState(s5)
            && evalEnterUserspace(s2.hw, s3)
            && evalUserspaceExecution(s3, s4)
            && evalExceptionTaken(s4, ex, s5)
            && ApplicationUsermodeContinuationInvariant(s5, this);
     
        assert validSysState'(s2);
      
        ghost var g := s2.g;

        ghost var d := s.d;
        //assert s1.d == d;
        //assert s2.d == d;
        assert s1.d == specPageDb(smc_resume(s.d, pagenr));

        ghost var ss3 := SysState(s3,d,g);
        ghost var ss4 := SysState(s4,d,g);
        ghost var ss5 := SysState(s5,d,g);

        ghost var pre_unstash := ss5.(hw := this);

        assert validSysStates(set(s2,ss3,ss4,ss5));
        assert preEntryResume(s1,s2,pagenr);

        forall :: entryTransitionResume(s2, ss3)
            && validSysState'(ss3)
        {

            reveal_validPageDb();
            reveal_ValidRegState();
            assert validSysState'(s1);
            assert s1.d == d;
            assert s2.d == d;
            assert ss3.d == d;
            assert ss3.hw.conf.ttbr0.ptbase == s2.hw.conf.ttbr0.ptbase;
            assert nonStoppedL1(d, securePageFromPhysAddr(s2.hw.conf.ttbr0.ptbase));
            assert nonStoppedL1(d, securePageFromPhysAddr(ss3.hw.conf.ttbr0.ptbase));

            assert OperandContents(s2.hw, OLR) == 
                s2.d[s2.g.g_cur_dispatcher].entry.ctxt.pc;

            assert validSysState'(s2);
            assert validSysState'(ss3);
            assert entryTransitionResume(s2, ss3);
        }

        assert ss4.d == ss3.d;
        assert ss5.d == ss4.d;
        forall :: userspaceExecution(ss3.hw, ss5.hw, ss3.d)
            && validSysState'(ss4)
            && validSysState'(ss5)
        {
            assert evalUserspaceExecution(ss3.hw, ss4.hw);
            assert evalExceptionTaken(ss4.hw, ex, ss5.hw);
           
            assert mode_of_state(ss5.hw) != User;
            forall :: WSMemInvariantExceptAddrspace(ss3.hw, ss5.hw, d) {
                UserExecutionMemInvariant(ss3.hw,ss4.hw,d,l1p);
                assert WSMemInvariantExceptAddrspaceAtPage(ss3.hw, ss4.hw, d, l1p); 
                assert WSMemInvariantExceptAddrspaceAtPage(ss4.hw, ss5.hw, d, l1p); 
                assert WSMemInvariantExceptAddrspaceAtPage(ss3.hw, ss5.hw, d, l1p); 
                assert ss5.hw.conf.ttbr0.ptbase == s2.hw.conf.ttbr0.ptbase;
                assert securePageFromPhysAddr(ss5.hw.conf.ttbr0.ptbase) == l1p;
            }
            //assert ss4.hw.conf.excount + 1 == ss5.hw.conf.excount;
            //assert ss3.hw.conf.excount == ss4.hw.conf.excount;
            //assert ss3.hw.conf.excount + 1 == ss5.hw.conf.excount;
            //assert ss5.hw.conf.exstep == ss4.hw.steps;
            //assert ss5.hw.steps == ss4.hw.steps;
            //assert ss5.hw.conf.exstep == ss5.hw.steps;
            userspaceExecutionPreservesPageDb(d,ss3.hw,ss4.hw,l1p);
            exceptionTakenPreservesPageDb(d,ss4.hw,ex,ss5.hw);
            assert validSysState'(ss4);
            assert validSysState'(ss5);
        }
        
        assert mode_of_state(ss5.hw) != User;
        assert pre_unstash.hw == this;
        reveal_ValidRegState();
        forall :: tuple(pre_unstash.hw.regs[R0], pre_unstash.hw.regs[R1], pre_unstash.d) ==
            exceptionHandled(ss5)
            && validExceptionTransition(ss5,pre_unstash,ss5.d)
            && validSysState'(pre_unstash)
            && mode_of_state(pre_unstash.hw) == Monitor
        {
            assert AUCIdef();
            assert validSysState(ss5);
            assert ApplicationUsermodeContinuationInvariant(ss5.hw, pre_unstash.hw);
            assert validExceptionTransition(ss5,pre_unstash,ss5.d);
            assert mode_of_state(ss5.hw) != User;
            assert tuple(pre_unstash.hw.regs[R0], pre_unstash.hw.regs[R1], pre_unstash.d) ==
                    exceptionHandled_premium(ss5);
            assert validSysState'(pre_unstash);
            reveal_validExceptionTransition();
            assert mode_of_state(pre_unstash.hw) == Monitor;
        }

        s':= unstash_banked_regs(pre_unstash);
        assert this == s'.hw;

        forall :: tuple(s'.hw.regs[R0], s'.hw.regs[R1], s'.d) ==
            exceptionHandled(ss5)
            && validExceptionTransition(ss5,s',ss5.d)
            && validSysState'(s')
        {
            assert pre_unstash.hw.regs[R0] == s'.hw.regs[R0];
            assert pre_unstash.hw.regs[R1] == s'.hw.regs[R1];
            assert pre_unstash.d == s'.d;
            assert pre_unstash.hw.m.addresses == s'.hw.m.addresses;
            assert pre_unstash.g.g_cur_dispatcher == s'.g.g_cur_dispatcher;
            assert pre_unstash.hw.conf.ttbr0 == s'.hw.conf.ttbr0;
            assert validSysState'(s');
            //assert tuple(pre_unstash.hw.regs[R0], pre_unstash.hw.regs[R1], pre_unstash.d) ==
            //        exceptionHandled_premium(ss5);
            //assert tuple(s'.hw.regs[R0], s'.hw.regs[R1], s'.d) ==
            //        exceptionHandled_premium(ss5);
            reveal_validExceptionTransition();
            //assert validExceptionTransition(ss5,pre_unstash,ss5.d);
            //assert validExceptionTransition(ss5,s',ss5.d);
        }

        forall :: bankedRegsPreserved(s.hw, s'.hw)
        {
            reveal_ValidConfig();
            reveal_ValidSRegState();
            assert s2.g.g_sps == s_stash.g.g_sps;
            assert s2.g.g_lrs == s_stash.g.g_lrs;
            assert s2.g.g_psrs == s_stash.g.g_psrs;
            assert pre_unstash.g == s2.g;
            assert pre_unstash.g.g_sps == s_stash.g.g_sps;
            assert pre_unstash.g.g_lrs == s_stash.g.g_lrs;
            assert pre_unstash.g.g_psrs == s_stash.g.g_psrs;
            assert s.hw.sregs[spsr(Monitor)] == s_stash.g.g_psrs[Monitor];
            assert s'.hw.sregs[spsr(Monitor)] == pre_unstash.g.g_psrs[Monitor];
            assert s.hw.sregs[spsr(Monitor)] == s'.hw.sregs[spsr(Monitor)];
         
            // I wish I knew the syntax for "m in set" in Spartan.
            forall m :| m == FIQ || m == IRQ || m == Supervisor ||
                m == Abort || m == Undefined || m == Monitor ::
            s'.hw.regs[LR(m)] == s.hw.regs[LR(m)] &&
            s'.hw.regs[SP(m)] == s.hw.regs[SP(m)]
            {
                assert s_err.hw.regs[LR(m)] == s_stash.g.g_lrs[m];
                assert s.hw.regs[LR(m)] == s_stash.g.g_lrs[m];
                assert s'.hw.regs[LR(m)] == pre_unstash.g.g_lrs[m];

                assert s_err.hw.regs[SP(m)] == s_stash.g.g_sps[m];
                assert s.hw.regs[SP(m)] == s_stash.g.g_sps[m]; 
                assert s'.hw.regs[SP(m)] == pre_unstash.g.g_sps[m];
            }

        }
        
        forall :: SaneState(s'.hw)
        {
            reveal_validExceptionTransition();
            assert ValidStack(s'.hw);
        }

        assert validSysStates(set(s1,s2,ss3,ss5));
        assert errCheck(s, s1);
        assert preEntryResume(s1, s2, pagenr);
        assert entryTransitionResume(s2, ss3);
        assert ss5.d == ss3.d;
        assert userspaceExecution(ss3.hw, ss5.hw, ss3.d);
        assert validExceptionTransition(ss5, s',ss5.d);
        assert mode_of_state(ss5.hw) != User;

        assert validResume(s,s',pagenr);
    }
}
