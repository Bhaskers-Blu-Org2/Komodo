#verbatim
// we don't know where the stack is exactly, but we know how big it is
function {:axiom} StackLimit():int
    ensures WordAligned(StackLimit())
    ensures KEVLAR_MON_VBASE() <= StackLimit()
    ensures StackLimit() <= KEVLAR_DIRECTMAP_VBASE() - KEVLAR_STACK_SIZE()

function StackBase():int
{
    StackLimit() + KEVLAR_STACK_SIZE()
}

predicate ValidStack(s:sp_state)
    requires ValidState(s)
{
    WordAligned(eval_op(s, op_sp()))
    && StackLimit() < eval_op(s, op_sp()) <= StackBase()
    && ValidMemRange(s, StackLimit(), StackBase())
}

predicate StackBytesRemaining(s:sp_state,bytes:int)
{
    ValidState(s) && ValidStack(s) &&
    (StackLimit() + bytes < eval_op(s,op_sp()) <= StackBase())
}

predicate RegPreservingExcept(s:sp_state, r:sp_state, trashed:seq<operand>)
    requires ValidState(s) && ValidState(r);
    requires forall o :: o in trashed ==> ValidRegOperand(s, o) && ValidRegOperand(r, o);
{
    (OReg(R0) in trashed || eval_op(s,OReg(R0)) == eval_op(r,OReg(R0)))
    && (OReg(R1) in trashed || eval_op(s,OReg(R1)) == eval_op(r,OReg(R1)))
    && (OReg(R2) in trashed || eval_op(s,OReg(R2)) == eval_op(r,OReg(R2)))
    && (OReg(R3) in trashed || eval_op(s,OReg(R3)) == eval_op(r,OReg(R3)))
    && (OReg(R4) in trashed || eval_op(s,OReg(R4)) == eval_op(r,OReg(R4)))
    && (OReg(R5) in trashed || eval_op(s,OReg(R5)) == eval_op(r,OReg(R5)))
    && (OReg(R6) in trashed || eval_op(s,OReg(R6)) == eval_op(r,OReg(R6)))
    && (OReg(R7) in trashed || eval_op(s,OReg(R7)) == eval_op(r,OReg(R7)))
    && (OReg(R8) in trashed || eval_op(s,OReg(R8)) == eval_op(r,OReg(R8)))
    && (OReg(R9) in trashed || eval_op(s,OReg(R9)) == eval_op(r,OReg(R9)))
    && (OReg(R10) in trashed || eval_op(s,OReg(R10)) == eval_op(r,OReg(R10)))
    && (OReg(R11) in trashed || eval_op(s,OReg(R11)) == eval_op(r,OReg(R11)))
    && (OReg(R12) in trashed || eval_op(s,OReg(R12)) == eval_op(r,OReg(R12)))
    && (op_sp() in trashed || eval_op(s,op_sp()) == eval_op(r,op_sp()))
    && (op_lr() in trashed || eval_op(s,op_lr()) == eval_op(r,op_lr()))
}

predicate NonvolatileRegPreserving(s:sp_state, r:sp_state)
    requires ValidState(s) && ValidState(r);
{
    RegPreservingExcept(s, r, [OReg(R0), OReg(R1), OReg(R2), OReg(R3)])
}

// XXX: delete this nonsense, as soon as we can figure out how
predicate MemValidityPreserving(s:sp_state, r:sp_state)
    requires ValidState(s) && ValidState(r);
{
    forall i:int :: ValidMem(s,Address(i)) ==> ValidMem(r,Address(i))
}

predicate MemPreserving(s:sp_state, r:sp_state)
    requires ValidState(s) && ValidState(r);
{
    forall i:int :: ValidMem(s,Address(i)) ==>
        ValidMem(r,Address(i)) && addrval(s,i) == addrval(r,i)
}

predicate ParentStackPreserving(s:sp_state, r:sp_state)
    requires ValidState(s) && ValidState(r);
    requires ValidStack(s) && ValidStack(r);
{
    var sp := eval_op(s,op_sp());
    forall i :: ValidMem(s,Address(i)) && (sp <= i < StackBase())
      ==> ValidMem(r,Address(i)) && addrval(r,i) == addrval(s,i)
}

predicate StackPreserving(s:sp_state, r:sp_state)
    requires ValidState(s) && ValidState(r);
    requires ValidStack(s) && ValidStack(r);
{
    eval_op(s,op_sp()) == eval_op(r,op_sp())
    && ParentStackPreserving(s, r)
}

predicate NonStackMemPreserving(s:sp_state, r:sp_state)
    requires ValidState(s) && ValidState(r);
{
    forall i:int {:trigger Address(i)}
        :: !(StackLimit() <= i < StackBase()) && ValidMem(s,Address(i))
        ==> ValidMem(r,Address(i)) && addrval(r,i) == addrval(s,i)
}

predicate GlobalValuePreserving(s:sp_state, r:sp_state)
    requires ValidState(s) && ValidState(r);
{
    assert ValidGlobalState(s) && ValidGlobalState(r);
    forall g :: ValidGlobal(g) ==> GlobalFullContents(s, g) == GlobalFullContents(r, g)
}

#endverbatim

procedure fcall_prologue(ghost stack_bytes:int)
    requires/ensures
        SaneState(this);
    requires
        stack_bytes >= 40; 
        StackBytesRemaining(this,stack_bytes);
    ensures
        sp == old(sp-40);
        
        //preserves function call argument registers 
        r0 == old(r0);
        r1 == old(r1);
        r2 == old(r2);
        r3 == old(r3);

        // pushes r4-r11, sp, lr
        addrval(this, sp)    == old(r12);
        addrval(this, sp+4)  == old(r11);
        addrval(this, sp+8)  == old(r10);
        addrval(this, sp+12) == old(r9);
        addrval(this, sp+16) == old(r8);
        addrval(this, sp+20) == old(r7);
        addrval(this, sp+24) == old(r6);
        addrval(this, sp+28) == old(r5);
        addrval(this, sp+32) == old(r4);
        addrval(this, sp+36) == old(lr);

        NonStackMemPreserving(old(this),this);
        ParentStackPreserving(old(this),this);
        GlobalValuePreserving(old(this),this);
        
        StackBytesRemaining(this,stack_bytes-40);
{
    SUB(sp, sp, 40);

    //push link register onto stack
    STR(lr, sp, 36);

    //push r4-r11 onto stack
    STR(r4,  sp, 32);
    STR(r5,  sp, 28);
    STR(r6,  sp, 24);
    STR(r7,  sp, 20);
    STR(r8,  sp, 16);
    STR(r9,  sp, 12);
    STR(r10, sp, 8);
    STR(r11, sp, 4);
    STR(r12, sp, 0);
}

procedure fcall_epilogue(ghost stack_bytes_left:int)
    requires/ensures
        SaneState(this);
    requires
        isUInt32(sp + 40);
        sp + 40 <= StackBase();
        StackBytesRemaining(this,stack_bytes_left);
    ensures
        sp == old(sp+40);
       
        // fcall argument regs preserved. 
        r0 == old(r0);
        r1 == old(r1);
        r2 == old(r2);
        r3 == old(r3);

        // pop lr, r4-r11 from stack.
        lr  == old(addrval(this, sp+36));
        r4  == old(addrval(this, sp+32));
        r5  == old(addrval(this, sp+28));
        r6  == old(addrval(this, sp+24));
        r7  == old(addrval(this, sp+20));
        r8  == old(addrval(this, sp+16));
        r9  == old(addrval(this, sp+12));
        r10 == old(addrval(this, sp+8));
        r11 == old(addrval(this, sp+4));
        r12 == old(addrval(this, sp));

        MemPreserving(old(this),this);
        GlobalValuePreserving(old(this),this);

        StackBytesRemaining(this,stack_bytes_left+40);
{
    //pop r12 down to r4 from stack
    LDR(r12, sp, 0);
    LDR(r11, sp, 4);
    LDR(r10, sp, 8);
    LDR(r9,  sp, 12);
    LDR(r8,  sp, 16);
    LDR(r7,  sp, 20);
    LDR(r6,  sp, 24);
    LDR(r5,  sp, 28);
    LDR(r4,  sp, 32);

    //pop link register from stack
    LDR(lr, sp, 36);
    ADD(sp, sp, 40);
}
