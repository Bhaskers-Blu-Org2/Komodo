#verbatim
predicate ValidStack(s:sp_state)
    requires ValidState(s)
{
    ValidMemRange(s, STACK_LOWER(), STACK_UPPER()) &&
    MemRangeIs32(s, STACK_LOWER(), STACK_UPPER()) &&
    WordAligned(eval_op(s, op_sp())) &&
    (STACK_LOWER() <= eval_op(s, op_sp()) < STACK_UPPER())
}

predicate can_fcall_n(s:sp_state,bytes:int)
{
    ValidState(s) && ValidStack(s) &&
    (STACK_LOWER() + bytes <= eval_op(s,op_sp()) < STACK_UPPER())
}

predicate RegPreserving(s:sp_state, r:sp_state)
    requires ValidState(s) && ValidState(r);
{
    eval_op(s,op_r(4))  == eval_op(r,op_r(4))  &&
    eval_op(s,op_r(5))  == eval_op(r,op_r(5))  &&
    eval_op(s,op_r(6))  == eval_op(r,op_r(6))  &&
    eval_op(s,op_r(7))  == eval_op(r,op_r(7))  &&
    eval_op(s,op_r(8))  == eval_op(r,op_r(8))  &&
    eval_op(s,op_r(9))  == eval_op(r,op_r(9))  &&
    eval_op(s,op_r(10)) == eval_op(r,op_r(10)) &&
    eval_op(s,op_r(11)) == eval_op(r,op_r(11)) &&
    eval_op(s,op_r(12)) == eval_op(r,op_r(12)) &&
    eval_op(s,op_sp())  == eval_op(r,op_sp())
}

predicate MemValidityPreserving(s:sp_state, r:sp_state)
{
    forall i:int :: ValidMem(s,Address(i)) ==> ValidMem(r,Address(i))
}

predicate ValidMemIs32(s:sp_state)
{
    forall i:int :: ValidMem(s,Address(i)) && WordAligned(i)
        ==> isUInt32(addrval(s,i))
}

predicate MemValuePreserving(s:sp_state, r:sp_state)
    requires MemValidityPreserving(s,r);
{
    forall i:int :: ValidMem(s,Address(i)) && WordAligned(i) ==>
        addrval(s,i) == addrval(r,i)
}

predicate StackValuePreserving(s:sp_state, r:sp_state, bytes_touched:int)
    requires ValidState(s) && ValidState(r);
    requires ValidStack(s) && ValidStack(r);
    requires MemValidityPreserving(s,r);
{
    forall i:int :: WordAligned(i) &&
        !(eval_op(s,op_sp()) - bytes_touched <= i < eval_op(s,op_sp())) &&
        (STACK_LOWER() <= i < STACK_UPPER()) && ValidMem(s,Address(i)) ==>
            addrval(r,i) == addrval(s,i)
}

predicate NonStackValuePreserving(s:sp_state, r:sp_state)
    requires ValidState(s) && ValidState(r);
    requires MemValidityPreserving(s,r);
{
    forall i:int {:trigger Address(i)} :: !(STACK_LOWER() <= i < STACK_UPPER()) &&
        ValidMem(s,Address(i)) && WordAligned(i) ==> addrval(r,i) == addrval(s,i)
}

#endverbatim

procedure fcall_prologue(ghost stack_bytes:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
    requires
        stack_bytes > 80; // TODO get this to >= 1?
        can_fcall_n(this,stack_bytes);
    ensures
        sp == old(sp-40);
        
        //preserves function call argument registers 
        r0 == old(r0);
        r1 == old(r1);
        r2 == old(r2);
        r3 == old(r3);

        // pushes r4-r11, sp, lr
        addrval(this, sp)    == old(r12);
        addrval(this, sp+4)  == old(r11);
        addrval(this, sp+8)  == old(r10);
        addrval(this, sp+12) == old(r9);
        addrval(this, sp+16) == old(r8);
        addrval(this, sp+20) == old(r7);
        addrval(this, sp+24) == old(r6);
        addrval(this, sp+28) == old(r5);
        addrval(this, sp+32) == old(r4);
        addrval(this, sp+36) == old(lr);

        MemValidityPreserving(old(this),this);
        NonStackValuePreserving(old(this),this);
        StackValuePreserving(old(this),this,40);
        
        can_fcall_n(this,stack_bytes-40);
{
    SUB(sp, sp, 40);

    assert MemValidityPreserving(old(this), this);
    assert ValidMem(this, Address(sp+44)) ==>
        addrval(this, sp+44) == addrval(old(this), sp+44);

    //push link register onto stack
    STR(lr, sp, 36);

    //push r4-r11 onto stack
    STR(r4,  sp, 32);
    STR(r5,  sp, 28);
    STR(r6,  sp, 24);
    STR(r7,  sp, 20);
    STR(r8,  sp, 16);
    STR(r9,  sp, 12);
    STR(r10, sp, 8);
    STR(r11, sp, 4);
    STR(r12, sp, 0);

    assert ValidMem(this, Address(sp+44)) ==>
        addrval(this, sp+44) == addrval(old(this), sp+44);

    // forall :: StackValuePreserving(old(this),this,40){
    //     assert forall i:int :: ValidMem(this, Address(i)) && WordAligned(i) &&
    //         (i >= sp + 40) ==> addrval(this, i) == addrval(old(this), i);
    //     assert forall i:int :: ValidMem(this, Address(i)) && WordAligned(i) &&
    //         (i >= old(sp)) ==> addrval(this, i) == addrval(old(this), i);
    //     assert forall i:int :: ValidMem(this, Address(i)) && WordAligned(i) &&
    //         (i < sp) ==> addrval(this, i) == addrval(old(this), i);
    //     assert forall i:int :: ValidMem(this, Address(i)) && WordAligned(i) &&
    //         (i < old(sp-40)) ==> addrval(this, i) == addrval(old(this), i);
    //     assert forall i:int :: ValidMem(this, Address(i)) && WordAligned(i) &&
    //         !(sp <= i < sp +40) ==> addrval(this, i) == addrval(old(this), i);
    //     assert forall i:int :: ValidMem(this, Address(i)) && WordAligned(i) &&
    //         !(old(sp-40) <= i < old(sp)) ==> addrval(this, i) == addrval(old(this), i);
    // }

    // forall :: StackValuePreserving(old(this),this,stack_bytes-40)
    // {
    //     assert NonStackValuePreserving(old(this),this);
    //     assert addrval(this, old(sp-(stack_bytes-44))) == addrval(old(this), old(sp-(stack_bytes-44)));
    //     assert addrval(this, old(sp-(stack_bytes-40))) == addrval(old(this), old(sp-(stack_bytes-40)));
    //     assert forall i:int :: WordAligned(i) && ValidMem(old(this),Address(i)) &&
    //         !(old(sp)-(stack_bytes-40) < i <= old(sp)) ==> addrval(this,i) == addrval(old(this), i);
    //     // assert forall i:int :: !(old(sp)-(stack_bytes-40) < i <= old(sp)) &&
    //     //     (STACK_LOWER() <= i < STACK_UPPER()) ==> !(old(sp)-(stack_bytes-40) < i <= old(sp));
    //     // assert forall i:int :: WordAligned(i) && ValidMem(old(this),Address(i)) &&
    //     //     (STACK_LOWER() <= i < STACK_UPPER()) &&
    //     //     !( old(sp)-(stack_bytes-40) < i <= old(sp) ) ==> addrval(this,i) == addrval(old(this), i);
    //     // assert StackValuePreserving(old(this),this,stack_bytes-40);
}

procedure fcall_epilogue(ghost stack_bytes_left:int)
    requires/ensures
        ValidState(this);
        ValidStack(this);
        ValidMemIs32(this);
    requires
        0 <= sp + 40 < MaxVal();
        sp + 40 < STACK_UPPER();
        can_fcall_n(this,stack_bytes_left);
    ensures
        sp == old(sp+40);
       
        // fcall argument regs preserved. 
        r0 == old(r0);
        r1 == old(r1);
        r2 == old(r2);
        r3 == old(r3);

        // pop lr, r4-r11 from stack.
        lr  == old(addrval(this, sp+36));
        r4  == old(addrval(this, sp+32));
        r5  == old(addrval(this, sp+28));
        r6  == old(addrval(this, sp+24));
        r7  == old(addrval(this, sp+20));
        r8  == old(addrval(this, sp+16));
        r9  == old(addrval(this, sp+12));
        r10 == old(addrval(this, sp+8));
        r11 == old(addrval(this, sp+4));
        r12 == old(addrval(this, sp));

        MemValidityPreserving(old(this),this);        
        MemValuePreserving(old(this),this);

        can_fcall_n(this,stack_bytes_left+40);
{
    //pop r12 down to r4 from stack
    LDR(r12, sp, 0);
    LDR(r11, sp, 4);
    LDR(r10, sp, 8);
    LDR(r9,  sp, 12);
    LDR(r8,  sp, 16);
    LDR(r7,  sp, 20);
    LDR(r6,  sp, 24);
    LDR(r5,  sp, 28);
    LDR(r4,  sp, 32);

    //pop link register from stack
    LDR(lr, sp, 36);
    ADD(sp, sp, 40);
}
