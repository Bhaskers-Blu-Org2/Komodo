include verbatim "kom_common.i.dfy"
include verbatim "pagedb.i.dfy"
include verbatim "smcapi.i.dfy"

include "ARMdecls-unrefined.sdfy"
include verbatim "ARMdecls-unrefined.gen.dfy"
include "kom_utils.sdfy"
include verbatim "kom_utils.gen.dfy"

procedure kom_smc_finalise(
    {:register OReg(R1)} as_page:int,
    out {:register OReg(R0)} err:int,
    ghost pagedb_in:PageDb)
    returns(ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    ensures
        SmcProcedureInvariant(old(this),this);
        tuple(pagedb,err) == smc_finalise_premium(pagedb_in, as_page);
        pageDbCorresponds(this.m, pagedb);
{
    reveal_smc_finalise_premium();
    pagedb := pagedb_in;
    ghost var specResult := smc_finalise_premium(pagedb, as_page);

    if (as_page >= sp_op_const(KOM_SECURE_NPAGES)) {
        err := sp_op_const(KOM_ERR_INVALID_ADDRSPACE);
    } else {
        assert validPageNr(as_page);
        LDRglobaladdr(r12, PageDb());
        lemma_LeftShift3(as_page);
        LSL(r4, as_page, sp_op_const(PAGEDB_ENTRY_SHIFT));
        assert r4 == G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE;
        LDRglobal(r3, PageDb(), r12, r4);

        forall :: r3 == pageDbEntryTypeVal(pagedb[as_page]) {
            assert r3 == GlobalWord(this.m, PageDb(), G_PAGEDB_ENTRY(as_page) + PAGEDB_ENTRY_TYPE);
            extractPageDbToAbstract(this.m, as_page);
            reveal_pageDbEntryCorresponds();
        }

        if (r3 != sp_op_const(KOM_PAGE_ADDRSPACE)) {
            assert !isAddrspace(pagedb, as_page);
            err := sp_op_const(KOM_ERR_INVALID_ADDRSPACE);
            assert err == specErr(specResult);
        } else {
            page_monvaddr_impl(r2,as_page,r3);
            LDR(r3,r2,sp_op_const(ADDRSPACE_STATE));

            forall :: r3 == pageDbAddrspaceStateVal(pagedb[as_page].entry.state)
            {
                reveal_validPageDb();
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            if(r3 != sp_op_const(KOM_ADDRSPACE_INIT)) {
                assert pagedb[as_page].entry.state != InitState;
                err := sp_op_const(KOM_ERR_ALREADY_FINAL);
                assert err == specErr(specResult);
            } else {
                assert pagedb[as_page].entry.state == InitState;
                r3 := sp_op_const(KOM_ADDRSPACE_FINAL);
                assert r3 == pageDbAddrspaceStateVal(FinalState);
                STR(r3, r2, sp_op_const(ADDRSPACE_STATE));
                assert MemContents(this.m, page_monvaddr(as_page) + 
                    ADDRSPACE_STATE) == pageDbAddrspaceStateVal(FinalState);
                forall :: pageDbCorrespondsOnly(this.m, specPageDb(specResult), as_page)
                {
                    ghost var d' := specPageDb(specResult);
                    reveal_validPageDb();
                    reveal_pageContentsCorresponds();
                    reveal_pageDbAddrspaceCorresponds();
                    assert pageContentsCorresponds(as_page, d'[as_page], 
                        extractPage(this.m, as_page));
                    reveal_pageDbEntryCorresponds();
                    assert pageDbEntryCorresponds(d'[as_page], 
                        extractPageDbEntry(this.m, as_page));
                
                }
                forall :: pageDbCorrespondsExcluding(this.m, specPageDb(specResult), as_page)
                {
                    reveal_validPageDb();
                    reveal_pageContentsCorresponds();
                    reveal_pageDbAddrspaceCorresponds();
                    ghost var d' := specPageDb(specResult);
                    assert pageDbCorrespondsExcluding(old(this).m, pagedb, as_page);
                    forall :: pageDbCorrespondsExcluding(this.m, pagedb, as_page)
                    {
                        forall p :| validPageNr(p) && p != as_page ::
                            extractPage(this.m, p) ==
                                extractPage(old(this).m, p) {}
                                
                    }
                    forall p :| validPageNr(p) && p != as_page ::
                        pagedb[p] == d'[p] {}
                }
                pagedb := specPageDb(specResult);
                err := sp_op_const(KOM_ERR_SUCCESS);
            }
        }
    }
}
