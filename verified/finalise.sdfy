include {:verbatim} "kom_common.i.dfy"
include {:verbatim} "pagedb.i.dfy"
include {:verbatim} "smcapi.i.dfy"

include "ARMdecls.sdfy"
include "kom_utils.sdfy"

procedure kom_smc_finalise(
    operand as_page:reg,
    operand pagedb_base:reg,
    out operand err:reg,
    ghost pagedb_in:PageDb)
    returns (ghost pagedb:PageDb)
    requires/ensures
        SaneState(this);
    requires
        @as_page == OReg(R1) && @err == OReg(R0) && @pagedb_base == OReg(R12);
        pagedb_base == AddressOfGlobal(PageDb());
        validPageDb(pagedb_in);
        pageDbCorresponds(this.m, pagedb_in);
    reads
        globals;
    modifies
        mem; r2;
    ensures
        SmcProcedureInvariant(old(this), this);
        tuple(pagedb, err) == smc_finalise_premium(pagedb_in, old(as_page));
        pageDbCorresponds(this.m, pagedb);
{
    reveal smc_finalise_premium;
    pagedb := pagedb_in;
    ghost var specResult := smc_finalise_premium(pagedb, as_page);

    if (as_page >= const(KOM_SECURE_NPAGES)) {
        err := const(KOM_ERR_INVALID_ADDRSPACE);
    } else {
        assert validPageNr(as_page);
        load_page_type(as_page, pagedb_base, err, err, pagedb);

        if (err != const(KOM_PAGE_ADDRSPACE)) {
            assert !isAddrspace(pagedb, as_page);
            err := const(KOM_ERR_INVALID_ADDRSPACE);
            assert err == specErr(specResult);
        } else {
            page_monvaddr_impl(r2, as_page, err);
            LDR(err, r2, const(ADDRSPACE_STATE));

            forall :: err == pageDbAddrspaceStateVal(pagedb[as_page].entry.state)
            {
                reveal_validPageDb();
                reveal_pageContentsCorresponds();
                reveal_pageDbAddrspaceCorresponds();
            }

            if(err != const(KOM_ADDRSPACE_INIT)) {
                assert pagedb[as_page].entry.state != InitState;
                err := const(KOM_ERR_ALREADY_FINAL);
                assert err == specErr(specResult);
            } else {
                assert pagedb[as_page].entry.state == InitState;
                err := const(KOM_ADDRSPACE_FINAL);
                assert err == pageDbAddrspaceStateVal(FinalState);
                STR(err, r2, const(ADDRSPACE_STATE));
                assert MemContents(this.m, page_monvaddr(as_page) + 
                    ADDRSPACE_STATE) == pageDbAddrspaceStateVal(FinalState);
                forall :: pageDbCorrespondsOnly(this.m, specPageDb(specResult), as_page)
                {
                    ghost var d' := specPageDb(specResult);
                    reveal_validPageDb();
                    reveal_pageContentsCorresponds();
                    reveal_pageDbAddrspaceCorresponds();
                    assert pageContentsCorresponds(as_page, d'[as_page], 
                        extractPage(this.m, as_page));
                    reveal_pageDbEntryCorresponds();
                    assert pageDbEntryCorresponds(d'[as_page], 
                        extractPageDbEntry(this.m, as_page));
                
                }
                forall :: pageDbCorrespondsExcluding(this.m, specPageDb(specResult), as_page)
                {
                    reveal_validPageDb();
                    reveal_pageContentsCorresponds();
                    reveal_pageDbAddrspaceCorresponds();
                    ghost var d' := specPageDb(specResult);
                    assert pageDbCorrespondsExcluding(old(this).m, pagedb, as_page);
                    forall :: pageDbCorrespondsExcluding(this.m, pagedb, as_page)
                    {
                        forall p :| validPageNr(p) && p != as_page ::
                            extractPage(this.m, p) ==
                                extractPage(old(this).m, p) {}
                                
                    }
                    forall p :| validPageNr(p) && p != as_page ::
                        pagedb[p] == d'[p] {}
                }
                pagedb := specPageDb(specResult);
                err := const(KOM_ERR_SUCCESS);
            }
        }
    }
}
